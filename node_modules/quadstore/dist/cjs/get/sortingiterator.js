"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SortingIterator = void 0;
const asynciterator_1 = require("asynciterator");
const stuff_1 = require("../utils/stuff");
let sortedSetImportErr;
let SortedSet = class {
    constructor() {
        throw new Error(`Failed to require module js-sorted-set: ${sortedSetImportErr?.message}`);
    }
};
Promise.resolve().then(() => __importStar(require('js-sorted-set'))).then((_) => { SortedSet = _.default; })
    .catch((err) => { sortedSetImportErr = err; });
class SortingIterator extends asynciterator_1.AsyncIterator {
    constructor(source, compare, digest, emit) {
        super();
        let iterator;
        const startBuffering = () => {
            const set = new SortedSet({ comparator: compare });
            const cleanup = () => {
                source.removeListener('data', onData);
                source.removeListener('error', onError);
                source.removeListener('end', onEnd);
                source.destroy();
            };
            const onData = (item) => {
                set.insert(digest(item));
            };
            const onError = (err) => {
                cleanup();
                this.emit('error', err);
            };
            const onEnd = () => {
                cleanup();
                iterator = set.beginIterator();
                this.readable = true;
            };
            source.on('data', onData);
            source.on('error', onError);
            source.on('end', onEnd);
        };
        this.read = () => {
            if (iterator) {
                const value = iterator.value();
                if (value === null) {
                    this.close();
                    return null;
                }
                iterator = iterator.next();
                return emit(value);
            }
            this.readable = false;
            return null;
        };
        stuff_1.RESOLVED.then(startBuffering).catch((err) => {
            stuff_1.RESOLVED.then(() => this.emit('error', err));
        });
    }
}
exports.SortingIterator = SortingIterator;
//# sourceMappingURL=sortingiterator.js.map