import * as __QUADSTORE_COMUNICA_EXTERNAL_MODULE_asynciterator__ from "asynciterator";
import * as __QUADSTORE_COMUNICA_EXTERNAL_MODULE_sparqlalgebrajs__ from "sparqlalgebrajs";
import * as __QUADSTORE_COMUNICA_EXTERNAL_MODULE_sparqljs__ from "sparqljs";
/******/ var __quadstore_comunica_modules__ = ({

/***/ "../node_modules/@comunica/actor-abstract-path/lib/ActorAbstractPath.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorAbstractPath = void 0;
const bindings_factory_1 = __quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/index.js");
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const context_entries_1 = __quadstore_comunica_require__("../node_modules/@comunica/context-entries/lib/index.js");
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const rdf_string_1 = __quadstore_comunica_require__("../node_modules/rdf-string/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
const PathVariableObjectIterator_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-abstract-path/lib/PathVariableObjectIterator.js");
const DF = new rdf_data_factory_1.DataFactory();
const BF = new bindings_factory_1.BindingsFactory();
/**
 * An abstract actor that handles Path operations.
 *
 * Provides multiple helper functions used by the Path operation actors.
 */
class ActorAbstractPath extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args, predicateType) {
        super(args, 'path');
        this.predicateType = predicateType;
    }
    async testOperation(operation, context) {
        if (operation.predicate.type !== this.predicateType) {
            throw new Error(`This Actor only supports ${this.predicateType} Path operations.`);
        }
        return true;
    }
    // Generates a variable that does not yet occur in the path
    generateVariable(path, name) {
        if (!name) {
            return this.generateVariable(path, 'b');
        }
        // Path predicates can't contain variables
        if (path && (path.subject.value === name || path.object.value === name)) {
            return this.generateVariable(path, `${name}b`);
        }
        return DF.variable(name);
    }
    // Such connectivity matching does not introduce duplicates (it does not incorporate any count of the number
    // of ways the connection can be made) even if the repeated path itself would otherwise result in duplicates.
    // https://www.w3.org/TR/sparql11-query/#propertypaths
    async isPathArbitraryLengthDistinct(context, path) {
        if (!context.get(context_entries_1.KeysQueryOperation.isPathArbitraryLengthDistinctKey)) {
            context = context.set(context_entries_1.KeysQueryOperation.isPathArbitraryLengthDistinctKey, true);
            return { context,
                operation: bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
                    operation: ActorAbstractPath.FACTORY.createDistinct(path),
                    context,
                })) };
        }
        context = context.set(context_entries_1.KeysQueryOperation.isPathArbitraryLengthDistinctKey, false);
        return { context, operation: undefined };
    }
    async predicateStarGraphVariable(subject, object, predicate, graph, context) {
        // TODO: refactor this with an iterator just like PathVariableObjectIterator so we handle backpressure correctly
        // Construct path to obtain all graphs where subject exists
        const predVar = this.generateVariable(ActorAbstractPath.FACTORY
            .createPath(subject, predicate, object, graph));
        const findGraphs = ActorAbstractPath.FACTORY.createUnion([
            ActorAbstractPath.FACTORY.createPattern(subject, predVar, object, graph),
            ActorAbstractPath.FACTORY.createPattern(object, predVar, subject, graph),
        ]);
        const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ context, operation: findGraphs }));
        const passedGraphs = new Set();
        const bindingsStream = new asynciterator_1.MultiTransformIterator(results.bindingsStream, {
            multiTransform: (bindings) => {
                // Extract the graph and start a predicate* search starting from subject in each graph
                const graphValue = bindings.get(graph);
                if (passedGraphs.has(graphValue.value)) {
                    return new asynciterator_1.EmptyIterator();
                }
                passedGraphs.add(graphValue.value);
                return new asynciterator_1.TransformIterator(async () => {
                    const it = new asynciterator_1.BufferedIterator();
                    await this.getObjectsPredicateStar(subject, predicate, graphValue, context, {}, it, { count: 0 });
                    return it.transform({
                        transform(item, next, push) {
                            push(BF.bindings([
                                [object, item],
                                [graph, graphValue],
                            ]));
                            next();
                        },
                    });
                }, { maxBufferSize: 128 });
            },
            autoStart: false,
        });
        return {
            bindingsStream,
            metadata: results.metadata,
        };
    }
    /**
     * Returns an iterator with Bindings of the query subject predicate* ?o or subject predicate+ ?o
     * If graph is a variable, it will also be in those bindings
     * @param {Term} subject Term of where we start the predicate* search.
     * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.
     * @param {Variable} object Variable of the zeroOrMore-query.
     * @param {Term} graph The graph in which we search for the pattern. (Possibly a variable)
     * @param {ActionContext} context The context to pass to sub-opertations
     * @param emitFirstSubject If the path operation is predicate*, otherwise it is predicate+.
     * @return {Promise<AsyncIterator<Bindings>} Iterator to where all bindings of query should have been pushed.
     */
    async getObjectsPredicateStarEval(subject, predicate, object, graph, context, emitFirstSubject) {
        if (graph.termType === 'Variable') {
            return this.predicateStarGraphVariable(subject, object, predicate, graph, context);
        }
        const it = new PathVariableObjectIterator_1.PathVariableObjectIterator(subject, predicate, graph, context, this.mediatorQueryOperation, emitFirstSubject);
        const bindingsStream = it.transform({
            autoStart: false,
            transform(item, next, push) {
                push(BF.bindings([[object, item]]));
                next();
            },
        });
        return {
            bindingsStream,
            metadata: () => new Promise(resolve => it.getProperty('metadata', (metadata) => resolve(metadata()))),
        };
    }
    /**
       * Pushes all terms to iterator `it` that are a solution of object predicate* ?o.
       * @param {Term} object Term of where we start the predicate* search.
       * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.
       * @param {Term} graph The graph in which we search for the pattern.
       * @param {ActionContext} context
       * @param {Record<string, Term>} termHashes Remembers the objects we've already searched for.
       * @param {BufferedIterator<Term>} it Iterator to push terms to.
       * @param {any} counter Counts how many searches are in progress to close it when needed (when counter == 0).
       * @return {Promise<IPathResultStream['metadata']>} The results metadata.
       */
    async getObjectsPredicateStar(object, predicate, graph, context, termHashes, it, counter) {
        const termString = (0, rdf_string_1.termToString)(object);
        if (termHashes[termString]) {
            return;
        }
        it._push(object);
        termHashes[termString] = object;
        counter.count++;
        const thisVariable = this.generateVariable();
        const path = ActorAbstractPath.FACTORY.createPath(object, predicate, thisVariable, graph);
        const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: path, context }));
        results.bindingsStream.on('data', async (bindings) => {
            const result = bindings.get(thisVariable);
            await this.getObjectsPredicateStar(result, predicate, graph, context, termHashes, it, counter);
        });
        results.bindingsStream.on('end', () => {
            if (--counter.count === 0) {
                it.close();
            }
        });
        return results.metadata;
    }
    /**
       * Pushes all terms to iterator `it` that are a solution of ?s predicate* ?o.
       * @param {string} subjectVar String representation of subjectVariable
       * @param {string} objectVar String representation of objectVariable
       * @param {Term} subjectVal Term of where we start the predicate* search.
       * @param {Term} objectVal Found solution for an object, start for the new step.
       * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.
       * @param {Term} graph The graph in which we search for the pattern.
       * @param {ActionContext} context
       * @param {{[id: string]: Promise<Term[]>}} termHashesGlobal
       * Remembers solutions for when objectVal is already been calculated, can be reused when same objectVal occurs
       * @param {{[id: string]: Term}} termHashesCurrentSubject
       * Remembers the pairs we've already searched for, can stop searching if so.
       * @param {BufferedIterator<Bindings>} it Iterator to push terms to.
       * @param {any} counter Counts how many searches are in progress to close it when needed (when counter == 0).
       * @return {Promise<void>} All solutions of query should have been pushed to it by then.
       */
    // Let the iterator `it` emit all bindings of size 2, with subjectStringVariable as value subjectVal
    // and objectStringVariable as value all nodes reachable through predicate* beginning at objectVal
    async getSubjectAndObjectBindingsPredicateStar(subjectVar, objectVar, subjectVal, objectVal, predicate, graph, context, termHashesGlobal, termHashesCurrentSubject, it, counter) {
        const termString = (0, rdf_string_1.termToString)(objectVal) + (0, rdf_string_1.termToString)(graph);
        // If this combination of subject and object already done, return nothing
        if (termHashesCurrentSubject[termString]) {
            return;
        }
        counter.count++;
        termHashesCurrentSubject[termString] = true;
        it._push(BF.bindings([
            [subjectVar, subjectVal],
            [objectVar, objectVal],
        ]));
        // If every reachable node from object has already been calculated, use these for current subject too
        if (termString in termHashesGlobal) {
            const objects = await termHashesGlobal[termString];
            for (const object of objects) {
                await this.getSubjectAndObjectBindingsPredicateStar(subjectVar, objectVar, subjectVal, object, predicate, graph, context, termHashesGlobal, termHashesCurrentSubject, it, counter);
            }
            if (--counter.count === 0) {
                it.close();
            }
            return;
        }
        // Construct promise to calculate all reachable nodes from this object
        const promise = new Promise(async (resolve, reject) => {
            const objectsArray = [];
            // Construct path that leads us one step through predicate
            const thisVariable = this.generateVariable();
            const path = ActorAbstractPath.FACTORY.createPath(objectVal, predicate, thisVariable, graph);
            const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: path, context }));
            // Recursive call on all neighbours
            results.bindingsStream.on('data', async (bindings) => {
                const result = bindings.get(thisVariable);
                objectsArray.push(result);
                await this.getSubjectAndObjectBindingsPredicateStar(subjectVar, objectVar, subjectVal, result, predicate, graph, context, termHashesGlobal, termHashesCurrentSubject, it, counter);
            });
            results.bindingsStream.on('error', reject);
            results.bindingsStream.on('end', () => {
                if (--counter.count === 0) {
                    it.close();
                }
                resolve(objectsArray);
            });
        });
        // Set it in the termHashesGlobal when this object occurs again they can wait for this promise
        termHashesGlobal[termString] = promise;
    }
}
exports.ActorAbstractPath = ActorAbstractPath;
ActorAbstractPath.FACTORY = new sparqlalgebrajs_1.Factory();
//# sourceMappingURL=ActorAbstractPath.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-abstract-path/lib/PathVariableObjectIterator.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PathVariableObjectIterator = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const rdf_string_1 = __quadstore_comunica_require__("../node_modules/rdf-string/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
const DF = new rdf_data_factory_1.DataFactory();
const FACTORY = new sparqlalgebrajs_1.Factory();
/**
 * An iterator that implements the multi-length property path operation (* and +)
 * for a fixed subject and predicate, and a variable object.
 */
class PathVariableObjectIterator extends asynciterator_1.BufferedIterator {
    constructor(subject, predicate, graph, context, mediatorQueryOperation, emitFirstSubject, maxRunningOperations = 16) {
        // The autoStart flag must be true to kickstart metadata collection
        super({ autoStart: true });
        this.subject = subject;
        this.predicate = predicate;
        this.graph = graph;
        this.context = context;
        this.mediatorQueryOperation = mediatorQueryOperation;
        this.maxRunningOperations = maxRunningOperations;
        this.termHashes = new Map();
        this.runningOperations = [];
        this.pendingOperations = [];
        // Push the subject as starting point
        this._push(this.subject, emitFirstSubject);
    }
    _end(destroy) {
        // Close all running iterators
        for (const it of this.runningOperations) {
            it.destroy();
        }
        super._end(destroy);
    }
    _push(item, pushAsResult = true) {
        let termString;
        if (pushAsResult) {
            // Don't push if this subject was already found
            termString = (0, rdf_string_1.termToString)(item);
            if (this.termHashes.has(termString)) {
                return;
            }
        }
        // Add a pending path operation for this item
        const variable = DF.variable('b');
        this.pendingOperations.push({
            variable,
            operation: FACTORY.createPath(item, this.predicate, variable, this.graph),
        });
        // Otherwise, push the subject
        if (termString) {
            this.termHashes.set(termString, item);
            super._push(item);
        }
    }
    _read(count, done) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this
        const self = this;
        (async function () {
            // Open as many operations as possible
            while (self.runningOperations.length < self.maxRunningOperations) {
                if (self.pendingOperations.length === 0) {
                    break;
                }
                const pendingOperation = self.pendingOperations.pop();
                const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await self.mediatorQueryOperation.mediate({ operation: pendingOperation.operation, context: self.context }));
                const runningOperation = results.bindingsStream.transform({
                    autoStart: false,
                    transform(bindings, next, push) {
                        const newTerm = bindings.get(pendingOperation.variable);
                        push(newTerm);
                        next();
                    },
                });
                if (!runningOperation.done) {
                    self.runningOperations.push(runningOperation);
                    runningOperation.on('error', error => self.destroy(error));
                    runningOperation.on('readable', () => {
                        self.readable = true;
                        self._fillBufferAsync();
                    });
                    runningOperation.on('end', () => {
                        self.runningOperations.splice(self.runningOperations.indexOf(runningOperation), 1);
                        self.readable = true;
                        self._fillBufferAsync();
                    });
                }
                self.setProperty('metadata', results.metadata);
            }
            // Try to read `count` items (based on UnionIterator)
            let lastCount = 0;
            let item;
            // eslint-disable-next-line no-cond-assign
            while (lastCount !== (lastCount = count)) {
                // Prioritize the operations that have been added first
                for (let i = 0; i < self.runningOperations.length && count > 0; i++) {
                    // eslint-disable-next-line no-cond-assign
                    if ((item = self.runningOperations[i].read()) !== null) {
                        count--;
                        self._push(item);
                    }
                }
            }
            // Close if everything has been read
            if (self.runningOperations.length === 0 && self.pendingOperations.length === 0) {
                self.close();
            }
        })().then(() => {
            done();
        }, error => this.destroy(error));
    }
}
exports.PathVariableObjectIterator = PathVariableObjectIterator;
//# sourceMappingURL=PathVariableObjectIterator.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-abstract-path/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-abstract-path/lib/ActorAbstractPath.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-abstract-path/lib/PathVariableObjectIterator.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-context-preprocess-source-to-destination/lib/ActorContextPreprocessSourceToDestination.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorContextPreprocessSourceToDestination = void 0;
const bus_context_preprocess_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-context-preprocess/lib/index.js");
const context_entries_1 = __quadstore_comunica_require__("../node_modules/@comunica/context-entries/lib/index.js");
/**
 * A comunica Source To Destination Context Preprocess Actor.
 */
class ActorContextPreprocessSourceToDestination extends bus_context_preprocess_1.ActorContextPreprocess {
    constructor(args) {
        super(args);
    }
    async test(action) {
        return true;
    }
    async run(action) {
        if (action.context.get(context_entries_1.KeysRdfResolveQuadPattern.sources) && !action.context.get(context_entries_1.KeysRdfUpdateQuads.destination)) {
            const sources = action.context.get(context_entries_1.KeysRdfResolveQuadPattern.sources);
            if (sources.length === 1) {
                return { context: action.context.set(context_entries_1.KeysRdfUpdateQuads.destination, sources[0]) };
            }
        }
        return action;
    }
}
exports.ActorContextPreprocessSourceToDestination = ActorContextPreprocessSourceToDestination;
//# sourceMappingURL=ActorContextPreprocessSourceToDestination.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-context-preprocess-source-to-destination/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-context-preprocess-source-to-destination/lib/ActorContextPreprocessSourceToDestination.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-hash-bindings-sha1/lib/ActorHashBindingsSha1.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorHashBindingsSha1 = void 0;
const bus_hash_bindings_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-hash-bindings/lib/index.js");
const hash_js_1 = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash.js");
const rdf_string_1 = __quadstore_comunica_require__("../node_modules/rdf-string/index.js");
const canonicalize = __quadstore_comunica_require__("../node_modules/canonicalize/lib/canonicalize.js");
/**
 * A comunica Memento Http Actor.
 */
class ActorHashBindingsSha1 extends bus_hash_bindings_1.ActorHashBindings {
    async test(action) {
        if (!action.allowHashCollisions) {
            throw new Error(`Actor ${this.name} can not provide hash functions without hash collisions`);
        }
        return true;
    }
    async run(action) {
        return {
            hashFunction: bindings => (0, hash_js_1.sha1)()
                .update(canonicalize(Object.fromEntries([...bindings]
                .map(([key, value]) => [(0, rdf_string_1.termToString)(key), (0, rdf_string_1.termToString)(value)]))))
                .digest('hex'),
            hashCollisions: true,
        };
    }
}
exports.ActorHashBindingsSha1 = ActorHashBindingsSha1;
//# sourceMappingURL=ActorHashBindingsSha1.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-hash-bindings-sha1/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-hash-bindings-sha1/lib/ActorHashBindingsSha1.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-init-query/lib/ActorInitQuery-browser.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorInitQuery = void 0;
/* eslint-disable unicorn/filename-case */
/* eslint-enable unicorn/filename-case */
const ActorInitQueryBase_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-init-query/lib/ActorInitQueryBase.js");
/* istanbul ignore next */
if (typeof process === 'undefined') {
    // Polyfills process.nextTick for readable-stream
    __quadstore_comunica_require__.g.process = __quadstore_comunica_require__("./require-empty.js"); // eslint-disable-line import/no-nodejs-modules
}
class ActorInitQuery extends ActorInitQueryBase_1.ActorInitQueryBase {
}
exports.ActorInitQuery = ActorInitQuery;
//# sourceMappingURL=ActorInitQuery-browser.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-init-query/lib/ActorInitQueryBase.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorInitQueryBase = void 0;
const bus_init_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-init/lib/index.js");
/**
 * A browser-safe comunica Query Init Actor.
 */
class ActorInitQueryBase extends bus_init_1.ActorInit {
    constructor(args) {
        super(args);
    }
    async test(action) {
        return true;
    }
    async run(action) {
        throw new Error('ActorInitSparql#run is not supported in the browser.');
    }
}
exports.ActorInitQueryBase = ActorInitQueryBase;
//# sourceMappingURL=ActorInitQueryBase.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-init-query/lib/MemoryPhysicalQueryPlanLogger.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemoryPhysicalQueryPlanLogger = void 0;
const rdf_string_1 = __quadstore_comunica_require__("../node_modules/rdf-string/index.js");
/**
 * A physical query plan logger that stores everything in memory.
 */
class MemoryPhysicalQueryPlanLogger {
    constructor() {
        this.children = new Map();
    }
    logOperation(logicalOperator, physicalOperator, node, parentNode, actor, metadata) {
        const planNode = {
            actor,
            logicalOperator,
            physicalOperator,
            rawNode: node,
            children: [],
            metadata,
        };
        this.children.set(node, planNode.children);
        if (!this.rootNode) {
            if (parentNode) {
                throw new Error(`No root node has been set yet, while a parent is being referenced`);
            }
            this.rootNode = planNode;
        }
        else {
            if (!parentNode) {
                throw new Error(`Detected more than one parent-less node`);
            }
            const children = this.children.get(parentNode);
            if (!children) {
                throw new Error(`Could not find parent node`);
            }
            children.push(planNode);
        }
    }
    toJson() {
        return this.rootNode ? this.planNodeToJson(this.rootNode) : {};
    }
    planNodeToJson(node) {
        return {
            logical: node.logicalOperator,
            physical: node.physicalOperator,
            ...this.getLogicalMetadata(node.rawNode),
            ...node.metadata,
            ...node.children.length > 0 ? { children: node.children.map(child => this.planNodeToJson(child)) } : {},
        };
    }
    getLogicalMetadata(rawNode) {
        if ('type' in rawNode) {
            const operation = rawNode;
            // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check
            switch (operation.type) {
                case 'pattern':
                    return {
                        pattern: this.quadToString(operation),
                    };
                case 'project':
                    return {
                        variables: operation.variables.map(variable => variable.value),
                    };
            }
        }
        return {};
    }
    quadToString(quad) {
        return `${(0, rdf_string_1.termToString)(quad.subject)} ${(0, rdf_string_1.termToString)(quad.predicate)} ${(0, rdf_string_1.termToString)(quad.object)}${quad.graph.termType === 'DefaultGraph' ? '' : ` ${(0, rdf_string_1.termToString)(quad.graph)}`}`;
    }
}
exports.MemoryPhysicalQueryPlanLogger = MemoryPhysicalQueryPlanLogger;
//# sourceMappingURL=MemoryPhysicalQueryPlanLogger.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-init-query/lib/QueryEngineBase.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QueryEngineBase = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const context_entries_1 = __quadstore_comunica_require__("../node_modules/@comunica/context-entries/lib/index.js");
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
const MemoryPhysicalQueryPlanLogger_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-init-query/lib/MemoryPhysicalQueryPlanLogger.js");
/**
 * Base implementation of a Comunica query engine.
 */
class QueryEngineBase {
    constructor(actorInitQuery) {
        this.actorInitQuery = actorInitQuery;
    }
    async queryBindings(query, context) {
        return this.queryOfType(query, context, 'bindings');
    }
    async queryQuads(query, context) {
        return this.queryOfType(query, context, 'quads');
    }
    async queryBoolean(query, context) {
        return this.queryOfType(query, context, 'boolean');
    }
    async queryVoid(query, context) {
        return this.queryOfType(query, context, 'void');
    }
    async queryOfType(query, context, expectedType) {
        const result = await this.query(query, context);
        if (result.resultType === expectedType) {
            return result.execute();
        }
        throw new Error(`Query result type '${expectedType}' was expected, while '${result.resultType}' was found.`);
    }
    /**
     * Evaluate the given query
     * @param query A query string or algebra.
     * @param context An optional query context.
     * @return {Promise<QueryType>} A promise that resolves to the query output.
     */
    async query(query, context) {
        const output = await this.queryOrExplain(query, context);
        if ('explain' in output) {
            throw new Error(`Tried to explain a query when in query-only mode`);
        }
        return output;
    }
    /**
     * Explain the given query
     * @param {string | Algebra.Operation} query A query string or algebra.
     * @param context An optional query context.
     * @param explainMode The explain mode.
     * @return {Promise<QueryType | IQueryExplained>} A promise that resolves to
     *                                                               the query output or explanation.
     */
    async explain(query, context, explainMode) {
        context.explain = explainMode;
        const output = await this.queryOrExplain(query, context);
        return output;
    }
    /**
     * Evaluate or explain the given query
     * @param {string | Algebra.Operation} query A query string or algebra.
     * @param context An optional query context.
     * @return {Promise<QueryType | IQueryExplained>} A promise that resolves to
     *                                                               the query output or explanation.
     */
    async queryOrExplain(query, context) {
        context = context || {};
        // Expand shortcuts
        for (const key in context) {
            if (this.actorInitQuery.contextKeyShortcuts[key]) {
                context[this.actorInitQuery.contextKeyShortcuts[key]] = context[key];
                delete context[key];
            }
        }
        // Prepare context
        let actionContext = new core_1.ActionContext(context);
        let queryFormat = { language: 'sparql', version: '1.1' };
        if (actionContext.has(context_entries_1.KeysInitQuery.queryFormat)) {
            queryFormat = actionContext.get(context_entries_1.KeysInitQuery.queryFormat);
            actionContext = actionContext.delete(context_entries_1.KeysInitQuery.queryFormat);
            if (queryFormat.language === 'graphql') {
                actionContext = actionContext.setDefault(context_entries_1.KeysInitQuery.graphqlSingularizeVariables, {});
            }
        }
        const baseIRI = actionContext.get(context_entries_1.KeysInitQuery.baseIRI);
        actionContext = actionContext
            .setDefault(context_entries_1.KeysInitQuery.queryTimestamp, new Date())
            .setDefault(context_entries_1.KeysRdfResolveQuadPattern.sourceIds, new Map())
            // Set the default logger if none is provided
            .setDefault(context_entries_1.KeysCore.log, this.actorInitQuery.logger);
        // Pre-processing the context
        actionContext = (await this.actorInitQuery.mediatorContextPreprocess.mediate({ context: actionContext })).context;
        // Determine explain mode
        const explainMode = actionContext.get(context_entries_1.KeysInitQuery.explain);
        // Parse query
        let operation;
        if (typeof query === 'string') {
            // Save the original query string in the context
            actionContext = actionContext.set(context_entries_1.KeysInitQuery.queryString, query);
            const queryParseOutput = await this.actorInitQuery.mediatorQueryParse
                .mediate({ context: actionContext, query, queryFormat, baseIRI });
            operation = queryParseOutput.operation;
            // Update the baseIRI in the context if the query modified it.
            if (queryParseOutput.baseIRI) {
                actionContext = actionContext.set(context_entries_1.KeysInitQuery.baseIRI, queryParseOutput.baseIRI);
            }
        }
        else {
            operation = query;
        }
        // Print parsed query
        if (explainMode === 'parsed') {
            return {
                explain: true,
                type: explainMode,
                data: operation,
            };
        }
        // Apply initial bindings in context
        if (actionContext.has(context_entries_1.KeysInitQuery.initialBindings)) {
            operation = (0, bus_query_operation_1.materializeOperation)(operation, actionContext.get(context_entries_1.KeysInitQuery.initialBindings));
            // Delete the query string from the context, since our initial query might have changed
            actionContext = actionContext.delete(context_entries_1.KeysInitQuery.queryString);
        }
        // Optimize the query operation
        const mediatorResult = await this.actorInitQuery.mediatorOptimizeQueryOperation
            .mediate({ context: actionContext, operation });
        operation = mediatorResult.operation;
        actionContext = mediatorResult.context || actionContext;
        // Print logical query plan
        if (explainMode === 'logical') {
            return {
                explain: true,
                type: explainMode,
                data: operation,
            };
        }
        // Save original query in context
        actionContext = actionContext.set(context_entries_1.KeysInitQuery.query, operation);
        // If we need a physical query plan, store a physical query plan logger in the context, and collect it after exec
        let physicalQueryPlanLogger;
        if (explainMode === 'physical') {
            physicalQueryPlanLogger = new MemoryPhysicalQueryPlanLogger_1.MemoryPhysicalQueryPlanLogger();
            actionContext = actionContext.set(context_entries_1.KeysInitQuery.physicalQueryPlanLogger, physicalQueryPlanLogger);
        }
        // Execute query
        const output = await this.actorInitQuery.mediatorQueryOperation.mediate({
            context: actionContext,
            operation,
        });
        output.context = actionContext;
        const finalOutput = QueryEngineBase.internalToFinalResult(output);
        // Output physical query plan after query exec if needed
        if (physicalQueryPlanLogger) {
            // Make sure the whole result is produced
            switch (finalOutput.resultType) {
                case 'bindings':
                    await (await finalOutput.execute()).toArray();
                    break;
                case 'quads':
                    await (await finalOutput.execute()).toArray();
                    break;
                case 'boolean':
                    await finalOutput.execute();
                    break;
                case 'void':
                    await finalOutput.execute();
                    break;
            }
            return {
                explain: true,
                type: explainMode,
                data: physicalQueryPlanLogger.toJson(),
            };
        }
        return finalOutput;
    }
    /**
     * @param context An optional context.
     * @return {Promise<{[p: string]: number}>} All available SPARQL (weighted) result media types.
     */
    async getResultMediaTypes(context) {
        context = core_1.ActionContext.ensureActionContext(context);
        return (await this.actorInitQuery.mediatorQueryResultSerializeMediaTypeCombiner
            .mediate({ context, mediaTypes: true })).mediaTypes;
    }
    /**
     * @param context An optional context.
     * @return {Promise<{[p: string]: number}>} All available SPARQL result media type formats.
     */
    async getResultMediaTypeFormats(context) {
        context = core_1.ActionContext.ensureActionContext(context);
        return (await this.actorInitQuery.mediatorQueryResultSerializeMediaTypeFormatCombiner
            .mediate({ context, mediaTypeFormats: true })).mediaTypeFormats;
    }
    /**
     * Convert a query result to a string stream based on a certain media type.
     * @param {IQueryOperationResult} queryResult A query result.
     * @param {string} mediaType A media type.
     * @param {ActionContext} context An optional context.
     * @return {Promise<IActorQueryResultSerializeOutput>} A text stream.
     */
    async resultToString(queryResult, mediaType, context) {
        context = core_1.ActionContext.ensureActionContext(context);
        if (!mediaType) {
            switch (queryResult.resultType) {
                case 'bindings':
                    mediaType = 'application/json';
                    break;
                case 'quads':
                    mediaType = 'application/trig';
                    break;
                default:
                    mediaType = 'simple';
                    break;
            }
        }
        const handle = { ...await QueryEngineBase.finalToInternalResult(queryResult), context };
        return (await this.actorInitQuery.mediatorQueryResultSerialize
            .mediate({ context, handle, handleMediaType: mediaType })).handle;
    }
    /**
     * Invalidate all internal caches related to the given page URL.
     * If no page URL is given, then all pages will be invalidated.
     * @param {string} url The page URL to invalidate.
     * @param context An optional ActionContext to pass to the actors.
     * @return {Promise<any>} A promise resolving when the caches have been invalidated.
     */
    invalidateHttpCache(url, context) {
        context = core_1.ActionContext.ensureActionContext(context);
        return this.actorInitQuery.mediatorHttpInvalidate.mediate({ url, context });
    }
    /**
     * Convert an internal query result to a final one.
     * @param internalResult An intermediary query result.
     */
    static internalToFinalResult(internalResult) {
        switch (internalResult.type) {
            case 'bindings':
                return {
                    resultType: 'bindings',
                    execute: async () => internalResult.bindingsStream,
                    metadata: async () => await internalResult.metadata(),
                    context: internalResult.context,
                };
            case 'quads':
                return {
                    resultType: 'quads',
                    execute: async () => internalResult.quadStream,
                    metadata: async () => await internalResult.metadata(),
                    context: internalResult.context,
                };
            case 'boolean':
                return {
                    resultType: 'boolean',
                    execute: async () => internalResult.execute(),
                    context: internalResult.context,
                };
            case 'void':
                return {
                    resultType: 'void',
                    execute: async () => internalResult.execute(),
                    context: internalResult.context,
                };
        }
    }
    /**
     * Convert a final query result to an internal one.
     * @param finalResult A final query result.
     */
    static async finalToInternalResult(finalResult) {
        switch (finalResult.resultType) {
            case 'bindings':
                return {
                    type: 'bindings',
                    bindingsStream: await finalResult.execute(),
                    metadata: async () => await finalResult.metadata(),
                };
            case 'quads':
                return {
                    type: 'quads',
                    quadStream: await finalResult.execute(),
                    metadata: async () => await finalResult.metadata(),
                };
            case 'boolean':
                return {
                    type: 'boolean',
                    execute: () => finalResult.execute(),
                };
            case 'void':
                return {
                    type: 'void',
                    execute: () => finalResult.execute(),
                };
        }
    }
}
exports.QueryEngineBase = QueryEngineBase;
//# sourceMappingURL=QueryEngineBase.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-init-query/lib/index-browser.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QueryEngineBase = void 0;
/* eslint-disable unicorn/filename-case */
/* eslint-enable unicorn/filename-case */
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-init-query/lib/ActorInitQueryBase.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-init-query/lib/ActorInitQuery-browser.js"), exports);
var QueryEngineBase_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-init-query/lib/QueryEngineBase.js");
Object.defineProperty(exports, "QueryEngineBase", ({ enumerable: true, get: function () { return QueryEngineBase_1.QueryEngineBase; } }));
//# sourceMappingURL=index-browser.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-optimize-query-operation-bgp-to-join/lib/ActorOptimizeQueryOperationBgpToJoin.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorOptimizeQueryOperationBgpToJoin = void 0;
const bus_optimize_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-optimize-query-operation/lib/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
/**
 * A comunica BGP to Join Optimize Query Operation Actor.
 */
class ActorOptimizeQueryOperationBgpToJoin extends bus_optimize_query_operation_1.ActorOptimizeQueryOperation {
    async test(action) {
        return true;
    }
    async run(action) {
        const operation = sparqlalgebrajs_1.Util.mapOperation(action.operation, {
            bgp(op, factory) {
                return {
                    recurse: false,
                    result: factory.createJoin(op.patterns),
                };
            },
        });
        return { operation, context: action.context };
    }
}
exports.ActorOptimizeQueryOperationBgpToJoin = ActorOptimizeQueryOperationBgpToJoin;
//# sourceMappingURL=ActorOptimizeQueryOperationBgpToJoin.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-optimize-query-operation-bgp-to-join/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-optimize-query-operation-bgp-to-join/lib/ActorOptimizeQueryOperationBgpToJoin.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-optimize-query-operation-join-bgp/lib/ActorOptimizeQueryOperationJoinBgp.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorOptimizeQueryOperationJoinBgp = void 0;
const bus_optimize_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-optimize-query-operation/lib/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
/**
 * A comunica Join BGP Optimize Query Operation Actor.
 */
class ActorOptimizeQueryOperationJoinBgp extends bus_optimize_query_operation_1.ActorOptimizeQueryOperation {
    async test(action) {
        return true;
    }
    async run(action) {
        const operation = sparqlalgebrajs_1.Util.mapOperation(action.operation, {
            join(op, factory) {
                if (op.input.every(subInput => subInput.type === 'bgp')) {
                    return {
                        recurse: false,
                        result: factory.createBgp(op.input.flatMap(subInput => subInput.patterns)),
                    };
                }
                return {
                    recurse: false,
                    result: op,
                };
            },
        });
        return { operation, context: action.context };
    }
}
exports.ActorOptimizeQueryOperationJoinBgp = ActorOptimizeQueryOperationJoinBgp;
//# sourceMappingURL=ActorOptimizeQueryOperationJoinBgp.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-optimize-query-operation-join-bgp/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-optimize-query-operation-join-bgp/lib/ActorOptimizeQueryOperationJoinBgp.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-optimize-query-operation-join-connected/lib/ActorOptimizeQueryOperationJoinConnected.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorOptimizeQueryOperationJoinConnected = void 0;
const bus_optimize_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-optimize-query-operation/lib/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
/**
 * A comunica Join Connected Optimize Query Operation Actor.
 */
class ActorOptimizeQueryOperationJoinConnected extends bus_optimize_query_operation_1.ActorOptimizeQueryOperation {
    async test(action) {
        return true;
    }
    async run(action) {
        const operation = sparqlalgebrajs_1.Util.mapOperation(action.operation, {
            join(op, factory) {
                return {
                    recurse: false,
                    result: ActorOptimizeQueryOperationJoinConnected.cluster(op, factory),
                };
            },
        });
        return { operation, context: action.context };
    }
    /**
     * Iteratively cluster join entries based on their overlapping variables.
     * @param op A join operation.
     * @param factory An algebra factory.
     */
    static cluster(op, factory) {
        // Initialize each entry to be in a separate cluster
        const initialClusters = op.input.map(subOp => ({
            inScopeVariables: Object.fromEntries(sparqlalgebrajs_1.Util.inScopeVariables(subOp).map(variable => [variable.value, true])),
            entries: [subOp],
        }));
        // Iteratively merge clusters until they don't change anymore
        let oldClusters;
        let newClusters = initialClusters;
        do {
            oldClusters = newClusters;
            newClusters = ActorOptimizeQueryOperationJoinConnected.clusterIteration(oldClusters);
        } while (oldClusters.length !== newClusters.length);
        // Create new join operation of latest clusters
        const subJoins = newClusters.map(cluster => factory.createJoin(cluster.entries));
        return subJoins.length === 1 ? subJoins[0] : factory.createJoin(subJoins, false);
    }
    /**
     * Perform a single clustering iteration.
     * Clusters will be joined if they have overlapping variables.
     * @param oldCluster
     */
    static clusterIteration(oldCluster) {
        const newClusters = [];
        for (const entry of oldCluster) {
            // Try to add entry to a join cluster
            let joined = false;
            for (const newEntry of newClusters) {
                if (ActorOptimizeQueryOperationJoinConnected
                    .haveOverlappingVariables(entry.inScopeVariables, newEntry.inScopeVariables)) {
                    newEntry.entries = [...newEntry.entries, ...entry.entries];
                    newEntry.inScopeVariables = { ...newEntry.inScopeVariables, ...entry.inScopeVariables };
                    joined = true;
                    break;
                }
            }
            // If none was found, create new cluster
            if (!joined) {
                newClusters.push({
                    inScopeVariables: entry.inScopeVariables,
                    entries: entry.entries,
                });
            }
        }
        return newClusters;
    }
    /**
     * Check if the two given variable objects are overlapping.
     * @param variablesA A variables objects.
     * @param variablesB A variables objects.
     */
    static haveOverlappingVariables(variablesA, variablesB) {
        for (const variableA of Object.keys(variablesA)) {
            if (variablesB[variableA]) {
                return true;
            }
        }
        return false;
    }
}
exports.ActorOptimizeQueryOperationJoinConnected = ActorOptimizeQueryOperationJoinConnected;
//# sourceMappingURL=ActorOptimizeQueryOperationJoinConnected.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-optimize-query-operation-join-connected/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-optimize-query-operation-join-connected/lib/ActorOptimizeQueryOperationJoinConnected.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-ask/lib/ActorQueryOperationAsk.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationAsk = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
/**
 * A comunica Ask Query Operation Actor.
 */
class ActorQueryOperationAsk extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'ask');
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(operation, context) {
        // Call other query operations like this:
        const output = await this.mediatorQueryOperation.mediate({ operation: operation.input, context });
        const bindings = bus_query_operation_1.ActorQueryOperation.getSafeBindings(output);
        const execute = () => new Promise((resolve, reject) => {
            // Resolve to true if we find one element, and close immediately
            bindings.bindingsStream.once('data', () => {
                resolve(true);
                bindings.bindingsStream.close();
            });
            // If we reach the end of the stream without finding anything, resolve to false
            bindings.bindingsStream.on('end', () => resolve(false));
            // Reject if an error occurs in the stream
            bindings.bindingsStream.on('error', reject);
        });
        return { type: 'boolean', execute };
    }
}
exports.ActorQueryOperationAsk = ActorQueryOperationAsk;
//# sourceMappingURL=ActorQueryOperationAsk.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-ask/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-ask/lib/ActorQueryOperationAsk.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-bgp-join/lib/ActorQueryOperationBgpJoin.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationBgpJoin = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
/**
 * A [Query Operation](https://github.com/comunica/comunica/tree/master/packages/bus-query-operation) actor
 * that handles SPARQL BGP operations by rewriting it as a join operator.
 */
class ActorQueryOperationBgpJoin extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'bgp');
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(operation, context) {
        return this.mediatorQueryOperation.mediate({
            operation: ActorQueryOperationBgpJoin.FACTORY.createJoin(operation.patterns),
            context,
        });
    }
}
exports.ActorQueryOperationBgpJoin = ActorQueryOperationBgpJoin;
ActorQueryOperationBgpJoin.FACTORY = new sparqlalgebrajs_1.Factory();
//# sourceMappingURL=ActorQueryOperationBgpJoin.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-bgp-join/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-bgp-join/lib/ActorQueryOperationBgpJoin.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-construct/lib/ActorQueryOperationConstruct.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationConstruct = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const rdf_terms_1 = __quadstore_comunica_require__("../node_modules/rdf-terms/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
const BindingsToQuadsIterator_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-construct/lib/BindingsToQuadsIterator.js");
/**
 * A comunica Construct Query Operation Actor.
 */
class ActorQueryOperationConstruct extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'construct');
    }
    /**
     * Find all variables in a list of triple patterns.
     * @param {Algebra.Pattern[]} patterns An array of triple patterns.
     * @return {RDF.Variable[]} The variables in the triple patterns.
     */
    static getVariables(patterns) {
        return (0, rdf_terms_1.uniqTerms)([].concat
            .apply([], patterns.map(pattern => (0, rdf_terms_1.getVariables)((0, rdf_terms_1.getTerms)(pattern)))));
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(operationOriginal, context) {
        // Apply a projection on our CONSTRUCT variables first, as the query may contain other variables as well.
        const variables = ActorQueryOperationConstruct.getVariables(operationOriginal.template);
        const operation = { type: sparqlalgebrajs_1.Algebra.types.PROJECT, input: operationOriginal.input, variables };
        // Evaluate the input query
        const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation, context }));
        // Construct triples using the result based on the pattern.
        const quadStream = new BindingsToQuadsIterator_1.BindingsToQuadsIterator(operationOriginal.template, output.bindingsStream);
        // Let the final metadata contain the estimated number of triples
        const metadata = () => output.metadata().then(meta => ({
            ...meta,
            order: undefined,
            cardinality: {
                type: meta.cardinality.type,
                value: meta.cardinality.value * operationOriginal.template.length,
            },
            canContainUndefs: false,
            availableOrders: undefined,
        }));
        return {
            metadata,
            quadStream,
            type: 'quads',
        };
    }
}
exports.ActorQueryOperationConstruct = ActorQueryOperationConstruct;
//# sourceMappingURL=ActorQueryOperationConstruct.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-construct/lib/BindingsToQuadsIterator.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BindingsToQuadsIterator = void 0;
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const rdf_terms_1 = __quadstore_comunica_require__("../node_modules/rdf-terms/index.js");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * Transforms a bindings stream into a quad stream given a quad template.
 *
 * This conforms to the SPARQL 1.1 spec on constructing triples:
 * https://www.w3.org/TR/sparql11-query/#rConstructTriples
 */
class BindingsToQuadsIterator extends asynciterator_1.MultiTransformIterator {
    constructor(template, bindingsStream, localizeBlankNodes = true) {
        super(bindingsStream, { autoStart: false });
        this.template = template;
        this.localizeBlankNodes = localizeBlankNodes;
        this.blankNodeCounter = 0;
    }
    /**
     * Bind the given term.
     * If the term is a variable and the variable is bound in the bindings object,
     * return the bindings value.
     * If the term is a variable and the variable is not bound in the bindings object,
     * a falsy value is returned..
     * Otherwise, the term itself is returned.
     * @param {Bindings}  bindings A bindings object.
     * @param {RDF.Term}  term     An RDF term.
     * @return {RDF.Term}          If the given term is not a variable, the term itself is returned.
     *                             If the given term is a variable, then the bound term is returned,
     *                             or a falsy value if it did not exist in the bindings.
     */
    static bindTerm(bindings, term) {
        if (term.termType === 'Variable') {
            return bindings.get(term);
        }
        return term;
    }
    /**
     * Bind the given quad pattern.
     * If one of the terms was a variable AND is not bound in the bindings,
     * a falsy value will be returned.
     * @param {Bindings} bindings A bindings object.
     * @param {RDF.Quad} pattern  An RDF quad.
     * @return {RDF.Quad}         A bound RDF quad or undefined.
     */
    static bindQuad(bindings, pattern) {
        try {
            return (0, rdf_terms_1.mapTerms)(pattern, term => {
                const boundTerm = BindingsToQuadsIterator.bindTerm(bindings, term);
                if (!boundTerm) {
                    throw new Error('Unbound term');
                }
                return boundTerm;
            });
        }
        catch {
            // Do nothing
        }
    }
    /**
     * Convert a blank node to a unique blank node in the given context.
     * If the given term is not a blank node, the term itself will be returned.
     * @param             blankNodeCounter A counter value for the blank node.
     * @param {RDF.Term}  term             The term that should be localized.
     * @return {RDF.Term}                  A term.
     */
    static localizeBlankNode(blankNodeCounter, term) {
        if (term.termType === 'BlankNode') {
            return DF.blankNode(`${term.value}${blankNodeCounter}`);
        }
        return term;
    }
    /**
     * Convert the given quad to a quad that only contains unique blank nodes.
     * @param            blankNodeCounter A counter value for the blank node.
     * @param {RDF.BaseQuad} pattern          The pattern that should be localized.
     * @return {RDF.BaseQuad}                 A quad.
     */
    static localizeQuad(blankNodeCounter, pattern) {
        return (0, rdf_terms_1.mapTerms)(pattern, term => BindingsToQuadsIterator.localizeBlankNode(blankNodeCounter, term));
    }
    /**
     * Convert the given template to a list of quads based on the given bindings.
     * @param {Bindings}    bindings           A bindings object.
     * @param {RDF.Quad[]}  template           A list of quad patterns.
     * @param               blankNodeCounter   A counter value for the blank node.
     * @return {RDF.Quad[]}                    A list of quads.
     */
    bindTemplate(bindings, template, blankNodeCounter) {
        let quads = template
            // Bind variables to bound terms
            .map(x => BindingsToQuadsIterator.bindQuad.bind(null, bindings)(x))
            // Remove quads that contained unbound terms, i.e., variables.
            .filter(Boolean);
        if (this.localizeBlankNodes) {
            // Make sure the multiple instantiations of the template contain different blank nodes, as required by SPARQL 1.1.
            quads = quads.map(BindingsToQuadsIterator.localizeQuad.bind(null, blankNodeCounter));
        }
        return quads;
    }
    _createTransformer(bindings) {
        return new asynciterator_1.ArrayIterator(this.bindTemplate(bindings, this.template, this.blankNodeCounter++));
    }
}
exports.BindingsToQuadsIterator = BindingsToQuadsIterator;
//# sourceMappingURL=BindingsToQuadsIterator.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-construct/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-construct/lib/ActorQueryOperationConstruct.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-construct/lib/BindingsToQuadsIterator.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-describe-subject/lib/ActorQueryOperationDescribeSubject.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationDescribeSubject = void 0;
const actor_query_operation_union_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-union/lib/index.js");
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A comunica Describe Subject Query Operation Actor.
 */
class ActorQueryOperationDescribeSubject extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'describe');
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(operationOriginal, context) {
        // Create separate construct queries for all non-variable terms
        const operations = operationOriginal.terms
            .filter(term => term.termType !== 'Variable')
            .map((term) => {
            // Transform each term to a separate construct operation with S ?p ?o patterns (BGP) for all terms
            const patterns = [
                DF.quad(term, DF.variable('__predicate'), DF.variable('__object')),
            ];
            // eslint-disable-next-line no-return-assign
            patterns.forEach((templatePattern) => templatePattern.type = 'pattern');
            const templateOperation = {
                type: sparqlalgebrajs_1.Algebra.types.BGP,
                patterns: patterns,
            };
            // Create a construct query
            return {
                input: templateOperation,
                template: patterns,
                type: 'construct',
            };
        });
        // If we have variables in the term list,
        // create one separate construct operation to determine these variables using the input pattern.
        if (operations.length !== operationOriginal.terms.length) {
            let variablePatterns = [];
            operationOriginal.terms
                .filter(term => term.termType === 'Variable')
                .forEach((term, i) => {
                // Transform each term to an S ?p ?o pattern in a non-conflicting way
                const patterns = [
                    DF.quad(term, DF.variable(`__predicate${i}`), DF.variable(`__object${i}`)),
                ];
                // eslint-disable-next-line no-return-assign
                patterns.forEach((templatePattern) => templatePattern.type = 'pattern');
                variablePatterns = [...variablePatterns, ...patterns];
            });
            // Add a single construct for the variables
            // This requires a join between the input pattern and our variable patterns that form a simple BGP
            operations.push({
                input: {
                    type: sparqlalgebrajs_1.Algebra.types.JOIN,
                    input: [
                        operationOriginal.input,
                        { type: sparqlalgebrajs_1.Algebra.types.BGP, patterns: variablePatterns },
                    ],
                },
                template: variablePatterns,
                type: sparqlalgebrajs_1.Algebra.types.CONSTRUCT,
            });
        }
        // Evaluate the construct queries
        const outputs = (await Promise.all(operations.map(operation => this.mediatorQueryOperation.mediate({ operation, context }))))
            .map(bus_query_operation_1.ActorQueryOperation.getSafeQuads);
        // Take the union of all quad streams
        const quadStream = new asynciterator_1.UnionIterator(outputs.map(output => output.quadStream), { autoStart: false });
        // Take union of metadata
        const metadata = () => Promise.all(outputs
            .map(x => x.metadata()))
            .then(metadatas => actor_query_operation_union_1.ActorQueryOperationUnion.unionMetadata(metadatas, false));
        return { type: 'quads', quadStream, metadata };
    }
}
exports.ActorQueryOperationDescribeSubject = ActorQueryOperationDescribeSubject;
//# sourceMappingURL=ActorQueryOperationDescribeSubject.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-describe-subject/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-describe-subject/lib/ActorQueryOperationDescribeSubject.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-distinct-hash/lib/ActorQueryOperationDistinctHash.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationDistinctHash = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
/**
 * A comunica Distinct Hash Query Operation Actor.
 */
class ActorQueryOperationDistinctHash extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'distinct');
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(operation, context) {
        const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: operation.input, context }));
        const bindingsStream = output.bindingsStream.filter(await this.newHashFilter(context));
        return {
            type: 'bindings',
            bindingsStream,
            metadata: output.metadata,
        };
    }
    /**
     * Create a new distinct filter function.
     * This will maintain an internal hash datastructure so that every bindings object only returns true once.
     * @param context The action context.
     * @return {(bindings: Bindings) => boolean} A distinct filter for bindings.
     */
    async newHashFilter(context) {
        const { hashFunction } = await this.mediatorHashBindings.mediate({ allowHashCollisions: true, context });
        const hashes = {};
        return (bindings) => {
            const hash = hashFunction(bindings);
            // eslint-disable-next-line no-return-assign
            return !(hash in hashes) && (hashes[hash] = true);
        };
    }
}
exports.ActorQueryOperationDistinctHash = ActorQueryOperationDistinctHash;
//# sourceMappingURL=ActorQueryOperationDistinctHash.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-distinct-hash/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-distinct-hash/lib/ActorQueryOperationDistinctHash.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-extend/lib/ActorQueryOperationExtend.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationExtend = void 0;
const bindings_factory_1 = __quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/index.js");
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const sparqlee_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/index.js");
/**
 * A comunica Extend Query Operation Actor.
 *
 * See https://www.w3.org/TR/sparql11-query/#sparqlAlgebra;
 */
class ActorQueryOperationExtend extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'extend');
    }
    async testOperation(operation, context) {
        // Will throw error for unsupported opperations
        const _ = Boolean(new sparqlee_1.AsyncEvaluator(operation.expression, bus_query_operation_1.ActorQueryOperation.getAsyncExpressionContext(context, this.mediatorQueryOperation)));
        return true;
    }
    async runOperation(operation, context) {
        const { expression, input, variable } = operation;
        const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: input, context }));
        const config = { ...bus_query_operation_1.ActorQueryOperation.getAsyncExpressionContext(context, this.mediatorQueryOperation) };
        const evaluator = new sparqlee_1.AsyncEvaluator(expression, config);
        // Transform the stream by extending each Bindings with the expression result
        const transform = async (bindings, next, push) => {
            try {
                const result = await evaluator.evaluate(bindings);
                // Extend operation is undefined when the key already exists
                // We just override it here.
                const extended = bindings.set(variable, result);
                push(extended);
            }
            catch (error) {
                if ((0, sparqlee_1.isExpressionError)(error)) {
                    // Errors silently don't actually extend according to the spec
                    push(bindings);
                    // But let's warn anyway
                    this.logWarn(context, `Expression error for extend operation with bindings '${(0, bindings_factory_1.bindingsToString)(bindings)}'`);
                }
                else {
                    bindingsStream.emit('error', error);
                }
            }
            next();
        };
        const bindingsStream = output.bindingsStream.transform({ autoStart: false, transform });
        return {
            type: 'bindings',
            bindingsStream,
            async metadata() {
                const outputMetadata = await output.metadata();
                return { ...outputMetadata, variables: [...outputMetadata.variables, variable] };
            },
        };
    }
}
exports.ActorQueryOperationExtend = ActorQueryOperationExtend;
//# sourceMappingURL=ActorQueryOperationExtend.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-extend/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-extend/lib/ActorQueryOperationExtend.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-filter-sparqlee/lib/ActorQueryOperationFilterSparqlee.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationFilterSparqlee = void 0;
const bindings_factory_1 = __quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/index.js");
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const sparqlee_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/index.js");
/**
 * A comunica Filter Sparqlee Query Operation Actor.
 */
class ActorQueryOperationFilterSparqlee extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'filter');
    }
    async testOperation(operation, context) {
        // Will throw error for unsupported operators
        const config = { ...bus_query_operation_1.ActorQueryOperation.getAsyncExpressionContext(context, this.mediatorQueryOperation) };
        const _ = new sparqlee_1.AsyncEvaluator(operation.expression, config);
        return true;
    }
    async runOperation(operation, context) {
        const outputRaw = await this.mediatorQueryOperation.mediate({ operation: operation.input, context });
        const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(outputRaw);
        bus_query_operation_1.ActorQueryOperation.validateQueryOutput(output, 'bindings');
        const config = { ...bus_query_operation_1.ActorQueryOperation.getAsyncExpressionContext(context, this.mediatorQueryOperation) };
        const evaluator = new sparqlee_1.AsyncEvaluator(operation.expression, config);
        const transform = async (item, next, push) => {
            try {
                const result = await evaluator.evaluateAsEBV(item);
                if (result) {
                    push(item);
                }
            }
            catch (error) {
                // We ignore all Expression errors.
                // Other errors (likely programming mistakes) are still propagated.
                //
                // > Specifically, FILTERs eliminate any solutions that,
                // > when substituted into the expression, either result in
                // > an effective boolean value of false or produce an error.
                // > ...
                // > These errors have no effect outside of FILTER evaluation.
                // https://www.w3.org/TR/sparql11-query/#expressions
                if ((0, sparqlee_1.isExpressionError)(error)) {
                    // In many cases, this is a user error, where the user should manually cast the variable to a string.
                    // In order to help users debug this, we should report these errors via the logger as warnings.
                    this.logWarn(context, 'Error occurred while filtering.', () => ({ error, bindings: (0, bindings_factory_1.bindingsToString)(item) }));
                }
                else {
                    bindingsStream.emit('error', error);
                }
            }
            next();
        };
        const bindingsStream = output.bindingsStream.transform({ transform });
        return { type: 'bindings', bindingsStream, metadata: output.metadata };
    }
}
exports.ActorQueryOperationFilterSparqlee = ActorQueryOperationFilterSparqlee;
//# sourceMappingURL=ActorQueryOperationFilterSparqlee.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-filter-sparqlee/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-filter-sparqlee/lib/ActorQueryOperationFilterSparqlee.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-from-quad/lib/ActorQueryOperationFromQuad.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationFromQuad = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
/**
 * A comunica From Query Operation Actor.
 */
class ActorQueryOperationFromQuad extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'from');
    }
    /**
     * Create a deep copy of the given operation.
     * @param {Operation} operation An operation.
     * @param {(subOperation: Operation) => Operation} recursiveCb A callback for recursive operation calls.
     * @return {Operation} The copied operation.
     */
    static copyOperation(operation, recursiveCb) {
        const copiedOperation = {};
        for (const key of Object.keys(operation)) {
            if (Array.isArray(operation[key]) && key !== 'template') {
                // We exclude the 'template' entry, as we don't want to modify the template value of construct operations
                if (key === 'variables') {
                    copiedOperation[key] = operation[key];
                }
                else {
                    copiedOperation[key] = operation[key].map(recursiveCb);
                }
            }
            else if (ActorQueryOperationFromQuad.ALGEBRA_TYPES.includes(operation[key].type)) {
                copiedOperation[key] = recursiveCb(operation[key]);
            }
            else {
                copiedOperation[key] = operation[key];
            }
        }
        return copiedOperation;
    }
    /**
     * Recursively transform the given operation to use the given graphs as default graph
     * This will (possibly) create a new operation and not modify the given operation.
     * @param {Operation} operation An operation.
     * @param {RDF.Term[]} defaultGraphs Graph terms.
     * @return {Operation} A new operation.
     */
    static applyOperationDefaultGraph(operation, defaultGraphs) {
        // If the operation is a BGP or Path, change the graph.
        if ((operation.type === 'bgp' && operation.patterns.length > 0) ||
            operation.type === 'path' ||
            operation.type === 'pattern') {
            if (operation.type === 'bgp') {
                return ActorQueryOperationFromQuad.joinOperations(operation.patterns.map((pattern) => {
                    if (pattern.graph.termType !== 'DefaultGraph') {
                        return ActorQueryOperationFromQuad.FACTORY.createBgp([pattern]);
                    }
                    const bgps = defaultGraphs.map((graph) => ActorQueryOperationFromQuad.FACTORY.createBgp([ActorQueryOperationFromQuad.FACTORY
                            .createPattern(pattern.subject, pattern.predicate, pattern.object, graph)]));
                    return ActorQueryOperationFromQuad.unionOperations(bgps);
                }));
            }
            if (operation.graph.termType !== 'DefaultGraph') {
                return operation;
            }
            const paths = defaultGraphs.map((graph) => {
                if (operation.type === 'path') {
                    return ActorQueryOperationFromQuad.FACTORY
                        .createPath(operation.subject, operation.predicate, operation.object, graph);
                }
                return ActorQueryOperationFromQuad.FACTORY
                    .createPattern(operation.subject, operation.predicate, operation.object, graph);
            });
            return ActorQueryOperationFromQuad.unionOperations(paths);
        }
        return ActorQueryOperationFromQuad.copyOperation(operation, (subOperation) => this.applyOperationDefaultGraph(subOperation, defaultGraphs));
    }
    /**
     * Recursively transform the given operation to use the given graphs as named graph
     * This will (possibly) create a new operation and not modify the given operation.
     * @param {Operation} operation An operation.
     * @param {RDF.Term[]} namedGraphs Graph terms.
     * @param {RDF.Term[]} defaultGraphs Default graph terms.
     * @return {Operation} A new operation.
     */
    static applyOperationNamedGraph(operation, namedGraphs, defaultGraphs) {
        // If the operation is a BGP or Path, change the graph.
        if ((operation.type === 'bgp' && operation.patterns.length > 0) ||
            operation.type === 'path' ||
            operation.type === 'pattern') {
            const patternGraph = operation.type === 'bgp' ? operation.patterns[0].graph : operation.graph;
            if (patternGraph.termType === 'DefaultGraph') {
                // SPARQL spec (8.2) describes that when FROM NAMED's are used without a FROM, the default graph must be empty.
                // The FROMs are transformed before this step to a named node, so this will not apply to this case anymore.
                return { type: sparqlalgebrajs_1.Algebra.types.BGP, patterns: [] };
            }
            if (patternGraph.termType === 'Variable') {
                if (namedGraphs.length === 1) {
                    const graph = namedGraphs[0];
                    // If the pattern graph is a variable, replace the graph and bind the variable using VALUES
                    const bindings = {};
                    bindings[`?${patternGraph.value}`] = graph;
                    const values = ActorQueryOperationFromQuad.FACTORY
                        .createValues([patternGraph], [bindings]);
                    let pattern;
                    if (operation.type === 'bgp') {
                        pattern = ActorQueryOperationFromQuad.FACTORY
                            .createBgp(operation.patterns.map((pat) => ActorQueryOperationFromQuad.FACTORY
                            .createPattern(pat.subject, pat.predicate, pat.object, graph)));
                    }
                    else if (operation.type === 'path') {
                        pattern = ActorQueryOperationFromQuad.FACTORY
                            .createPath(operation.subject, operation.predicate, operation.object, graph);
                    }
                    else {
                        pattern = ActorQueryOperationFromQuad.FACTORY
                            .createPattern(operation.subject, operation.predicate, operation.object, graph);
                    }
                    return ActorQueryOperationFromQuad.FACTORY.createJoin([values, pattern]);
                }
                // If the pattern graph is a variable, take the union of the pattern applied to each available named graph
                return ActorQueryOperationFromQuad.unionOperations(namedGraphs.map((graph) => ActorQueryOperationFromQuad.applyOperationNamedGraph(operation, [graph], defaultGraphs)));
            }
            // The pattern's graph is defined (including the default graphs)
            const isNamedGraphAvailable = [...namedGraphs, ...defaultGraphs].some((namedGraph) => namedGraph.equals(patternGraph));
            if (isNamedGraphAvailable) {
                // Return the pattern as-is if the pattern's graph was selected in a FROM NAMED
                return operation;
            }
            // No-op if the pattern's graph was not selected in a FROM NAMED.
            return { type: sparqlalgebrajs_1.Algebra.types.BGP, patterns: [] };
        }
        return ActorQueryOperationFromQuad.copyOperation(operation, (subOperation) => this.applyOperationNamedGraph(subOperation, namedGraphs, defaultGraphs));
    }
    /**
     * Transform the given array of operations into a join operation.
     * @param {Operation[]} operations An array of operations, must contain at least one operation.
     * @return {Join} A join operation.
     */
    static joinOperations(operations) {
        if (operations.length === 1) {
            return operations[0];
        }
        if (operations.length > 1) {
            return ActorQueryOperationFromQuad.FACTORY.createJoin(operations);
        }
        throw new Error('A join can only be applied on at least one operation');
    }
    /**
     * Transform the given array of operations into a union operation.
     * @param {Operation[]} operations An array of operations, must contain at least one operation.
     * @return {Union} A union operation.
     */
    static unionOperations(operations) {
        if (operations.length === 1) {
            return operations[0];
        }
        if (operations.length > 1) {
            return ActorQueryOperationFromQuad.FACTORY.createUnion(operations);
        }
        throw new Error('A union can only be applied on at least one operation');
    }
    /**
     * Transform an operation based on the default and named graphs in the pattern.
     *
     * FROM sets the default graph.
     * If multiple are available, take the union of the operation for all of them at quad-pattern level.
     *
     * FROM NAMED indicates which named graphs are available.
     * This will rewrite the query so that only triples from the given named graphs can be selected.
     *
     * @param {From} pattern A from operation.
     * @return {Operation} The transformed operation.
     */
    static createOperation(pattern) {
        let operation = pattern.input;
        if (pattern.default.length > 0) {
            operation = ActorQueryOperationFromQuad.applyOperationDefaultGraph(operation, pattern.default);
        }
        if (pattern.named.length > 0 || pattern.default.length > 0) {
            operation = ActorQueryOperationFromQuad.applyOperationNamedGraph(operation, pattern.named, pattern.default);
        }
        return operation;
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(operationOriginal, context) {
        const operation = ActorQueryOperationFromQuad.createOperation(operationOriginal);
        return this.mediatorQueryOperation.mediate({ operation, context });
    }
}
exports.ActorQueryOperationFromQuad = ActorQueryOperationFromQuad;
ActorQueryOperationFromQuad.FACTORY = new sparqlalgebrajs_1.Factory();
ActorQueryOperationFromQuad.ALGEBRA_TYPES = Object.keys(sparqlalgebrajs_1.Algebra.types).map(key => sparqlalgebrajs_1.Algebra.types[key]);
//# sourceMappingURL=ActorQueryOperationFromQuad.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-from-quad/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-from-quad/lib/ActorQueryOperationFromQuad.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-group/lib/ActorQueryOperationGroup.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationGroup = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
const sparqlee_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/index.js");
const GroupsState_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-group/lib/GroupsState.js");
/**
 * A comunica Group Query Operation Actor.
 */
class ActorQueryOperationGroup extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'group');
    }
    async testOperation(operation, context) {
        for (const aggregate of operation.aggregates) {
            // Will throw for unsupported expressions
            const _ = new sparqlee_1.AsyncEvaluator(aggregate.expression, bus_query_operation_1.ActorQueryOperation.getAsyncExpressionContext(context));
        }
        return true;
    }
    async runOperation(operation, context) {
        // Create a hash function
        const { hashFunction } = await this.mediatorHashBindings.mediate({ allowHashCollisions: true, context });
        // Get result stream for the input query
        const { input, aggregates } = operation;
        const outputRaw = await this.mediatorQueryOperation.mediate({ operation: input, context });
        const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(outputRaw);
        // The variables in scope are the variables on which we group, i.e. pattern.variables.
        // For 'GROUP BY ?x, ?z', this is [?x, ?z], for 'GROUP by expr(?x) as ?e' this is [?e].
        // But also in scope are the variables defined by the aggregations, since GROUP has to handle this.
        const variables = [
            ...operation.variables,
            ...aggregates.map(agg => agg.variable),
        ];
        const sparqleeConfig = bus_query_operation_1.ActorQueryOperation.getAsyncExpressionContext(context);
        // Return a new promise that completes when the stream has ended or when
        // an error occurs
        return new Promise((resolve, reject) => {
            const groups = new GroupsState_1.GroupsState(hashFunction, operation, sparqleeConfig);
            // Phase 2: Collect aggregator results
            // We can only return when the binding stream ends, when that happens
            // we return the identified groups. Which are nothing more than Bindings
            // of the grouping variables merged with the aggregate variables
            output.bindingsStream.on('end', async () => {
                try {
                    const bindingsStream = new asynciterator_1.ArrayIterator(await groups.collectResults(), { autoStart: false });
                    resolve({
                        type: 'bindings',
                        bindingsStream,
                        metadata: async () => ({ ...await output.metadata(), variables }),
                    });
                }
                catch (error) {
                    reject(error);
                }
            });
            // Make sure to propagate any errors in the binding stream
            output.bindingsStream.on('error', reject);
            // Phase 1: Consume the stream, identify the groups and populate the aggregators.
            // We need to bind this after the 'error' and 'end' listeners to avoid the
            // stream having ended before those listeners are bound.
            output.bindingsStream.on('data', bindings => {
                groups.consumeBindings(bindings).catch(reject);
            });
        });
    }
}
exports.ActorQueryOperationGroup = ActorQueryOperationGroup;
//# sourceMappingURL=ActorQueryOperationGroup.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-group/lib/GroupsState.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupsState = void 0;
const bindings_factory_1 = __quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/index.js");
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const sparqlee_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/index.js");
const DF = new rdf_data_factory_1.DataFactory();
const BF = new bindings_factory_1.BindingsFactory();
/**
 * A state manager for the groups constructed by consuming the bindings-stream.
 */
class GroupsState {
    constructor(hashFunction, pattern, sparqleeConfig) {
        this.hashFunction = hashFunction;
        this.pattern = pattern;
        this.sparqleeConfig = sparqleeConfig;
        this.groups = new Map();
        this.groupsInitializer = new Map();
        this.groupVariables = new Set(this.pattern.variables.map(x => x.value));
        this.distinctHashes = pattern.aggregates.some(({ distinct }) => distinct) ?
            new Map() :
            null;
        this.waitCounter = 1;
        this.resultHasBeenCalled = false;
    }
    /**
     * - Consumes a stream binding
     * - Find the corresponding group and create one if need be
     * - Feeds the binding to the group's aggregators
     *
     * @param {Bindings} bindings - The Bindings to consume
     */
    consumeBindings(bindings) {
        const check = this.resultCheck();
        if (check) {
            return check;
        }
        // We increment the counter and decrement him when put action is performed.
        this.waitCounter++;
        // Select the bindings on which we group
        const grouper = bindings
            .filter((_, variable) => this.groupVariables.has(variable.value));
        const groupHash = this.hashBindings(grouper);
        // First member of group -> create new group
        let groupInitializer = this.groupsInitializer.get(groupHash);
        let res;
        if (!groupInitializer) {
            // Initialize state for all aggregators for new group
            groupInitializer = (async () => {
                const aggregators = {};
                await Promise.all(this.pattern.aggregates.map(async (aggregate) => {
                    const key = aggregate.variable.value;
                    aggregators[key] = new sparqlee_1.AsyncAggregateEvaluator(aggregate, this.sparqleeConfig);
                    await aggregators[key].put(bindings);
                }));
                if (this.distinctHashes) {
                    const bindingsHash = this.hashBindings(bindings);
                    this.distinctHashes.set(groupHash, new Set([bindingsHash]));
                }
                const group = { aggregators, bindings: grouper };
                this.groups.set(groupHash, group);
                this.subtractWaitCounterAndCollect();
                return group;
            })();
            this.groupsInitializer.set(groupHash, groupInitializer);
            res = groupInitializer;
        }
        else {
            const groupInitializerDefined = groupInitializer;
            res = (async () => {
                const group = await groupInitializerDefined;
                await Promise.all(this.pattern.aggregates.map(async (aggregate) => {
                    // If distinct, check first whether we have inserted these values already
                    if (aggregate.distinct) {
                        const hash = this.hashBindings(bindings);
                        if (this.distinctHashes.get(groupHash).has(hash)) {
                            return;
                        }
                        this.distinctHashes.get(groupHash).add(hash);
                    }
                    const variable = aggregate.variable.value;
                    await group.aggregators[variable].put(bindings);
                }));
            })().then(() => {
                this.subtractWaitCounterAndCollect();
            });
        }
        return res;
    }
    subtractWaitCounterAndCollect() {
        if (--this.waitCounter === 0) {
            this.handleResultCollection();
        }
    }
    handleResultCollection() {
        // Collect groups
        let rows = [...this.groups].map(([_, group]) => {
            const { bindings: groupBindings, aggregators } = group;
            // Collect aggregator bindings
            // If the aggregate errorred, the result will be undefined
            let returnBindings = groupBindings;
            for (const variable in aggregators) {
                const value = aggregators[variable].result();
                if (value) {
                    // Filter undefined
                    returnBindings = returnBindings.set(DF.variable(variable), value);
                }
            }
            // Merge grouping bindings and aggregator bindings
            return returnBindings;
        });
        // Case: No Input
        // Some aggregators still define an output on the empty input
        // Result is a single Bindings
        if (rows.length === 0 && this.groupVariables.size === 0) {
            const single = [];
            for (const aggregate of this.pattern.aggregates) {
                const key = aggregate.variable;
                const value = sparqlee_1.AsyncAggregateEvaluator.emptyValue(aggregate);
                if (value !== undefined) {
                    single.push([key, value]);
                }
            }
            rows = [BF.bindings(single)];
        }
        this.waitResolver(rows);
    }
    resultCheck() {
        if (this.resultHasBeenCalled) {
            return Promise.reject(new Error('Calling any function after calling collectResult is invalid.'));
        }
    }
    /**
     * Collect the result of the final state. This returns a Bindings per group,
     * and a (possibly empty) Bindings in case no Bindings have been consumed yet.
     * You can only call this method once, after calling this method,
     * calling any function on this will result in an error being thrown.
     */
    collectResults() {
        const check = this.resultCheck();
        if (check) {
            return check;
        }
        this.resultHasBeenCalled = true;
        const res = new Promise(resolve => {
            this.waitResolver = resolve;
        });
        this.subtractWaitCounterAndCollect();
        return res;
    }
    /**
     * @param {Bindings} bindings - Bindings to hash
     */
    hashBindings(bindings) {
        return this.hashFunction(bindings);
    }
}
exports.GroupsState = GroupsState;
//# sourceMappingURL=GroupsState.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-group/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-group/lib/ActorQueryOperationGroup.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-join/lib/ActorQueryOperationJoin.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationJoin = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
/**
 * A comunica Join Query Operation Actor.
 */
class ActorQueryOperationJoin extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'join');
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(operationOriginal, context) {
        const entries = (await Promise.all(operationOriginal.input
            .map(async (subOperation) => ({
            output: await this.mediatorQueryOperation.mediate({ operation: subOperation, context }),
            operation: subOperation,
        }))))
            .map(({ output, operation }) => ({
            output: bus_query_operation_1.ActorQueryOperation.getSafeBindings(output),
            operation,
        }));
        return this.mediatorJoin.mediate({ type: 'inner', entries, context });
    }
}
exports.ActorQueryOperationJoin = ActorQueryOperationJoin;
//# sourceMappingURL=ActorQueryOperationJoin.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-join/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-join/lib/ActorQueryOperationJoin.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-leftjoin/lib/ActorQueryOperationLeftJoin.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationLeftJoin = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const sparqlee_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/index.js");
/**
 * A comunica LeftJoin Query Operation Actor.
 */
class ActorQueryOperationLeftJoin extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'leftjoin');
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(operationOriginal, context) {
        // Delegate to join bus
        const entries = (await Promise.all(operationOriginal.input
            .map(async (subOperation) => ({
            output: await this.mediatorQueryOperation.mediate({ operation: subOperation, context }),
            operation: subOperation,
        }))))
            .map(({ output, operation }) => ({
            output: bus_query_operation_1.ActorQueryOperation.getSafeBindings(output),
            operation,
        }));
        const joined = await this.mediatorJoin.mediate({ type: 'optional', entries, context });
        // If the pattern contains an expression, filter the resulting stream
        if (operationOriginal.expression) {
            const config = { ...bus_query_operation_1.ActorQueryOperation.getAsyncExpressionContext(context) };
            const evaluator = new sparqlee_1.AsyncEvaluator(operationOriginal.expression, config);
            const bindingsStream = joined.bindingsStream
                .transform({
                autoStart: false,
                transform: async (bindings, done, push) => {
                    try {
                        const result = await evaluator.evaluateAsEBV(bindings);
                        if (result) {
                            push(bindings);
                        }
                    }
                    catch (error) {
                        // We ignore all Expression errors.
                        // Other errors (likely programming mistakes) are still propagated.
                        // Left Join is defined in terms of Filter (https://www.w3.org/TR/sparql11-query/#defn_algJoin),
                        // and Filter requires this (https://www.w3.org/TR/sparql11-query/#expressions).
                        if ((0, sparqlee_1.isExpressionError)(error)) {
                            // In many cases, this is a user error, where the user should manually cast the variable to a string.
                            // In order to help users debug this, we should report these errors via the logger as warnings.
                            this.logWarn(context, 'Error occurred while filtering.', () => ({ error, bindings }));
                        }
                        else {
                            bindingsStream.emit('error', error);
                        }
                    }
                    done();
                },
            });
            joined.bindingsStream = bindingsStream;
        }
        return joined;
    }
}
exports.ActorQueryOperationLeftJoin = ActorQueryOperationLeftJoin;
//# sourceMappingURL=ActorQueryOperationLeftJoin.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-leftjoin/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-leftjoin/lib/ActorQueryOperationLeftJoin.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-minus/lib/ActorQueryOperationMinus.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationMinus = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
/**
 * A comunica Minus Query Operation Actor.
 */
class ActorQueryOperationMinus extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'minus');
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(operationOriginal, context) {
        const entries = (await Promise.all(operationOriginal.input
            .map(async (subOperation) => ({
            output: await this.mediatorQueryOperation.mediate({ operation: subOperation, context }),
            operation: subOperation,
        }))))
            .map(({ output, operation }) => ({
            output: bus_query_operation_1.ActorQueryOperation.getSafeBindings(output),
            operation,
        }));
        return this.mediatorJoin.mediate({ type: 'minus', entries, context });
    }
}
exports.ActorQueryOperationMinus = ActorQueryOperationMinus;
//# sourceMappingURL=ActorQueryOperationMinus.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-minus/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-minus/lib/ActorQueryOperationMinus.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-nop/lib/ActorQueryOperationNop.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationNop = void 0;
const bindings_factory_1 = __quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/index.js");
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
const BF = new bindings_factory_1.BindingsFactory();
/**
 * A [Query Operation](https://github.com/comunica/comunica/tree/master/packages/bus-query-operation)
 * actor that handles SPARQL nop operations.
 */
class ActorQueryOperationNop extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'nop');
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(operation, context) {
        return {
            bindingsStream: new asynciterator_1.SingletonIterator(BF.bindings()),
            metadata: () => Promise.resolve({
                cardinality: { type: 'exact', value: 1 },
                canContainUndefs: false,
                variables: [],
            }),
            type: 'bindings',
        };
    }
}
exports.ActorQueryOperationNop = ActorQueryOperationNop;
//# sourceMappingURL=ActorQueryOperationNop.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-nop/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-nop/lib/ActorQueryOperationNop.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-orderby-sparqlee/lib/ActorQueryOperationOrderBySparqlee.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationOrderBySparqlee = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
const sparqlee_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/index.js");
const SortIterator_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-orderby-sparqlee/lib/SortIterator.js");
/**
 * A comunica OrderBy Sparqlee Query Operation Actor.
 */
class ActorQueryOperationOrderBySparqlee extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'orderby');
        this.window = args.window ?? Number.POSITIVE_INFINITY;
    }
    async testOperation(operation, context) {
        // Will throw error for unsupported operators
        for (let expr of operation.expressions) {
            expr = this.extractSortExpression(expr);
            const _ = new sparqlee_1.AsyncEvaluator(expr, bus_query_operation_1.ActorQueryOperation.getAsyncExpressionContext(context));
        }
        return true;
    }
    async runOperation(operation, context) {
        const outputRaw = await this.mediatorQueryOperation.mediate({ operation: operation.input, context });
        const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(outputRaw);
        const options = { window: this.window };
        const sparqleeConfig = { ...bus_query_operation_1.ActorQueryOperation.getAsyncExpressionContext(context) };
        let { bindingsStream } = output;
        // Sorting backwards since the first one is the most important therefore should be ordered last.
        for (let i = operation.expressions.length - 1; i >= 0; i--) {
            let expr = operation.expressions[i];
            const isAscending = this.isAscending(expr);
            expr = this.extractSortExpression(expr);
            // Transform the stream by annotating it with the expr result
            const evaluator = new sparqlee_1.AsyncEvaluator(expr, sparqleeConfig);
            // eslint-disable-next-line @typescript-eslint/no-loop-func
            const transform = async (bindings, next, push) => {
                try {
                    const result = await evaluator.evaluate(bindings);
                    push({ bindings, result });
                }
                catch (error) {
                    // We ignore all Expression errors.
                    // Other errors (likely programming mistakes) are still propagated.
                    // I can't recall where this is defined in the spec.
                    if (!(0, sparqlee_1.isExpressionError)(error)) {
                        bindingsStream.emit('error', error);
                    }
                    push({ bindings, result: undefined });
                }
                next();
            };
            const transformedStream = bindingsStream.transform({ transform });
            // Sort the annoted stream
            const sortedStream = new SortIterator_1.SortIterator(transformedStream, (left, right) => (0, sparqlee_1.orderTypes)(left.result, right.result, isAscending), options);
            // Remove the annotation
            bindingsStream = sortedStream.map(({ bindings, result }) => bindings);
        }
        return {
            type: 'bindings',
            bindingsStream,
            metadata: output.metadata,
        };
    }
    // Remove descending operator if necessary
    extractSortExpression(expr) {
        const { expressionType, operator } = expr;
        if (expressionType !== sparqlalgebrajs_1.Algebra.expressionTypes.OPERATOR) {
            return expr;
        }
        return operator === 'desc' ?
            expr.args[0] :
            expr;
    }
    isAscending(expr) {
        const { expressionType, operator } = expr;
        if (expressionType !== sparqlalgebrajs_1.Algebra.expressionTypes.OPERATOR) {
            return true;
        }
        return operator !== 'desc';
    }
}
exports.ActorQueryOperationOrderBySparqlee = ActorQueryOperationOrderBySparqlee;
//# sourceMappingURL=ActorQueryOperationOrderBySparqlee.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-orderby-sparqlee/lib/SortIterator.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SortIterator = void 0;
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
// Based on https://github.com/LinkedDataFragments/Client.js/blob/master/lib/sparql/SortIterator.js
class SortIterator extends asynciterator_1.TransformIterator {
    constructor(source, sort, options) {
        super(source, options);
        // The `window` parameter indicates the length of the sliding window to apply sorting
        const window = options && options.window;
        this.windowLength = Number.isFinite(window) && window > 0 ? window : Number.POSITIVE_INFINITY;
        this.sort = sort;
        this.sorted = [];
    }
    // Reads the smallest item in the current sorting window
    _read(count, done) {
        let item;
        let { length } = this.sorted;
        // Try to read items until we reach the desired window length
        while (length !== this.windowLength) {
            item = this.source.read();
            if (item === null) {
                break;
            }
            // Insert the item in the sorted window (smallest last)
            let left = 0;
            let right = length - 1;
            let mid;
            let order;
            while (left <= right) {
                mid = Math.trunc((left + right) / 2);
                order = this.sort(item, this.sorted[mid]);
                if (order < 0) {
                    left = mid + 1;
                }
                else if (order > 0) {
                    right = mid - 1;
                }
                else {
                    left = mid;
                    right = -1;
                }
            }
            this.sorted.splice(left, 0, item);
            length++;
        }
        // Push the smallest item in the window
        if (length === this.windowLength) {
            this._push(this.sorted.pop());
        }
        done();
    }
    // Flushes remaining data after the source has ended
    _flush(done) {
        let { length } = this.sorted;
        while (length--) {
            this._push(this.sorted.pop());
        }
        done();
    }
}
exports.SortIterator = SortIterator;
//# sourceMappingURL=SortIterator.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-orderby-sparqlee/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-orderby-sparqlee/lib/ActorQueryOperationOrderBySparqlee.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-path-alt/lib/ActorQueryOperationPathAlt.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationPathAlt = void 0;
const actor_abstract_path_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-abstract-path/lib/index.js");
const actor_query_operation_union_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-union/lib/index.js");
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
/**
 * A comunica Path Alt Query Operation Actor.
 */
class ActorQueryOperationPathAlt extends actor_abstract_path_1.ActorAbstractPath {
    constructor(args) {
        super(args, sparqlalgebrajs_1.Algebra.types.ALT);
    }
    async runOperation(operation, context) {
        const predicate = operation.predicate;
        const subOperations = (await Promise.all(predicate.input
            .map(subPredicate => this.mediatorQueryOperation.mediate({
            context,
            operation: actor_abstract_path_1.ActorAbstractPath.FACTORY
                .createPath(operation.subject, subPredicate, operation.object, operation.graph),
        }))))
            .map(bus_query_operation_1.ActorQueryOperation.getSafeBindings);
        const bindingsStream = new asynciterator_1.UnionIterator(subOperations.map(op => op.bindingsStream), { autoStart: false });
        const metadata = () => Promise.all(subOperations.map(output => output.metadata()))
            .then(subMeta => actor_query_operation_union_1.ActorQueryOperationUnion.unionMetadata(subMeta, true));
        return {
            type: 'bindings',
            bindingsStream,
            metadata,
        };
    }
}
exports.ActorQueryOperationPathAlt = ActorQueryOperationPathAlt;
//# sourceMappingURL=ActorQueryOperationPathAlt.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-path-alt/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-path-alt/lib/ActorQueryOperationPathAlt.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-path-inv/lib/ActorQueryOperationPathInv.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationPathInv = void 0;
const actor_abstract_path_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-abstract-path/lib/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
/**
 * A comunica Path Inv Query Operation Actor.
 */
class ActorQueryOperationPathInv extends actor_abstract_path_1.ActorAbstractPath {
    constructor(args) {
        super(args, sparqlalgebrajs_1.Algebra.types.INV);
    }
    async runOperation(operation, context) {
        const predicate = operation.predicate;
        const invPath = actor_abstract_path_1.ActorAbstractPath.FACTORY
            .createPath(operation.object, predicate.path, operation.subject, operation.graph);
        return this.mediatorQueryOperation.mediate({ operation: invPath, context });
    }
}
exports.ActorQueryOperationPathInv = ActorQueryOperationPathInv;
//# sourceMappingURL=ActorQueryOperationPathInv.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-path-inv/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-path-inv/lib/ActorQueryOperationPathInv.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-path-link/lib/ActorQueryOperationPathLink.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationPathLink = void 0;
const actor_abstract_path_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-abstract-path/lib/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
/**
 * A comunica Path Link Query Operation Actor.
 */
class ActorQueryOperationPathLink extends actor_abstract_path_1.ActorAbstractPath {
    constructor(args) {
        super(args, sparqlalgebrajs_1.Algebra.types.LINK);
    }
    async runOperation(operationOriginal, context) {
        const predicate = operationOriginal.predicate;
        const operation = actor_abstract_path_1.ActorAbstractPath.FACTORY.createPattern(operationOriginal.subject, predicate.iri, operationOriginal.object, operationOriginal.graph);
        return this.mediatorQueryOperation.mediate({ operation, context });
    }
}
exports.ActorQueryOperationPathLink = ActorQueryOperationPathLink;
//# sourceMappingURL=ActorQueryOperationPathLink.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-path-link/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-path-link/lib/ActorQueryOperationPathLink.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-path-nps/lib/ActorQueryOperationPathNps.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationPathNps = void 0;
const actor_abstract_path_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-abstract-path/lib/index.js");
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
/**
 * A comunica Path Nps Query Operation Actor.
 */
class ActorQueryOperationPathNps extends actor_abstract_path_1.ActorAbstractPath {
    constructor(args) {
        super(args, sparqlalgebrajs_1.Algebra.types.NPS);
    }
    async runOperation(operation, context) {
        const predicate = operation.predicate;
        const blank = this.generateVariable(operation);
        const pattern = actor_abstract_path_1.ActorAbstractPath.FACTORY
            .createPattern(operation.subject, blank, operation.object, operation.graph);
        const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: pattern, context }));
        // Remove the generated blank nodes from the bindings
        const bindingsStream = output.bindingsStream.transform({
            filter(bindings) {
                return !predicate.iris.some(iri => iri.equals(bindings.get(blank)));
            },
            transform(item, next, push) {
                push(item.delete(blank));
                next();
            },
        });
        return {
            type: 'bindings',
            bindingsStream,
            metadata: output.metadata,
        };
    }
}
exports.ActorQueryOperationPathNps = ActorQueryOperationPathNps;
//# sourceMappingURL=ActorQueryOperationPathNps.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-path-nps/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-path-nps/lib/ActorQueryOperationPathNps.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-path-one-or-more/lib/ActorQueryOperationPathOneOrMore.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationPathOneOrMore = void 0;
const actor_abstract_path_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-abstract-path/lib/index.js");
const bindings_factory_1 = __quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/index.js");
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
const BF = new bindings_factory_1.BindingsFactory();
/**
 * A comunica Path OneOrMore Query Operation Actor.
 */
class ActorQueryOperationPathOneOrMore extends actor_abstract_path_1.ActorAbstractPath {
    constructor(args) {
        super(args, sparqlalgebrajs_1.Algebra.types.ONE_OR_MORE_PATH);
    }
    async runOperation(operation, context) {
        const distinct = await this.isPathArbitraryLengthDistinct(context, operation);
        if (distinct.operation) {
            return distinct.operation;
        }
        context = distinct.context;
        const predicate = operation.predicate;
        if (operation.subject.termType !== 'Variable' && operation.object.termType === 'Variable') {
            const objectVar = operation.object;
            const starEval = await this.getObjectsPredicateStarEval(operation.subject, predicate.path, objectVar, operation.graph, context, false);
            const variables = operation.graph.termType === 'Variable' ? [objectVar, operation.graph] : [objectVar];
            return {
                type: 'bindings',
                bindingsStream: starEval.bindingsStream,
                metadata: async () => ({ ...await starEval.metadata(), variables }),
            };
        }
        if (operation.subject.termType === 'Variable' && operation.object.termType === 'Variable') {
            // Get all the results of subjects with same predicate, but once, then fill in first variable for those
            const single = actor_abstract_path_1.ActorAbstractPath.FACTORY.createDistinct(actor_abstract_path_1.ActorAbstractPath.FACTORY
                .createPath(operation.subject, operation.predicate.path, operation.object, operation.graph));
            const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ context, operation: single }));
            const subjectVar = operation.subject;
            const objectVar = operation.object;
            const termHashes = {};
            const bindingsStream = new asynciterator_1.MultiTransformIterator(results.bindingsStream, {
                multiTransform: (bindings) => {
                    const subject = bindings.get(subjectVar);
                    const object = bindings.get(objectVar);
                    const graph = operation.graph.termType === 'Variable' ? bindings.get(operation.graph) : operation.graph;
                    return new asynciterator_1.TransformIterator(async () => {
                        const it = new asynciterator_1.BufferedIterator();
                        await this.getSubjectAndObjectBindingsPredicateStar(subjectVar, objectVar, subject, object, predicate.path, graph, context, termHashes, {}, it, { count: 0 });
                        return it.transform({
                            transform(item, next, push) {
                                if (operation.graph.termType === 'Variable') {
                                    item = item.set(operation.graph, graph);
                                }
                                push(item);
                                next();
                            },
                        });
                    }, { maxBufferSize: 128 });
                },
                autoStart: false,
            });
            const variables = operation.graph.termType === 'Variable' ?
                [subjectVar, objectVar, operation.graph] :
                [subjectVar, objectVar];
            return {
                type: 'bindings',
                bindingsStream,
                metadata: async () => ({ ...await results.metadata(), variables }),
            };
        }
        if (operation.subject.termType === 'Variable' && operation.object.termType !== 'Variable') {
            return this.mediatorQueryOperation.mediate({
                context,
                operation: actor_abstract_path_1.ActorAbstractPath.FACTORY.createPath(operation.object, actor_abstract_path_1.ActorAbstractPath.FACTORY.createOneOrMorePath(actor_abstract_path_1.ActorAbstractPath.FACTORY.createInv(predicate.path)), operation.subject, operation.graph),
            });
        }
        // If (!sVar && !oVar)
        const variable = this.generateVariable();
        const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
            context,
            operation: actor_abstract_path_1.ActorAbstractPath.FACTORY.createPath(operation.subject, predicate, variable, operation.graph),
        }));
        const bindingsStream = results.bindingsStream.transform({
            filter: item => operation.object.equals(item.get(variable)),
            transform(item, next, push) {
                const binding = operation.graph.termType === 'Variable' ?
                    BF.bindings([[operation.graph, item.get(operation.graph)]]) :
                    BF.bindings();
                push(binding);
                next();
            },
        });
        return {
            type: 'bindings',
            bindingsStream,
            metadata: async () => ({
                ...await results.metadata(),
                variables: operation.graph.termType === 'Variable' ? [operation.graph] : [],
            }),
        };
    }
}
exports.ActorQueryOperationPathOneOrMore = ActorQueryOperationPathOneOrMore;
//# sourceMappingURL=ActorQueryOperationPathOneOrMore.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-path-one-or-more/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-path-one-or-more/lib/ActorQueryOperationPathOneOrMore.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-path-seq/lib/ActorQueryOperationPathSeq.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationPathSeq = void 0;
const actor_abstract_path_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-abstract-path/lib/index.js");
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
/**
 * A comunica Path Seq Query Operation Actor.
 */
class ActorQueryOperationPathSeq extends actor_abstract_path_1.ActorAbstractPath {
    constructor(args) {
        super(args, sparqlalgebrajs_1.Algebra.types.SEQ);
    }
    async runOperation(operationOriginal, context) {
        const predicate = operationOriginal.predicate;
        let joiner = operationOriginal.subject;
        const generatedVariableNames = [];
        const entries = await Promise.all(predicate.input
            .map((subPredicate, i) => {
            const nextJoiner = i === predicate.input.length - 1 ? operationOriginal.object : this.generateVariable(operationOriginal, `b${i}`);
            const operation = actor_abstract_path_1.ActorAbstractPath.FACTORY
                .createPath(joiner, subPredicate, nextJoiner, operationOriginal.graph);
            const output = this.mediatorQueryOperation.mediate({
                context,
                operation,
            });
            joiner = nextJoiner;
            if (i < predicate.input.length - 1) {
                generatedVariableNames.push(nextJoiner);
            }
            return { output, operation };
        })
            .map(async ({ output, operation }) => ({
            output: bus_query_operation_1.ActorQueryOperation.getSafeBindings(await output),
            operation,
        })));
        const join = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorJoin
            .mediate({ type: 'inner', entries, context }));
        // Remove the generated variable from the bindings
        const bindingsStream = join.bindingsStream.transform({
            transform(item, next, push) {
                for (const generatedVariableName of generatedVariableNames) {
                    item = item.delete(generatedVariableName);
                }
                push(item);
                next();
            },
        });
        // Remove the generated variable from the list of variables
        return {
            type: 'bindings',
            bindingsStream,
            async metadata() {
                const joinMetadata = await join.metadata();
                const variables = joinMetadata.variables.filter(variable => !generatedVariableNames
                    .some(generatedVariableName => generatedVariableName.value === variable.value));
                return { ...joinMetadata, variables };
            },
        };
    }
}
exports.ActorQueryOperationPathSeq = ActorQueryOperationPathSeq;
//# sourceMappingURL=ActorQueryOperationPathSeq.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-path-seq/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-path-seq/lib/ActorQueryOperationPathSeq.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-path-zero-or-more/lib/ActorQueryOperationPathZeroOrMore.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationPathZeroOrMore = void 0;
const actor_abstract_path_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-abstract-path/lib/index.js");
const bindings_factory_1 = __quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/index.js");
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
const rdf_string_1 = __quadstore_comunica_require__("../node_modules/rdf-string/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
const BF = new bindings_factory_1.BindingsFactory();
/**
 * A comunica Path ZeroOrMore Query Operation Actor.
 */
class ActorQueryOperationPathZeroOrMore extends actor_abstract_path_1.ActorAbstractPath {
    constructor(args) {
        super(args, sparqlalgebrajs_1.Algebra.types.ZERO_OR_MORE_PATH);
    }
    async runOperation(operation, context) {
        const distinct = await this.isPathArbitraryLengthDistinct(context, operation);
        if (distinct.operation) {
            return distinct.operation;
        }
        context = distinct.context;
        const predicate = operation.predicate;
        const sVar = operation.subject.termType === 'Variable';
        const oVar = operation.object.termType === 'Variable';
        if (operation.subject.termType === 'Variable' && operation.object.termType === 'Variable') {
            // Query ?s ?p ?o, to get all possible namedNodes in de the db
            const predVar = this.generateVariable(operation);
            const single = actor_abstract_path_1.ActorAbstractPath.FACTORY
                .createPattern(operation.subject, predVar, operation.object, operation.graph);
            const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ context, operation: single }));
            const subjectVar = operation.subject;
            const objectVar = operation.object;
            // Set with all namedNodes we have already started a predicate* search from
            const entities = new Set();
            const termHashes = {};
            const bindingsStream = new asynciterator_1.MultiTransformIterator(results.bindingsStream, {
                multiTransform: (bindings) => {
                    // Get the subject and object of the triples (?s ?p ?o) and extract graph if it was a variable
                    const subject = bindings.get(subjectVar);
                    const object = bindings.get(objectVar);
                    const graph = operation.graph.termType === 'Variable' ?
                        bindings.get(operation.graph) :
                        operation.graph;
                    // Make a hash of namedNode + graph to remember from where we already started a search
                    const subjectGraphHash = (0, rdf_string_1.termToString)(subject) + (0, rdf_string_1.termToString)(graph);
                    const objectGraphHash = (0, rdf_string_1.termToString)(object) + (0, rdf_string_1.termToString)(graph);
                    return new asynciterator_1.TransformIterator(async () => {
                        // If no new namedNodes in this triple, return nothing
                        if (entities.has(subjectGraphHash) && entities.has(objectGraphHash)) {
                            return new asynciterator_1.EmptyIterator();
                        }
                        // Set up an iterator to which getSubjectAndObjectBindingsPredicateStar will push solutions
                        const it = new asynciterator_1.BufferedIterator();
                        const counter = { count: 0 };
                        // If not started from this namedNode (subject in triple) in this graph, start a search
                        if (!entities.has(subjectGraphHash)) {
                            entities.add(subjectGraphHash);
                            await this.getSubjectAndObjectBindingsPredicateStar(subjectVar, objectVar, subject, subject, predicate.path, graph, context, termHashes, {}, it, counter);
                        }
                        // If not started from this namedNode (object in triple) in this graph, start a search
                        if (!entities.has(objectGraphHash)) {
                            entities.add(objectGraphHash);
                            await this.getSubjectAndObjectBindingsPredicateStar(subjectVar, objectVar, object, object, predicate.path, graph, context, termHashes, {}, it, counter);
                        }
                        return it.transform({
                            transform(item, next, push) {
                                // If the graph was a variable, fill in it's binding (we got it from the ?s ?p ?o binding)
                                if (operation.graph.termType === 'Variable') {
                                    item = item.set(operation.graph, graph);
                                }
                                push(item);
                                next();
                            },
                        });
                    });
                },
            });
            const variables = operation.graph.termType === 'Variable' ?
                [subjectVar, operation.object, operation.graph] :
                [subjectVar, operation.object];
            return {
                type: 'bindings',
                bindingsStream,
                metadata: async () => ({ ...await results.metadata(), variables }),
            };
        }
        if (!sVar && !oVar) {
            const variable = this.generateVariable();
            const starEval = await this.getObjectsPredicateStarEval(operation.subject, predicate.path, variable, operation.graph, context, true);
            const bindingsStream = starEval.bindingsStream.transform({
                filter: item => operation.object.equals(item.get(variable)),
                transform(item, next, push) {
                    // Return graph binding if graph was a variable, otherwise empty binding
                    const binding = operation.graph.termType === 'Variable' ?
                        BF.bindings([[operation.graph, item.get(operation.graph)]]) :
                        BF.bindings();
                    push(binding);
                    next();
                },
            });
            return {
                type: 'bindings',
                bindingsStream,
                metadata: async () => ({
                    ...await starEval.metadata(),
                    variables: operation.graph.termType === 'Variable' ? [operation.graph] : [],
                }),
            };
        }
        // If (sVar || oVar)
        const subject = sVar ? operation.object : operation.subject;
        const value = (sVar ? operation.subject : operation.object);
        const pred = sVar ? actor_abstract_path_1.ActorAbstractPath.FACTORY.createInv(predicate.path) : predicate.path;
        const starEval = await this.getObjectsPredicateStarEval(subject, pred, value, operation.graph, context, true);
        const variables = operation.graph.termType === 'Variable' ? [value, operation.graph] : [value];
        return {
            type: 'bindings',
            bindingsStream: starEval.bindingsStream,
            metadata: async () => ({ ...await starEval.metadata(), variables }),
        };
    }
}
exports.ActorQueryOperationPathZeroOrMore = ActorQueryOperationPathZeroOrMore;
//# sourceMappingURL=ActorQueryOperationPathZeroOrMore.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-path-zero-or-more/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-path-zero-or-more/lib/ActorQueryOperationPathZeroOrMore.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-path-zero-or-one/lib/ActorQueryOperationPathZeroOrOne.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationPathZeroOrOne = void 0;
const actor_abstract_path_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-abstract-path/lib/index.js");
const bindings_factory_1 = __quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/index.js");
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
const BF = new bindings_factory_1.BindingsFactory();
/**
 * A comunica Path ZeroOrOne Query Operation Actor.
 */
class ActorQueryOperationPathZeroOrOne extends actor_abstract_path_1.ActorAbstractPath {
    constructor(args) {
        super(args, sparqlalgebrajs_1.Algebra.types.ZERO_OR_ONE_PATH);
    }
    async runOperation(operation, context) {
        const predicate = operation.predicate;
        const sVar = operation.subject.termType === 'Variable';
        const oVar = operation.object.termType === 'Variable';
        const extra = [];
        // Both subject and object non-variables
        if (!sVar && !oVar && operation.subject.equals(operation.object)) {
            return {
                type: 'bindings',
                bindingsStream: new asynciterator_1.SingletonIterator(BF.bindings()),
                metadata: () => Promise.resolve({
                    cardinality: { type: 'exact', value: 1 },
                    canContainUndefs: false,
                    variables: [],
                }),
            };
        }
        if (sVar && oVar) {
            throw new Error('ZeroOrOne path expressions with 2 variables not supported yet');
        }
        const distinct = await this.isPathArbitraryLengthDistinct(context, operation);
        if (distinct.operation) {
            return distinct.operation;
        }
        context = distinct.context;
        if (operation.subject.termType === 'Variable') {
            extra.push(BF.bindings([[operation.subject, operation.object]]));
        }
        if (operation.object.termType === 'Variable') {
            extra.push(BF.bindings([[operation.object, operation.subject]]));
        }
        const single = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
            context,
            operation: actor_abstract_path_1.ActorAbstractPath.FACTORY
                .createPath(operation.subject, predicate.path, operation.object, operation.graph),
        }));
        const bindingsStream = single.bindingsStream.prepend(extra);
        return {
            type: 'bindings',
            bindingsStream,
            metadata: single.metadata,
        };
    }
}
exports.ActorQueryOperationPathZeroOrOne = ActorQueryOperationPathZeroOrOne;
//# sourceMappingURL=ActorQueryOperationPathZeroOrOne.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-path-zero-or-one/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-path-zero-or-one/lib/ActorQueryOperationPathZeroOrOne.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-project/lib/ActorQueryOperationProject.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationProject = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const data_factory_1 = __quadstore_comunica_require__("../node_modules/@comunica/data-factory/lib/index.js");
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A comunica Project Query Operation Actor.
 */
class ActorQueryOperationProject extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'project');
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(operation, context) {
        // Resolve the input
        const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: operation.input, context }));
        // Find all variables that should be deleted from the input stream.
        const outputMetadata = await output.metadata();
        const variables = operation.variables;
        const deleteVariables = outputMetadata.variables
            .filter(variable => !variables.some(subVariable => variable.value === subVariable.value));
        // Error if there are variables that are not bound in the input stream.
        const missingVariables = variables
            .filter(variable => !outputMetadata.variables.some(subVariable => variable.value === subVariable.value));
        if (missingVariables.length > 0) {
            throw new Error(`Variables '${missingVariables.map(variable => `?${variable.value}`)}' are used in the projection result, but are not assigned.`);
        }
        // Make sure the project variables are the only variables that are present in the bindings.
        let bindingsStream = deleteVariables.length === 0 ?
            output.bindingsStream :
            output.bindingsStream.transform({
                map(bindings) {
                    for (const deleteVariable of deleteVariables) {
                        bindings = bindings.delete(deleteVariable);
                    }
                    return bindings;
                },
                autoStart: false,
            });
        // Make sure that blank nodes with same labels are not reused over different bindings, as required by SPARQL 1.1.
        // Required for the BNODE() function: https://www.w3.org/TR/sparql11-query/#func-bnode
        // When we have a scoped blank node, make sure the skolemized value is maintained.
        let blankNodeCounter = 0;
        bindingsStream = bindingsStream.transform({
            map(bindings) {
                blankNodeCounter++;
                const scopedBlankNodesCache = new Map();
                return bindings.map(term => {
                    if (term instanceof data_factory_1.BlankNodeBindingsScoped) {
                        let scopedBlankNode = scopedBlankNodesCache.get(term.value);
                        if (!scopedBlankNode) {
                            scopedBlankNode = DF.blankNode(`${term.value}${blankNodeCounter}`);
                            scopedBlankNodesCache.set(term.value, scopedBlankNode);
                        }
                        return scopedBlankNode;
                    }
                    return term;
                });
            },
            autoStart: false,
        });
        return {
            type: 'bindings',
            bindingsStream,
            metadata: async () => ({ ...outputMetadata, variables }),
        };
    }
}
exports.ActorQueryOperationProject = ActorQueryOperationProject;
//# sourceMappingURL=ActorQueryOperationProject.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-project/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-project/lib/ActorQueryOperationProject.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-quadpattern/lib/ActorQueryOperationQuadpattern.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationQuadpattern = void 0;
const bindings_factory_1 = __quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/index.js");
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const context_entries_1 = __quadstore_comunica_require__("../node_modules/@comunica/context-entries/lib/index.js");
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const rdf_terms_1 = __quadstore_comunica_require__("../node_modules/rdf-terms/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
const BF = new bindings_factory_1.BindingsFactory();
const DF = new rdf_data_factory_1.DataFactory();
const AF = new sparqlalgebrajs_1.Factory();
/**
 * A comunica actor for handling 'quadpattern' query operations.
 */
class ActorQueryOperationQuadpattern extends bus_query_operation_1.ActorQueryOperationTyped {
    constructor(args) {
        super(args, 'pattern');
    }
    /**
     * Check if a term is a variable.
     * @param {RDF.Term} term An RDF term.
     * @return {any} If the term is a variable or blank node.
     */
    static isTermVariable(term) {
        return term.termType === 'Variable';
    }
    /**
     * Get all variables in the given pattern.
     * No duplicates are returned.
     * @param {RDF.BaseQuad} pattern A quad pattern.
     */
    static getVariables(pattern) {
        return (0, rdf_terms_1.uniqTerms)((0, rdf_terms_1.getTerms)(pattern)
            .filter(ActorQueryOperationQuadpattern.isTermVariable));
    }
    /**
     * A helper function to find a hash with quad elements that have duplicate variables.
     *
     * @param {RDF.Quad} pattern A quad pattern.
     *
     * @return {{[p: string]: string[]}} If no equal variable names are present in the four terms, this returns undefined.
     *                                   Otherwise, this maps quad elements ('subject', 'predicate', 'object', 'graph')
     *                                   to the list of quad elements it shares a variable name with.
     *                                   If no links for a certain element exist, this element will
     *                                   not be included in the hash.
     *                                   Note 1: Quad elements will never have a link to themselves.
     *                                           So this can never occur: { subject: [ 'subject'] },
     *                                           instead 'null' would be returned.
     *                                   Note 2: Links only exist in one direction,
     *                                           this means that { subject: [ 'predicate'], predicate: [ 'subject' ] }
     *                                           will not occur, instead only { subject: [ 'predicate'] }
     *                                           will be returned.
     */
    static getDuplicateElementLinks(pattern) {
        // Collect a variable to quad elements mapping.
        const variableElements = {};
        let duplicateVariables = false;
        for (const key of rdf_terms_1.QUAD_TERM_NAMES) {
            if (pattern[key].termType === 'Variable') {
                const val = pattern[key].value;
                const length = (variableElements[val] || (variableElements[val] = [])).push(key);
                duplicateVariables = duplicateVariables || length > 1;
            }
        }
        if (!duplicateVariables) {
            return;
        }
        // Collect quad element to elements with equal variables mapping.
        const duplicateElementLinks = {};
        for (const variable in variableElements) {
            const elements = variableElements[variable];
            const remainingElements = elements.slice(1);
            // Only store the elements that have at least one equal element.
            if (remainingElements.length > 0) {
                duplicateElementLinks[elements[0]] = remainingElements;
            }
        }
        return duplicateElementLinks;
    }
    /**
     * Ensure that the given raw metadata object contains all required metadata entries.
     * @param metadataRaw A raw metadata object.
     */
    static validateMetadata(metadataRaw) {
        for (const key of ['cardinality', 'canContainUndefs']) {
            if (!(key in metadataRaw)) {
                throw new Error(`Invalid metadata: missing ${key} in ${JSON.stringify(metadataRaw)}`);
            }
        }
        return metadataRaw;
    }
    /**
     * Get the metadata of the given action on a quad stream.
     *
     * @param {AsyncIterator<Quad>} data The data stream that is guaranteed to emit the metadata property.
     * @param elementVariables Mapping of quad term name to variable name.
     * @param variables Variables to include in the metadata
     * @return {() => Promise<{[p: string]: any}>} A lazy promise behind a callback resolving to a metadata object.
     */
    static getMetadata(data, elementVariables, variables) {
        return () => new Promise((resolve, reject) => {
            data.getProperty('metadata', (metadata) => resolve(metadata));
            data.on('error', reject);
        }).then(metadataRaw => {
            if (!('canContainUndefs' in metadataRaw)) {
                metadataRaw.canContainUndefs = false;
            }
            return ActorQueryOperationQuadpattern.quadsMetadataToBindingsMetadata(ActorQueryOperationQuadpattern.validateMetadata(metadataRaw), elementVariables, variables);
        });
    }
    static quadsMetadataToBindingsMetadata(metadataQuads, elementVariables, variables) {
        return {
            ...metadataQuads,
            order: metadataQuads.order ?
                ActorQueryOperationQuadpattern.quadsOrderToBindingsOrder(metadataQuads.order, elementVariables) :
                undefined,
            availableOrders: metadataQuads.availableOrders ?
                metadataQuads.availableOrders.map(orderDef => ({
                    cost: orderDef.cost,
                    terms: ActorQueryOperationQuadpattern.quadsOrderToBindingsOrder(orderDef.terms, elementVariables),
                })) :
                undefined,
            variables,
        };
    }
    static quadsOrderToBindingsOrder(quadsOrder, elementVariables) {
        const mappedVariables = {};
        return quadsOrder.map(entry => {
            // Omit entries that do not map to a variable
            const variableName = elementVariables[entry.term];
            if (!variableName) {
                return;
            }
            // Omit entries that have been mapped already
            if (mappedVariables[variableName]) {
                return;
            }
            mappedVariables[variableName] = true;
            return {
                term: DF.variable(variableName),
                direction: entry.direction,
            };
        }).filter(entry => Boolean(entry));
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(pattern, context) {
        // Apply the (optional) pattern-specific context
        if (pattern.context) {
            context = context.merge(pattern.context);
        }
        // Modify pattern with default graph when using union default graph semantics
        let patternInner = pattern;
        const unionDefaultGraph = this.unionDefaultGraph || context.get(context_entries_1.KeysQueryOperation.unionDefaultGraph);
        if (pattern.graph.termType === 'DefaultGraph' && unionDefaultGraph) {
            patternInner = AF.createPattern(pattern.subject, pattern.predicate, pattern.object, DF.variable('__comunica:defaultGraph'));
        }
        // Resolve the quad pattern
        const result = await this.mediatorResolveQuadPattern.mediate({ pattern: patternInner, context });
        // Collect all variables from the pattern
        const variables = ActorQueryOperationQuadpattern.getVariables(pattern);
        // Convenience datastructure for mapping quad elements to variables
        const elementVariables = (0, rdf_terms_1.reduceTerms)(pattern, (acc, term, key) => {
            if (term.termType === 'Variable') {
                acc[key] = term.value;
            }
            return acc;
        }, {});
        const quadBindingsReducer = (acc, term, key) => {
            const variable = elementVariables[key];
            if (variable) {
                acc.push([DF.variable(variable), term]);
            }
            return acc;
        };
        // Create the metadata callback
        const metadata = ActorQueryOperationQuadpattern.getMetadata(result.data, elementVariables, variables);
        // Optionally filter, and construct bindings
        const bindingsStream = new bus_query_operation_1.ClosableTransformIterator(async () => {
            let filteredOutput = result.data;
            // Detect duplicate variables in the pattern
            const duplicateElementLinks = ActorQueryOperationQuadpattern
                .getDuplicateElementLinks(pattern);
            // SPARQL query semantics allow graph variables to only match with named graphs, excluding the default graph
            // But this is not the case when using union default graph semantics
            if (pattern.graph.termType === 'Variable' && !unionDefaultGraph) {
                filteredOutput = filteredOutput.filter(quad => quad.graph.termType !== 'DefaultGraph');
            }
            // If there are duplicate variables in the search pattern,
            // make sure that we filter out the triples that don't have equal values for those triple elements,
            // as QPF ignores variable names.
            if (duplicateElementLinks) {
                filteredOutput = filteredOutput.filter(quad => {
                    // No need to check the graph, because an equal element already would have to be found in s, p, or o.
                    for (const element1 of rdf_terms_1.TRIPLE_TERM_NAMES) {
                        for (const element2 of duplicateElementLinks[element1] || []) {
                            if (!quad[element1].equals(quad[element2])) {
                                return false;
                            }
                        }
                    }
                    return true;
                });
            }
            return filteredOutput.map(quad => BF.bindings((0, rdf_terms_1.reduceTerms)(quad, quadBindingsReducer, [])));
        }, {
            autoStart: false,
            onClose: () => result.data.destroy(),
        });
        return { type: 'bindings', bindingsStream, metadata };
    }
}
exports.ActorQueryOperationQuadpattern = ActorQueryOperationQuadpattern;
//# sourceMappingURL=ActorQueryOperationQuadpattern.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-quadpattern/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-quadpattern/lib/ActorQueryOperationQuadpattern.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-reduced-hash/lib/ActorQueryOperationReducedHash.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationReducedHash = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const LRU = __quadstore_comunica_require__("../node_modules/lru-cache/index.js");
/**
 * A comunica Reduced Hash Query Operation Actor.
 */
class ActorQueryOperationReducedHash extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'reduced');
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(operation, context) {
        const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: operation.input, context }));
        const bindingsStream = output.bindingsStream.filter(await this.newHashFilter(context));
        return {
            type: 'bindings',
            bindingsStream,
            metadata: output.metadata,
        };
    }
    /**
     * Create a new distinct filter function.
     * This will maintain an internal hash datastructure so that every bindings object only returns true once.
     * @param context The action context.
     * @return {(bindings: Bindings) => boolean} A distinct filter for bindings.
     */
    async newHashFilter(context) {
        const { hashFunction } = await this.mediatorHashBindings.mediate({ allowHashCollisions: true, context });
        const hashes = new LRU({ max: this.cacheSize });
        return (bindings) => {
            const hash = hashFunction(bindings);
            return !hashes.has(hash) && hashes.set(hash, true);
        };
    }
}
exports.ActorQueryOperationReducedHash = ActorQueryOperationReducedHash;
//# sourceMappingURL=ActorQueryOperationReducedHash.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-reduced-hash/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-reduced-hash/lib/ActorQueryOperationReducedHash.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-service/lib/ActorQueryOperationService.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationService = void 0;
const bindings_factory_1 = __quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/index.js");
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const context_entries_1 = __quadstore_comunica_require__("../node_modules/@comunica/context-entries/lib/index.js");
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
const BF = new bindings_factory_1.BindingsFactory();
/**
 * A comunica Service Query Operation Actor.
 * It unwraps the SERVICE operation and executes it on the given source.
 */
class ActorQueryOperationService extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'service');
    }
    async testOperation(operation, context) {
        if (operation.name.termType !== 'NamedNode') {
            throw new Error(`${this.name} can only query services by IRI, while a ${operation.name.termType} was given.`);
        }
        return true;
    }
    async runOperation(operation, context) {
        const endpoint = operation.name.value;
        // Adjust our context to only have the endpoint as source
        let subContext = context
            .delete(context_entries_1.KeysRdfResolveQuadPattern.source)
            .delete(context_entries_1.KeysRdfResolveQuadPattern.sources)
            .delete(context_entries_1.KeysInitQuery.queryString);
        const sourceType = this.forceSparqlEndpoint ? 'sparql' : undefined;
        subContext = subContext.set(context_entries_1.KeysRdfResolveQuadPattern.sources, [{ type: sourceType, value: endpoint }]);
        // Query the source
        let output;
        try {
            output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: operation.input, context: subContext }));
        }
        catch (error) {
            if (operation.silent) {
                // Emit a single empty binding
                output = {
                    bindingsStream: new asynciterator_1.SingletonIterator(BF.bindings()),
                    type: 'bindings',
                    metadata: async () => ({ cardinality: { type: 'exact', value: 1 }, canContainUndefs: false, variables: [] }),
                };
            }
            else {
                throw error;
            }
        }
        return output;
    }
}
exports.ActorQueryOperationService = ActorQueryOperationService;
//# sourceMappingURL=ActorQueryOperationService.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-service/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-service/lib/ActorQueryOperationService.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-slice/lib/ActorQueryOperationSlice.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationSlice = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const context_entries_1 = __quadstore_comunica_require__("../node_modules/@comunica/context-entries/lib/index.js");
/**
 * A comunica Slice Query Operation Actor.
 */
class ActorQueryOperationSlice extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'slice');
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(operation, context) {
        // Add limit indicator to the context, which can be used for query planning
        // eslint-disable-next-line unicorn/explicit-length-check
        if (operation.length) {
            context = context.set(context_entries_1.KeysQueryOperation.limitIndicator, operation.length);
        }
        // Resolve the input
        const output = await this.mediatorQueryOperation
            .mediate({ operation: operation.input, context });
        if (output.type === 'bindings') {
            const bindingsStream = this.sliceStream(output.bindingsStream, operation);
            return {
                type: 'bindings',
                bindingsStream,
                metadata: this.sliceMetadata(output, operation),
            };
        }
        if (output.type === 'quads') {
            const quadStream = this.sliceStream(output.quadStream, operation);
            return {
                type: 'quads',
                quadStream,
                metadata: this.sliceMetadata(output, operation),
            };
        }
        throw new Error(`Invalid query output type: Expected 'bindings' or 'quads' but got '${output.type}'`);
    }
    // Slice the stream based on the pattern values
    sliceStream(stream, pattern) {
        // eslint-disable-next-line unicorn/explicit-length-check
        const hasLength = Boolean(pattern.length) || pattern.length === 0;
        const { start } = pattern;
        const end = hasLength ? pattern.start + pattern.length - 1 : Number.POSITIVE_INFINITY;
        return stream.transform({ offset: start, limit: Math.max(end - start + 1, 0), autoStart: false });
    }
    // If we find metadata, apply slicing on the total number of items
    sliceMetadata(output, pattern) {
        // eslint-disable-next-line unicorn/explicit-length-check
        const hasLength = Boolean(pattern.length) || pattern.length === 0;
        return () => output.metadata()
            .then(subMetadata => {
            const cardinality = { ...subMetadata.cardinality };
            if (Number.isFinite(cardinality.value)) {
                cardinality.value = Math.max(0, cardinality.value - pattern.start);
                if (hasLength) {
                    cardinality.value = Math.min(cardinality.value, pattern.length);
                }
            }
            return { ...subMetadata, cardinality };
        });
    }
}
exports.ActorQueryOperationSlice = ActorQueryOperationSlice;
//# sourceMappingURL=ActorQueryOperationSlice.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-slice/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-slice/lib/ActorQueryOperationSlice.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-union/lib/ActorQueryOperationUnion.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationUnion = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
const rdf_terms_1 = __quadstore_comunica_require__("../node_modules/rdf-terms/index.js");
/**
 * A comunica Union Query Operation Actor.
 */
class ActorQueryOperationUnion extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'union');
    }
    /**
     * Takes the union of the given double array variables.
     * Uniqueness is guaranteed.
     * @param {string[][]} variables Double array of variables to take the union of.
     * @return {string[]} The union of the given variables.
     */
    static unionVariables(variables) {
        return (0, rdf_terms_1.uniqTerms)(variables.flat());
    }
    /**
     * Takes the union of the given metadata array.
     * It will ensure that the cardinality metadata value is properly calculated.
     * @param {{[p: string]: any}[]} metadatas Array of metadata.
     * @param bindings If the union of the variables field should also be taken.
     * @return {{[p: string]: any}} Union of the metadata.
     */
    static unionMetadata(metadatas, bindings) {
        // Union cardinality
        const cardinality = { type: 'exact', value: 0 };
        for (const metadata of metadatas) {
            if ((metadata.cardinality.value && Number.isFinite(metadata.cardinality.value)) ||
                metadata.cardinality.value === 0) {
                if (metadata.cardinality.type === 'estimate') {
                    cardinality.type = 'estimate';
                }
                cardinality.value += metadata.cardinality.value;
            }
            else {
                cardinality.type = 'estimate';
                cardinality.value = Number.POSITIVE_INFINITY;
                break;
            }
        }
        const metadataBase = {
            cardinality,
            canContainUndefs: metadatas.some(metadata => metadata.canContainUndefs),
        };
        // Union variables
        if (bindings) {
            metadataBase.variables = ActorQueryOperationUnion.unionVariables(metadatas.map(metadata => metadata.variables));
            return metadataBase;
        }
        return metadataBase;
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(operation, context) {
        const outputs = (await Promise.all(operation.input
            .map(subOperation => this.mediatorQueryOperation.mediate({ operation: subOperation, context }))))
            .map(bus_query_operation_1.ActorQueryOperation.getSafeBindings);
        const bindingsStream = new asynciterator_1.UnionIterator(outputs.map((output) => output.bindingsStream), { autoStart: false });
        const metadata = () => Promise.all(outputs.map(output => output.metadata()))
            .then(subMeta => ActorQueryOperationUnion.unionMetadata(subMeta, true));
        return { type: 'bindings', bindingsStream, metadata };
    }
}
exports.ActorQueryOperationUnion = ActorQueryOperationUnion;
//# sourceMappingURL=ActorQueryOperationUnion.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-union/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-union/lib/ActorQueryOperationUnion.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-update-add-rewrite/lib/ActorQueryOperationAddRewrite.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationAddRewrite = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A [Query Operation](https://github.com/comunica/comunica/tree/master/packages/bus-query-operation) actor
 * that handles SPARQL add operations.
 */
class ActorQueryOperationAddRewrite extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'add');
        this.factory = new sparqlalgebrajs_1.Factory();
    }
    async testOperation(operation, context) {
        bus_query_operation_1.ActorQueryOperation.throwOnReadOnly(context);
        return true;
    }
    runOperation(operationOriginal, context) {
        // CONSTRUCT all quads from the source, and INSERT them into the destination
        const destination = operationOriginal.destination === 'DEFAULT' ? DF.defaultGraph() : operationOriginal.destination;
        const source = operationOriginal.source === 'DEFAULT' ? DF.defaultGraph() : operationOriginal.source;
        const operation = this.factory.createDeleteInsert(undefined, [
            this.factory.createPattern(DF.variable('s'), DF.variable('p'), DF.variable('o'), destination),
        ], this.factory.createPattern(DF.variable('s'), DF.variable('p'), DF.variable('o'), source));
        return this.mediatorQueryOperation.mediate({ operation, context });
    }
}
exports.ActorQueryOperationAddRewrite = ActorQueryOperationAddRewrite;
//# sourceMappingURL=ActorQueryOperationAddRewrite.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-update-add-rewrite/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-update-add-rewrite/lib/ActorQueryOperationAddRewrite.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-update-clear/lib/ActorQueryOperationClear.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationClear = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A [Query Operation](https://github.com/comunica/comunica/tree/master/packages/bus-query-operation) actor
 * that handles SPARQL clear operations.
 */
class ActorQueryOperationClear extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'clear');
    }
    async testOperation(operation, context) {
        bus_query_operation_1.ActorQueryOperation.throwOnReadOnly(context);
        return true;
    }
    async runOperation(operation, context) {
        // Delegate to update-quads bus
        let graphs;
        if (operation.source === 'DEFAULT') {
            graphs = DF.defaultGraph();
        }
        else if (typeof operation.source === 'string') {
            graphs = operation.source;
        }
        else {
            graphs = [operation.source];
        }
        const { execute } = await this.mediatorUpdateQuads.mediate({
            deleteGraphs: {
                graphs,
                requireExistence: !operation.silent,
                dropGraphs: false,
            },
            context,
        });
        return {
            type: 'void',
            execute,
        };
    }
}
exports.ActorQueryOperationClear = ActorQueryOperationClear;
//# sourceMappingURL=ActorQueryOperationClear.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-update-clear/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-update-clear/lib/ActorQueryOperationClear.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-update-compositeupdate/lib/ActorQueryOperationUpdateCompositeUpdate.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationUpdateCompositeUpdate = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
/**
 * A comunica Update CompositeUpdate Query Operation Actor.
 */
class ActorQueryOperationUpdateCompositeUpdate extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'compositeupdate');
    }
    async testOperation(operation, context) {
        bus_query_operation_1.ActorQueryOperation.throwOnReadOnly(context);
        return true;
    }
    async runOperation(operationOriginal, context) {
        const execute = () => (async () => {
            // Execute update operations in sequence
            for (const operation of operationOriginal.updates) {
                const subResult = bus_query_operation_1.ActorQueryOperation
                    .getSafeVoid(await this.mediatorQueryOperation.mediate({ operation, context }));
                await subResult.execute();
            }
        })();
        return {
            type: 'void',
            execute,
        };
    }
}
exports.ActorQueryOperationUpdateCompositeUpdate = ActorQueryOperationUpdateCompositeUpdate;
//# sourceMappingURL=ActorQueryOperationUpdateCompositeUpdate.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-update-compositeupdate/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-update-compositeupdate/lib/ActorQueryOperationUpdateCompositeUpdate.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-update-copy-rewrite/lib/ActorQueryOperationCopyRewrite.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationCopyRewrite = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
/**
 * A [Query Operation](https://github.com/comunica/comunica/tree/master/packages/bus-query-operation) actor that
 * handles SPARQL copy operations.
 */
class ActorQueryOperationCopyRewrite extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'copy');
        this.factory = new sparqlalgebrajs_1.Factory();
    }
    async testOperation(operation, context) {
        bus_query_operation_1.ActorQueryOperation.throwOnReadOnly(context);
        return true;
    }
    runOperation(operationOriginal, context) {
        // No-op if source === destination
        if ((typeof operationOriginal.destination === 'string' && typeof operationOriginal.source === 'string' &&
            operationOriginal.destination === operationOriginal.source) ||
            (typeof operationOriginal.destination !== 'string' && typeof operationOriginal.source !== 'string' &&
                operationOriginal.destination.equals(operationOriginal.source))) {
            return Promise.resolve({
                type: 'void',
                execute: () => Promise.resolve(),
            });
        }
        // COPY is equivalent to drop destination, and add
        const operation = this.factory.createCompositeUpdate([
            this.factory.createDrop(operationOriginal.destination, true),
            this.factory.createAdd(operationOriginal.source, operationOriginal.destination, operationOriginal.silent),
        ]);
        return this.mediatorQueryOperation.mediate({ operation, context });
    }
}
exports.ActorQueryOperationCopyRewrite = ActorQueryOperationCopyRewrite;
//# sourceMappingURL=ActorQueryOperationCopyRewrite.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-update-copy-rewrite/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-update-copy-rewrite/lib/ActorQueryOperationCopyRewrite.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-update-create/lib/ActorQueryOperationCreate.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationCreate = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
/**
 * A [Query Operation](https://github.com/comunica/comunica/tree/master/packages/bus-query-operation) actor that
 * handles SPARQL create operations.
 */
class ActorQueryOperationCreate extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'create');
    }
    async testOperation(operation, context) {
        bus_query_operation_1.ActorQueryOperation.throwOnReadOnly(context);
        return true;
    }
    async runOperation(operation, context) {
        // Delegate to update-quads bus
        const { execute } = await this.mediatorUpdateQuads.mediate({
            createGraphs: {
                graphs: [operation.source],
                requireNonExistence: !operation.silent,
            },
            context,
        });
        return {
            type: 'void',
            execute,
        };
    }
}
exports.ActorQueryOperationCreate = ActorQueryOperationCreate;
//# sourceMappingURL=ActorQueryOperationCreate.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-update-create/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-update-create/lib/ActorQueryOperationCreate.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-update-deleteinsert/lib/ActorQueryOperationUpdateDeleteInsert.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationUpdateDeleteInsert = void 0;
const actor_query_operation_construct_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-construct/lib/index.js");
const bindings_factory_1 = __quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/index.js");
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
const BF = new bindings_factory_1.BindingsFactory();
/**
 * A comunica Update DeleteInsert Query Operation Actor.
 */
class ActorQueryOperationUpdateDeleteInsert extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'deleteinsert');
        this.blankNodeCounter = 0;
    }
    async testOperation(operation, context) {
        bus_query_operation_1.ActorQueryOperation.throwOnReadOnly(context);
        return true;
    }
    async runOperation(operation, context) {
        // Evaluate the where clause
        const whereBindings = operation.where ?
            bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation
                .mediate({ operation: operation.where, context })).bindingsStream :
            new asynciterator_1.ArrayIterator([BF.bindings()], { autoStart: false });
        // Construct triples using the result based on the pattern.
        let quadStreamInsert;
        let quadStreamDelete;
        if (operation.insert) {
            // Localize blank nodes in pattern, to avoid clashes across different INSERT/DELETE calls
            quadStreamInsert = new actor_query_operation_construct_1.BindingsToQuadsIterator(operation.insert.map(actor_query_operation_construct_1.BindingsToQuadsIterator.localizeQuad.bind(null, this.blankNodeCounter)), whereBindings.clone(), false);
            this.blankNodeCounter++;
        }
        if (operation.delete) {
            // Localize blank nodes in pattern, to avoid clashes across different INSERT/DELETE calls
            quadStreamDelete = new actor_query_operation_construct_1.BindingsToQuadsIterator(operation.delete.map(actor_query_operation_construct_1.BindingsToQuadsIterator.localizeQuad.bind(null, this.blankNodeCounter)), whereBindings.clone(), false);
            this.blankNodeCounter++;
        }
        // Evaluate the required modifications
        const { execute } = await this.mediatorUpdateQuads.mediate({
            quadStreamInsert,
            quadStreamDelete,
            context,
        });
        return {
            type: 'void',
            execute,
        };
    }
}
exports.ActorQueryOperationUpdateDeleteInsert = ActorQueryOperationUpdateDeleteInsert;
//# sourceMappingURL=ActorQueryOperationUpdateDeleteInsert.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-update-deleteinsert/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-update-deleteinsert/lib/ActorQueryOperationUpdateDeleteInsert.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-update-drop/lib/ActorQueryOperationDrop.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationDrop = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A [Query Operation](https://github.com/comunica/comunica/tree/master/packages/bus-query-operation) actor
 * that handles SPARQL drop operations.
 */
class ActorQueryOperationDrop extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'drop');
    }
    async testOperation(operation, context) {
        bus_query_operation_1.ActorQueryOperation.throwOnReadOnly(context);
        return true;
    }
    async runOperation(operation, context) {
        // Delegate to update-quads bus
        let graphs;
        if (operation.source === 'DEFAULT') {
            graphs = DF.defaultGraph();
        }
        else if (typeof operation.source === 'string') {
            graphs = operation.source;
        }
        else {
            graphs = [operation.source];
        }
        const { execute } = await this.mediatorUpdateQuads.mediate({
            deleteGraphs: {
                graphs,
                requireExistence: !operation.silent,
                dropGraphs: true,
            },
            context,
        });
        return {
            type: 'void',
            execute,
        };
    }
}
exports.ActorQueryOperationDrop = ActorQueryOperationDrop;
//# sourceMappingURL=ActorQueryOperationDrop.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-update-drop/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-update-drop/lib/ActorQueryOperationDrop.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-update-load/lib/ActorQueryOperationLoad.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationLoad = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const context_entries_1 = __quadstore_comunica_require__("../node_modules/@comunica/context-entries/lib/index.js");
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A [Query Operation](https://github.com/comunica/comunica/tree/master/packages/bus-query-operation) actor
 * that handles SPARQL load operations.
 */
class ActorQueryOperationLoad extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'load');
        this.factory = new sparqlalgebrajs_1.Factory();
        this.constructOperation = this.factory.createConstruct(this.factory.createPattern(DF.variable('s'), DF.variable('p'), DF.variable('o')), [this.factory.createPattern(DF.variable('s'), DF.variable('p'), DF.variable('o'))]);
    }
    async testOperation(operation, context) {
        bus_query_operation_1.ActorQueryOperation.throwOnReadOnly(context);
        return true;
    }
    async runOperation(operation, context) {
        // Create CONSTRUCT query on the given source
        let subContext = context.set(context_entries_1.KeysRdfResolveQuadPattern.sources, [operation.source.value]);
        if (operation.silent) {
            subContext = subContext.set(context_entries_1.KeysInitQuery.lenient, true);
        }
        const output = ActorQueryOperationLoad.getSafeQuads(await this.mediatorQueryOperation.mediate({
            operation: this.constructOperation,
            context: subContext,
        }));
        // Determine quad stream to insert
        let quadStream = output.quadStream;
        if (operation.destination) {
            quadStream = quadStream.map(quad => DF.quad(quad.subject, quad.predicate, quad.object, operation.destination));
        }
        // Insert quad stream
        const { execute } = await this.mediatorUpdateQuads.mediate({
            quadStreamInsert: quadStream,
            context,
        });
        return {
            type: 'void',
            execute,
        };
    }
}
exports.ActorQueryOperationLoad = ActorQueryOperationLoad;
//# sourceMappingURL=ActorQueryOperationLoad.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-update-load/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-update-load/lib/ActorQueryOperationLoad.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-update-move-rewrite/lib/ActorQueryOperationMoveRewrite.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationMoveRewrite = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
/**
 * A [Query Operation](https://github.com/comunica/comunica/tree/master/packages/bus-query-operation) actor that
 * handles SPARQL move operations.
 */
class ActorQueryOperationMoveRewrite extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'move');
        this.factory = new sparqlalgebrajs_1.Factory();
    }
    async testOperation(operation, context) {
        bus_query_operation_1.ActorQueryOperation.throwOnReadOnly(context);
        return true;
    }
    runOperation(operationOriginal, context) {
        // No-op if source === destination
        if ((typeof operationOriginal.destination === 'string' && typeof operationOriginal.source === 'string' &&
            operationOriginal.destination === operationOriginal.source) ||
            (typeof operationOriginal.destination !== 'string' && typeof operationOriginal.source !== 'string' &&
                operationOriginal.destination.equals(operationOriginal.source))) {
            return Promise.resolve({
                type: 'void',
                execute: () => Promise.resolve(),
            });
        }
        // MOVE is equivalent to drop destination, add, and drop source
        const updates = [
            this.factory.createDrop(operationOriginal.destination, true),
            this.factory.createAdd(operationOriginal.source, operationOriginal.destination, operationOriginal.silent),
            this.factory.createDrop(operationOriginal.source),
        ];
        const operation = this.factory.createCompositeUpdate(updates);
        return this.mediatorQueryOperation.mediate({ operation, context });
    }
}
exports.ActorQueryOperationMoveRewrite = ActorQueryOperationMoveRewrite;
//# sourceMappingURL=ActorQueryOperationMoveRewrite.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-update-move-rewrite/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-update-move-rewrite/lib/ActorQueryOperationMoveRewrite.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-values/lib/ActorQueryOperationValues.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationValues = void 0;
const bindings_factory_1 = __quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/index.js");
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const BF = new bindings_factory_1.BindingsFactory();
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A comunica Values Query Operation Actor.
 */
class ActorQueryOperationValues extends bus_query_operation_1.ActorQueryOperationTyped {
    constructor(args) {
        super(args, 'values');
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(operation, context) {
        const bindingsStream = new asynciterator_1.ArrayIterator(operation.bindings
            .map(x => BF.bindings(Object.entries(x)
            .map(([key, value]) => [DF.variable(key.slice(1)), value]))));
        const variables = operation.variables;
        const metadata = () => Promise.resolve({
            cardinality: { type: 'exact', value: operation.bindings.length },
            canContainUndefs: operation.bindings.some(bindings => variables.some(variable => !(`?${variable.value}` in bindings))),
            variables,
        });
        return { type: 'bindings', bindingsStream, metadata };
    }
}
exports.ActorQueryOperationValues = ActorQueryOperationValues;
//# sourceMappingURL=ActorQueryOperationValues.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-operation-values/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-values/lib/ActorQueryOperationValues.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-parse-sparql/lib/ActorQueryParseSparql.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryParseSparql = void 0;
const bus_query_parse_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-parse/lib/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
const sparqljs_1 = __quadstore_comunica_require__("sparqljs");
/**
 * A comunica Algebra SPARQL Parse Actor.
 */
class ActorQueryParseSparql extends bus_query_parse_1.ActorQueryParse {
    constructor(args) {
        super(args);
        this.prefixes = Object.freeze(this.prefixes);
    }
    async test(action) {
        if (action.queryFormat && action.queryFormat.language !== 'sparql') {
            throw new Error('This actor can only parse SPARQL queries');
        }
        return true;
    }
    async run(action) {
        const parser = new sparqljs_1.Parser({ prefixes: this.prefixes, baseIRI: action.baseIRI });
        const parsedSyntax = parser.parse(action.query);
        const baseIRI = parsedSyntax.type === 'query' ? parsedSyntax.base : undefined;
        return {
            baseIRI,
            operation: (0, sparqlalgebrajs_1.translate)(parsedSyntax, { quads: true, prefixes: this.prefixes, blankToVariable: true, baseIRI: action.baseIRI }),
        };
    }
}
exports.ActorQueryParseSparql = ActorQueryParseSparql;
//# sourceMappingURL=ActorQueryParseSparql.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-query-parse-sparql/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-query-parse-sparql/lib/ActorQueryParseSparql.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-entries-sort-cardinality/lib/ActorRdfJoinEntriesSortCardinality.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfJoinEntriesSortCardinality = void 0;
const bus_rdf_join_entries_sort_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-join-entries-sort/lib/index.js");
/**
 * An actor that sorts join entries by increasing cardinality.
 */
class ActorRdfJoinEntriesSortCardinality extends bus_rdf_join_entries_sort_1.ActorRdfJoinEntriesSort {
    constructor(args) {
        super(args);
    }
    async test(action) {
        return true;
    }
    async run(action) {
        const entries = [...action.entries]
            .sort((entryLeft, entryRight) => entryLeft.metadata.cardinality.value - entryRight.metadata.cardinality.value);
        return { entries };
    }
}
exports.ActorRdfJoinEntriesSortCardinality = ActorRdfJoinEntriesSortCardinality;
//# sourceMappingURL=ActorRdfJoinEntriesSortCardinality.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-entries-sort-cardinality/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-entries-sort-cardinality/lib/ActorRdfJoinEntriesSortCardinality.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-inner-hash/lib/ActorRdfJoinHash.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfJoinHash = void 0;
const bus_rdf_join_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-join/lib/index.js");
const asyncjoin_1 = __quadstore_comunica_require__("../node_modules/asyncjoin/index.js");
/**
 * A comunica Hash RDF Join Actor.
 */
class ActorRdfJoinHash extends bus_rdf_join_1.ActorRdfJoin {
    constructor(args) {
        super(args, {
            logicalType: 'inner',
            physicalName: 'hash',
            limitEntries: 2,
        });
    }
    async getOutput(action) {
        const metadatas = await bus_rdf_join_1.ActorRdfJoin.getMetadatas(action.entries);
        const variables = bus_rdf_join_1.ActorRdfJoin.overlappingVariables(metadatas);
        const join = new asyncjoin_1.HashJoin(action.entries[0].output.bindingsStream, action.entries[1].output.bindingsStream, entry => bus_rdf_join_1.ActorRdfJoin.hash(entry, variables), bus_rdf_join_1.ActorRdfJoin.joinBindings);
        return {
            result: {
                type: 'bindings',
                bindingsStream: join,
                metadata: async () => await this.constructResultMetadata(action.entries, metadatas, action.context),
            },
        };
    }
    async getJoinCoefficients(action, metadatas) {
        const requestInitialTimes = bus_rdf_join_1.ActorRdfJoin.getRequestInitialTimes(metadatas);
        const requestItemTimes = bus_rdf_join_1.ActorRdfJoin.getRequestItemTimes(metadatas);
        return {
            iterations: metadatas[0].cardinality.value + metadatas[1].cardinality.value,
            persistedItems: metadatas[0].cardinality.value,
            blockingItems: metadatas[0].cardinality.value,
            requestTime: requestInitialTimes[0] + metadatas[0].cardinality.value * requestItemTimes[0] +
                requestInitialTimes[1] + metadatas[1].cardinality.value * requestItemTimes[1],
        };
    }
}
exports.ActorRdfJoinHash = ActorRdfJoinHash;
//# sourceMappingURL=ActorRdfJoinHash.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-inner-hash/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-inner-hash/lib/ActorRdfJoinHash.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-inner-multi-bind/lib/ActorRdfJoinMultiBind.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfJoinMultiBind = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const bus_rdf_join_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-join/lib/index.js");
const context_entries_1 = __quadstore_comunica_require__("../node_modules/@comunica/context-entries/lib/index.js");
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
/**
 * A comunica Multi-way Bind RDF Join Actor.
 */
class ActorRdfJoinMultiBind extends bus_rdf_join_1.ActorRdfJoin {
    constructor(args) {
        super(args, {
            logicalType: 'inner',
            physicalName: 'bind',
            canHandleUndefs: true,
        });
    }
    /**
     * Create a new bindings stream that takes every binding of the base stream
     * and binds it to the remaining patterns, evaluates those patterns, and emits all their bindings.
     *
     * @param bindOrder The order in which elements should be bound.
     * @param baseStream The base stream.
     * @param operations The operations to bind with each binding of the base stream.
     * @param operationBinder A callback to retrieve the bindings stream of bound operations.
     * @param optional If the original bindings should be emitted when the resulting bindings stream is empty.
     * @return {BindingsStream}
     */
    static createBindStream(bindOrder, baseStream, operations, operationBinder, optional) {
        // Create bindings function
        const binder = (bindings) => {
            // We don't bind the filter because filters are always handled last,
            // and we need to avoid binding filters of sub-queries, which are to be handled first. (see spec test bind10)
            const subOperations = operations
                .map(operation => (0, bus_query_operation_1.materializeOperation)(operation, bindings, { bindFilter: false }));
            const bindingsMerger = (subBindings) => subBindings.merge(bindings);
            return new asynciterator_1.TransformIterator(async () => (await operationBinder(subOperations, bindings))
                .transform({ map: bindingsMerger }), { maxBufferSize: 128, autoStart: false });
        };
        // Create an iterator that binds elements from the base stream in different orders
        switch (bindOrder) {
            case 'depth-first':
                return new asynciterator_1.MultiTransformIterator(baseStream, { autoStart: false, multiTransform: binder, optional });
            case 'breadth-first':
                return new asynciterator_1.UnionIterator(baseStream.transform({
                    map: binder,
                    optional,
                }), { autoStart: false });
            default:
                throw new Error(`Received request for unknown bind order: ${bindOrder}`);
        }
    }
    /**
     * Order the given join entries using the join-entries-sort bus.
     * @param {IJoinEntryWithMetadata[]} entries An array of join entries.
     * @param context The action context.
     * @return {IJoinEntryWithMetadata[]} The sorted join entries.
     */
    async sortJoinEntries(entries, context) {
        // If there is a stream that can contain undefs, we don't modify the join order.
        const canContainUndefs = entries.some(entry => entry.metadata.canContainUndefs);
        if (canContainUndefs) {
            return entries;
        }
        // Calculate number of occurrences of each variable
        const variableOccurrences = {};
        for (const entry of entries) {
            for (const variable of entry.metadata.variables) {
                let counter = variableOccurrences[variable.value];
                if (!counter) {
                    counter = 0;
                }
                variableOccurrences[variable.value] = ++counter;
            }
        }
        // Determine variables that occur in at least two join entries
        const multiOccurrenceVariables = [];
        for (const [variable, count] of Object.entries(variableOccurrences)) {
            if (count >= 2) {
                multiOccurrenceVariables.push(variable);
            }
        }
        // Reject if no entries have common variables
        if (multiOccurrenceVariables.length === 0) {
            throw new Error(`Bind join can only join entries with at least one common variable`);
        }
        // Determine entries without common variables
        // These will be placed in the back of the sorted array
        const entriesWithoutCommonVariables = [];
        for (const entry of entries) {
            let hasCommon = false;
            for (const variable of entry.metadata.variables) {
                if (multiOccurrenceVariables.includes(variable.value)) {
                    hasCommon = true;
                    break;
                }
            }
            if (!hasCommon) {
                entriesWithoutCommonVariables.push(entry);
            }
        }
        return (await this.mediatorJoinEntriesSort.mediate({ entries, context })).entries
            .sort((entryLeft, entryRight) => {
            // Sort to make sure that entries without common variables come last in the array.
            // For all other entries, the original order is kept.
            const leftWithoutCommonVariables = entriesWithoutCommonVariables.includes(entryLeft);
            const rightWithoutCommonVariables = entriesWithoutCommonVariables.includes(entryRight);
            if (leftWithoutCommonVariables === rightWithoutCommonVariables) {
                return 0;
            }
            return leftWithoutCommonVariables ?
                1 :
                -1;
        });
    }
    async getOutput(action) {
        // Order the entries so we can pick the first one (usually the one with the lowest cardinality)
        const entriesUnsorted = await bus_rdf_join_1.ActorRdfJoin.getEntriesWithMetadatas(action.entries);
        const entries = await this.sortJoinEntries(entriesUnsorted, action.context);
        this.logDebug(action.context, 'First entry for Bind Join: ', () => ({ entry: entries[0].operation, metadata: entries[0].metadata }));
        // Close the non-smallest streams
        for (const [i, element] of entries.entries()) {
            if (i !== 0) {
                element.output.bindingsStream.close();
            }
        }
        // Take the stream with the lowest cardinality
        const smallestStream = entries[0].output;
        const remainingEntries = [...entries];
        remainingEntries.splice(0, 1);
        // Bind the remaining patterns for each binding in the stream
        const subContext = action.context
            .set(context_entries_1.KeysQueryOperation.joinLeftMetadata, entries[0].metadata)
            .set(context_entries_1.KeysQueryOperation.joinRightMetadatas, remainingEntries.map(entry => entry.metadata));
        const bindingsStream = ActorRdfJoinMultiBind.createBindStream(this.bindOrder, smallestStream.bindingsStream, remainingEntries.map(entry => entry.operation), async (operations, operationBindings) => {
            // Send the materialized patterns to the mediator for recursive join evaluation.
            const operation = operations.length === 1 ?
                operations[0] :
                ActorRdfJoinMultiBind.FACTORY.createJoin(operations);
            const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation, context: subContext?.set(context_entries_1.KeysQueryOperation.joinBindings, operationBindings) }));
            return output.bindingsStream;
        }, false);
        return {
            result: {
                type: 'bindings',
                bindingsStream,
                metadata: () => this.constructResultMetadata(entries, entries.map(entry => entry.metadata), action.context),
            },
            physicalPlanMetadata: {
                bindIndex: entriesUnsorted.indexOf(entries[0]),
                bindOrder: this.bindOrder,
            },
        };
    }
    async getJoinCoefficients(action, metadatas) {
        // Order the entries so we can pick the first one (usually the one with the lowest cardinality)
        const entries = await this.sortJoinEntries(action.entries
            .map((entry, i) => ({ ...entry, metadata: metadatas[i] })), action.context);
        metadatas = entries.map(entry => entry.metadata);
        const requestInitialTimes = bus_rdf_join_1.ActorRdfJoin.getRequestInitialTimes(metadatas);
        const requestItemTimes = bus_rdf_join_1.ActorRdfJoin.getRequestItemTimes(metadatas);
        // Determine first stream and remaining ones
        const remainingEntries = [...entries];
        const remainingRequestInitialTimes = [...requestInitialTimes];
        const remainingRequestItemTimes = [...requestItemTimes];
        remainingEntries.splice(0, 1);
        remainingRequestInitialTimes.splice(0, 1);
        remainingRequestItemTimes.splice(0, 1);
        // Reject binding on some operation types
        if (remainingEntries
            .some(entry => entry.operation.type === sparqlalgebrajs_1.Algebra.types.EXTEND || entry.operation.type === sparqlalgebrajs_1.Algebra.types.GROUP)) {
            throw new Error(`Actor ${this.name} can not bind on Extend and Group operations`);
        }
        // Determine selectivities of smallest entry with all other entries
        const selectivities = await Promise.all(remainingEntries
            .map(async (entry) => (await this.mediatorJoinSelectivity.mediate({
            entries: [entries[0], entry],
            context: action.context,
        })).selectivity * this.selectivityModifier));
        // Determine coefficients for remaining entries
        const cardinalityRemaining = remainingEntries
            .map((entry, i) => entry.metadata.cardinality.value * selectivities[i])
            .reduce((sum, element) => sum + element, 0);
        const receiveInitialCostRemaining = remainingRequestInitialTimes
            .reduce((sum, element, i) => sum + (element * selectivities[i]), 0);
        const receiveItemCostRemaining = remainingRequestItemTimes
            .reduce((sum, element, i) => sum + (element * selectivities[i]), 0);
        return {
            iterations: metadatas[0].cardinality.value * cardinalityRemaining,
            persistedItems: 0,
            blockingItems: 0,
            requestTime: requestInitialTimes[0] +
                metadatas[0].cardinality.value * (requestItemTimes[0] +
                    receiveInitialCostRemaining +
                    cardinalityRemaining * receiveItemCostRemaining),
        };
    }
}
exports.ActorRdfJoinMultiBind = ActorRdfJoinMultiBind;
ActorRdfJoinMultiBind.FACTORY = new sparqlalgebrajs_1.Factory();
//# sourceMappingURL=ActorRdfJoinMultiBind.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-inner-multi-bind/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-inner-multi-bind/lib/ActorRdfJoinMultiBind.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-inner-multi-empty/lib/ActorRdfJoinMultiEmpty.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfJoinMultiEmpty = void 0;
const bus_rdf_join_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-join/lib/index.js");
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
/**
 * A comunica Multi Empty RDF Join Actor.
 */
class ActorRdfJoinMultiEmpty extends bus_rdf_join_1.ActorRdfJoin {
    constructor(args) {
        super(args, {
            logicalType: 'inner',
            physicalName: 'multi-empty',
        });
    }
    async test(action) {
        if ((await bus_rdf_join_1.ActorRdfJoin.getMetadatas(action.entries))
            .every(metadata => bus_rdf_join_1.ActorRdfJoin.getCardinality(metadata).value > 0)) {
            throw new Error(`Actor ${this.name} can only join entries where at least one is empty`);
        }
        return super.test(action);
    }
    async getOutput(action) {
        // Close all entries
        for (const entry of action.entries) {
            entry.output.bindingsStream.close();
        }
        return {
            result: {
                bindingsStream: new asynciterator_1.ArrayIterator([], { autoStart: false }),
                metadata: async () => ({
                    cardinality: { type: 'exact', value: 0 },
                    canContainUndefs: false,
                    variables: bus_rdf_join_1.ActorRdfJoin.joinVariables(await bus_rdf_join_1.ActorRdfJoin.getMetadatas(action.entries)),
                }),
                type: 'bindings',
            },
        };
    }
    async getJoinCoefficients(action, metadatas) {
        return {
            iterations: 0,
            persistedItems: 0,
            blockingItems: 0,
            requestTime: 0,
        };
    }
}
exports.ActorRdfJoinMultiEmpty = ActorRdfJoinMultiEmpty;
//# sourceMappingURL=ActorRdfJoinMultiEmpty.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-inner-multi-empty/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-inner-multi-empty/lib/ActorRdfJoinMultiEmpty.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-inner-multi-smallest/lib/ActorRdfJoinMultiSmallest.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfJoinMultiSmallest = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const bus_rdf_join_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-join/lib/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
/**
 * A Multi Smallest RDF Join Actor.
 * It accepts 3 or more streams, joins the smallest two, and joins the result with the remaining streams.
 */
class ActorRdfJoinMultiSmallest extends bus_rdf_join_1.ActorRdfJoin {
    constructor(args) {
        super(args, {
            logicalType: 'inner',
            physicalName: 'multi-smallest',
            limitEntries: 3,
            limitEntriesMin: true,
        });
    }
    /**
     * Order the given join entries using the join-entries-sort bus.
     * @param {IJoinEntryWithMetadata[]} entries An array of join entries.
     * @param context The action context.
     * @return {IJoinEntryWithMetadata[]} The sorted join entries.
     */
    async sortJoinEntries(entries, context) {
        return (await this.mediatorJoinEntriesSort.mediate({ entries, context })).entries;
    }
    async getOutput(action) {
        // Determine the two smallest streams by sorting (e.g. via cardinality)
        const entries = await this.sortJoinEntries(await bus_rdf_join_1.ActorRdfJoin.getEntriesWithMetadatas([...action.entries]), action.context);
        const smallestEntry1 = entries[0];
        const smallestEntry2 = entries[1];
        entries.splice(0, 2);
        // Join the two selected streams, and then join the result with the remaining streams
        const firstEntry = {
            output: bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorJoin
                .mediate({ type: action.type, entries: [smallestEntry1, smallestEntry2], context: action.context })),
            operation: ActorRdfJoinMultiSmallest.FACTORY
                .createJoin([smallestEntry1.operation, smallestEntry2.operation], false),
        };
        entries.push(firstEntry);
        return {
            result: await this.mediatorJoin.mediate({
                type: action.type,
                entries,
                context: action.context,
            }),
        };
    }
    async getJoinCoefficients(action, metadatas) {
        metadatas = [...metadatas];
        // Determine the two smallest streams by sorting (e.g. via cardinality)
        const entriesWithMetadata = await this.sortJoinEntries(action.entries
            .map((entry, i) => ({ ...entry, metadata: metadatas[i] })), action.context);
        metadatas = entriesWithMetadata.map(entry => entry.metadata);
        const requestInitialTimes = bus_rdf_join_1.ActorRdfJoin.getRequestInitialTimes(metadatas);
        const requestItemTimes = bus_rdf_join_1.ActorRdfJoin.getRequestItemTimes(metadatas);
        return {
            iterations: metadatas[0].cardinality.value * metadatas[1].cardinality.value *
                metadatas.slice(2).reduce((acc, metadata) => acc * metadata.cardinality.value, 1),
            persistedItems: 0,
            blockingItems: 0,
            requestTime: requestInitialTimes[0] + metadatas[0].cardinality.value * requestItemTimes[0] +
                requestInitialTimes[1] + metadatas[1].cardinality.value * requestItemTimes[1] +
                metadatas.slice(2).reduce((sum, metadata, i) => sum + requestInitialTimes.slice(2)[i] +
                    metadata.cardinality.value * requestItemTimes.slice(2)[i], 0),
        };
    }
}
exports.ActorRdfJoinMultiSmallest = ActorRdfJoinMultiSmallest;
ActorRdfJoinMultiSmallest.FACTORY = new sparqlalgebrajs_1.Factory();
//# sourceMappingURL=ActorRdfJoinMultiSmallest.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-inner-multi-smallest/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-inner-multi-smallest/lib/ActorRdfJoinMultiSmallest.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-inner-nestedloop/lib/ActorRdfJoinNestedLoop.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfJoinNestedLoop = void 0;
const bus_rdf_join_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-join/lib/index.js");
const asyncjoin_1 = __quadstore_comunica_require__("../node_modules/asyncjoin/index.js");
/**
 * A comunica NestedLoop RDF Join Actor.
 */
class ActorRdfJoinNestedLoop extends bus_rdf_join_1.ActorRdfJoin {
    constructor(args) {
        super(args, {
            logicalType: 'inner',
            physicalName: 'nested-loop',
            limitEntries: 2,
            canHandleUndefs: true,
        });
    }
    async getOutput(action) {
        const join = new asyncjoin_1.NestedLoopJoin(action.entries[0].output.bindingsStream, action.entries[1].output.bindingsStream, bus_rdf_join_1.ActorRdfJoin.joinBindings, { autoStart: false });
        return {
            result: {
                type: 'bindings',
                bindingsStream: join,
                metadata: async () => await this.constructResultMetadata(action.entries, await bus_rdf_join_1.ActorRdfJoin.getMetadatas(action.entries), action.context),
            },
        };
    }
    async getJoinCoefficients(action, metadatas) {
        const requestInitialTimes = bus_rdf_join_1.ActorRdfJoin.getRequestInitialTimes(metadatas);
        const requestItemTimes = bus_rdf_join_1.ActorRdfJoin.getRequestItemTimes(metadatas);
        return {
            iterations: metadatas[0].cardinality.value * metadatas[1].cardinality.value,
            persistedItems: 0,
            blockingItems: 0,
            requestTime: requestInitialTimes[0] + metadatas[0].cardinality.value * requestItemTimes[0] +
                requestInitialTimes[1] + metadatas[1].cardinality.value * requestItemTimes[1],
        };
    }
}
exports.ActorRdfJoinNestedLoop = ActorRdfJoinNestedLoop;
//# sourceMappingURL=ActorRdfJoinNestedLoop.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-inner-nestedloop/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-inner-nestedloop/lib/ActorRdfJoinNestedLoop.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-inner-none/lib/ActorRdfJoinNone.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfJoinNone = void 0;
const bindings_factory_1 = __quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/index.js");
const bus_rdf_join_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-join/lib/index.js");
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
const BF = new bindings_factory_1.BindingsFactory();
/**
 * A comunica None RDF Join Actor.
 */
class ActorRdfJoinNone extends bus_rdf_join_1.ActorRdfJoin {
    constructor(args) {
        super(args, {
            logicalType: 'inner',
            physicalName: 'none',
            limitEntries: 0,
        });
    }
    async test(action) {
        // Allow joining of one or zero streams
        if (action.entries.length > 0) {
            throw new Error(`Actor ${this.name} can only join zero entries`);
        }
        return await this.getJoinCoefficients();
    }
    async getOutput(action) {
        return {
            result: {
                bindingsStream: new asynciterator_1.ArrayIterator([BF.bindings()], { autoStart: false }),
                metadata: () => Promise.resolve({
                    cardinality: { type: 'exact', value: 1 },
                    canContainUndefs: false,
                    variables: [],
                }),
                type: 'bindings',
            },
        };
    }
    async getJoinCoefficients() {
        return {
            iterations: 0,
            persistedItems: 0,
            blockingItems: 0,
            requestTime: 0,
        };
    }
}
exports.ActorRdfJoinNone = ActorRdfJoinNone;
//# sourceMappingURL=ActorRdfJoinNone.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-inner-none/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-inner-none/lib/ActorRdfJoinNone.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-inner-single/lib/ActorRdfJoinSingle.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfJoinSingle = void 0;
const bus_rdf_join_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-join/lib/index.js");
/**
 * A comunica Single RDF Join Actor.
 */
class ActorRdfJoinSingle extends bus_rdf_join_1.ActorRdfJoin {
    constructor(args) {
        super(args, {
            logicalType: 'inner',
            physicalName: 'single',
            limitEntries: 1,
        });
        this.includeInLogs = false;
    }
    async test(action) {
        // Allow joining of one or zero streams
        if (action.entries.length !== 1) {
            throw new Error(`Actor ${this.name} can only join a single entry`);
        }
        return await this.getJoinCoefficients();
    }
    async getOutput(action) {
        return {
            result: action.entries[0].output,
        };
    }
    async getJoinCoefficients() {
        return {
            iterations: 0,
            persistedItems: 0,
            blockingItems: 0,
            requestTime: 0,
        };
    }
}
exports.ActorRdfJoinSingle = ActorRdfJoinSingle;
//# sourceMappingURL=ActorRdfJoinSingle.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-inner-single/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-inner-single/lib/ActorRdfJoinSingle.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-inner-symmetrichash/lib/ActorRdfJoinSymmetricHash.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfJoinSymmetricHash = void 0;
const bus_rdf_join_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-join/lib/index.js");
const asyncjoin_1 = __quadstore_comunica_require__("../node_modules/asyncjoin/index.js");
/**
 * A comunica Hash RDF Join Actor.
 */
class ActorRdfJoinSymmetricHash extends bus_rdf_join_1.ActorRdfJoin {
    constructor(args) {
        super(args, {
            logicalType: 'inner',
            physicalName: 'symmetric-hash',
            limitEntries: 2,
        });
    }
    async getOutput(action) {
        const metadatas = await bus_rdf_join_1.ActorRdfJoin.getMetadatas(action.entries);
        const variables = bus_rdf_join_1.ActorRdfJoin.overlappingVariables(metadatas);
        const join = new asyncjoin_1.SymmetricHashJoin(action.entries[0].output.bindingsStream, action.entries[1].output.bindingsStream, entry => ActorRdfJoinSymmetricHash.hash(entry, variables), bus_rdf_join_1.ActorRdfJoin.joinBindings);
        return {
            result: {
                type: 'bindings',
                bindingsStream: join,
                metadata: async () => await this.constructResultMetadata(action.entries, metadatas, action.context),
            },
        };
    }
    async getJoinCoefficients(action, metadatas) {
        const requestInitialTimes = bus_rdf_join_1.ActorRdfJoin.getRequestInitialTimes(metadatas);
        const requestItemTimes = bus_rdf_join_1.ActorRdfJoin.getRequestItemTimes(metadatas);
        return {
            iterations: metadatas[0].cardinality.value + metadatas[1].cardinality.value,
            persistedItems: metadatas[0].cardinality.value + metadatas[1].cardinality.value,
            blockingItems: 0,
            requestTime: requestInitialTimes[0] + metadatas[0].cardinality.value * requestItemTimes[0] +
                requestInitialTimes[1] + metadatas[1].cardinality.value * requestItemTimes[1],
        };
    }
}
exports.ActorRdfJoinSymmetricHash = ActorRdfJoinSymmetricHash;
//# sourceMappingURL=ActorRdfJoinSymmetricHash.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-inner-symmetrichash/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-inner-symmetrichash/lib/ActorRdfJoinSymmetricHash.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-minus-hash-undef/lib/ActorRdfJoinMinusHashUndef.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfJoinMinusHashUndef = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const bus_rdf_join_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-join/lib/index.js");
const BindingsIndex_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-minus-hash-undef/lib/BindingsIndex.js");
/**
 * A comunica Minus Hash RDF Join Actor.
 */
class ActorRdfJoinMinusHashUndef extends bus_rdf_join_1.ActorRdfJoin {
    constructor(args) {
        super(args, {
            logicalType: 'minus',
            physicalName: 'hash-undef',
            limitEntries: 2,
            canHandleUndefs: true,
        });
    }
    async getOutput(action) {
        const buffer = action.entries[1].output;
        const output = action.entries[0].output;
        const metadatas = await bus_rdf_join_1.ActorRdfJoin.getMetadatas(action.entries);
        const commonVariables = bus_rdf_join_1.ActorRdfJoin.overlappingVariables(metadatas);
        if (commonVariables.length > 0) {
            /**
             * To assure we've filtered all B (`buffer`) values from A (`output`) we wait until we've fetched all values of B.
             * Then we save these triples in `index` and use it to filter our A-stream.
             */
            const index = new BindingsIndex_1.BindingsIndex(commonVariables);
            const bindingsStream = new bus_query_operation_1.ClosableTransformIterator(async () => {
                await new Promise(resolve => {
                    buffer.bindingsStream.on('data', data => index.add(data));
                    buffer.bindingsStream.on('end', resolve);
                });
                return output.bindingsStream.filter(data => !index.contains(data));
            }, {
                autoStart: false,
                onClose() {
                    buffer.bindingsStream.destroy();
                    output.bindingsStream.destroy();
                },
            });
            return {
                result: {
                    type: 'bindings',
                    bindingsStream,
                    async metadata() {
                        const bufferMetadata = await output.metadata();
                        const outputMetadata = await output.metadata();
                        return {
                            ...outputMetadata,
                            canContainUndefs: bufferMetadata.canContainUndefs || outputMetadata.canContainUndefs,
                        };
                    },
                },
            };
        }
        return {
            result: output,
        };
    }
    async getJoinCoefficients(action, metadatas) {
        const requestInitialTimes = bus_rdf_join_1.ActorRdfJoin.getRequestInitialTimes(metadatas);
        const requestItemTimes = bus_rdf_join_1.ActorRdfJoin.getRequestItemTimes(metadatas);
        return {
            // Slightly increase iteration cost, as operations in our BindingsIndex do not happen in constant time
            // This enables the mediator to favor other minus actors,
            // while this one will only be selected when streams contain undefs.
            iterations: (metadatas[0].cardinality.value + metadatas[1].cardinality.value) * 1.01,
            persistedItems: metadatas[0].cardinality.value,
            blockingItems: metadatas[0].cardinality.value,
            requestTime: requestInitialTimes[0] + metadatas[0].cardinality.value * requestItemTimes[0] +
                requestInitialTimes[1] + metadatas[1].cardinality.value * requestItemTimes[1],
        };
    }
}
exports.ActorRdfJoinMinusHashUndef = ActorRdfJoinMinusHashUndef;
//# sourceMappingURL=ActorRdfJoinMinusHashUndef.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-minus-hash-undef/lib/BindingsIndex.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BindingsIndex = void 0;
const rdf_string_1 = __quadstore_comunica_require__("../node_modules/rdf-string/index.js");
/**
 * A simple efficient tree-based index for maintaining bindings,
 * and checking whether or not a bindings is contained in this index.
 *
 * This will consider bindings with a variable term or a missing term
 * as a 'match-all' with other terms.
 */
class BindingsIndex {
    constructor(keys) {
        this.data = {};
        this.keys = keys;
    }
    static hashTerm(term) {
        return term && term.termType !== 'Variable' ? (0, rdf_string_1.termToString)(term) : '';
    }
    /**
     * Add the given bindings to the index.
     * @param {Bindings} bindings A bindings.
     */
    add(bindings) {
        if (this.isBindingsValid(bindings)) {
            let dataIt = this.data;
            for (const key of this.keys) {
                const dataKey = BindingsIndex.hashTerm(bindings.get(key));
                let subDataIt = dataIt[dataKey];
                if (!subDataIt) {
                    subDataIt = dataIt[dataKey] = {};
                }
                dataIt = subDataIt;
            }
        }
    }
    /**
     * Check if the given bindings is contained in this index.
     * @param {Bindings} bindings A bindings.
     * @return {boolean} If it exists in the index.
     */
    contains(bindings) {
        // Always return false if the bindings contain none of the expected keys
        if (!this.isBindingsValid(bindings)) {
            return false;
        }
        return this.containsRecursive(bindings, this.keys, [this.data]);
    }
    isBindingsValid(bindings) {
        let validKeys = false;
        for (const key of this.keys) {
            if (bindings.get(key)) {
                validKeys = true;
                break;
            }
        }
        return validKeys;
    }
    containsRecursive(bindings, keys, dataIndexes) {
        if (keys.length === 0) {
            return true;
        }
        let key;
        // eslint-disable-next-line prefer-const
        [key, ...keys] = keys;
        for (const data of dataIndexes) {
            // If the index contained a variable, all terms will match.
            const dataKey = BindingsIndex.hashTerm(bindings.get(key));
            if (!dataKey) {
                // Iterate over all entries
                let subDatas = Object.keys(data).map(subKey => data[subKey]);
                if (subDatas.length === 0) {
                    subDatas = [{}];
                }
                if (this.containsRecursive(bindings, keys, subDatas)) {
                    return true;
                }
            }
            else {
                // Check the entry for the term, and the variable term.
                const subDatas = [data[dataKey], data['']].filter(Boolean);
                if (subDatas.length === 0) {
                    continue;
                }
                if (this.containsRecursive(bindings, keys, subDatas)) {
                    return true;
                }
            }
        }
        return false;
    }
}
exports.BindingsIndex = BindingsIndex;
//# sourceMappingURL=BindingsIndex.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-minus-hash-undef/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-minus-hash-undef/lib/ActorRdfJoinMinusHashUndef.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-minus-hash/lib/ActorRdfJoinMinusHash.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfJoinMinusHash = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const bus_rdf_join_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-join/lib/index.js");
/**
 * A comunica Minus Hash RDF Join Actor.
 */
class ActorRdfJoinMinusHash extends bus_rdf_join_1.ActorRdfJoin {
    constructor(args) {
        super(args, {
            logicalType: 'minus',
            physicalName: 'hash',
            limitEntries: 2,
        });
    }
    async getOutput(action) {
        const buffer = action.entries[1].output;
        const output = action.entries[0].output;
        const metadatas = await bus_rdf_join_1.ActorRdfJoin.getMetadatas(action.entries);
        const commonVariables = bus_rdf_join_1.ActorRdfJoin.overlappingVariables(metadatas);
        if (commonVariables.length > 0) {
            /**
             * To assure we've filtered all B (`buffer`) values from A (`output`) we wait until we've fetched all values of B.
             * Then we save these triples in `index` and use it to filter our A-stream.
             */
            const index = {};
            const bindingsStream = new bus_query_operation_1.ClosableTransformIterator(async () => {
                await new Promise(resolve => {
                    buffer.bindingsStream.on('data', data => {
                        index[bus_rdf_join_1.ActorRdfJoin.hash(data, commonVariables)] = true;
                    });
                    buffer.bindingsStream.on('end', resolve);
                });
                return output.bindingsStream.filter(data => !index[bus_rdf_join_1.ActorRdfJoin.hash(data, commonVariables)]);
            }, {
                autoStart: false,
                onClose() {
                    buffer.bindingsStream.destroy();
                    output.bindingsStream.destroy();
                },
            });
            return {
                result: {
                    type: 'bindings',
                    bindingsStream,
                    metadata: output.metadata,
                },
            };
        }
        return {
            result: output,
        };
    }
    async getJoinCoefficients(action, metadatas) {
        const requestInitialTimes = bus_rdf_join_1.ActorRdfJoin.getRequestInitialTimes(metadatas);
        const requestItemTimes = bus_rdf_join_1.ActorRdfJoin.getRequestItemTimes(metadatas);
        return {
            iterations: metadatas[0].cardinality.value + metadatas[1].cardinality.value,
            persistedItems: metadatas[0].cardinality.value,
            blockingItems: metadatas[0].cardinality.value,
            requestTime: requestInitialTimes[0] + metadatas[0].cardinality.value * requestItemTimes[0] +
                requestInitialTimes[1] + metadatas[1].cardinality.value * requestItemTimes[1],
        };
    }
}
exports.ActorRdfJoinMinusHash = ActorRdfJoinMinusHash;
//# sourceMappingURL=ActorRdfJoinMinusHash.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-minus-hash/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-minus-hash/lib/ActorRdfJoinMinusHash.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-optional-bind/lib/ActorRdfJoinOptionalBind.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfJoinOptionalBind = void 0;
const actor_rdf_join_inner_multi_bind_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-inner-multi-bind/lib/index.js");
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const bus_rdf_join_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-join/lib/index.js");
const context_entries_1 = __quadstore_comunica_require__("../node_modules/@comunica/context-entries/lib/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
/**
 * A comunica Optional Bind RDF Join Actor.
 */
class ActorRdfJoinOptionalBind extends bus_rdf_join_1.ActorRdfJoin {
    constructor(args) {
        super(args, {
            logicalType: 'optional',
            physicalName: 'bind',
            limitEntries: 2,
            canHandleUndefs: true,
        });
    }
    async getOutput(action) {
        // Close the right stream, since we don't need that one
        action.entries[1].output.bindingsStream.close();
        // Bind the right pattern for each binding in the stream
        const subContext = action.context
            .set(context_entries_1.KeysQueryOperation.joinLeftMetadata, await action.entries[0].output.metadata())
            .set(context_entries_1.KeysQueryOperation.joinRightMetadatas, [await action.entries[1].output.metadata()]);
        const bindingsStream = actor_rdf_join_inner_multi_bind_1.ActorRdfJoinMultiBind.createBindStream(this.bindOrder, action.entries[0].output.bindingsStream, [action.entries[1].operation], async (operations, operationBindings) => {
            // Send the materialized patterns to the mediator for recursive join evaluation.
            // Length of operations will always be 1
            const operation = operations[0];
            const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation, context: subContext?.set(context_entries_1.KeysQueryOperation.joinBindings, operationBindings) }));
            return output.bindingsStream;
        }, true);
        return {
            result: {
                type: 'bindings',
                bindingsStream,
                metadata: async () => await this.constructResultMetadata(action.entries, await bus_rdf_join_1.ActorRdfJoin.getMetadatas(action.entries), action.context, { canContainUndefs: true }),
            },
        };
    }
    async getJoinCoefficients(action, metadatas) {
        const requestInitialTimes = bus_rdf_join_1.ActorRdfJoin.getRequestInitialTimes(metadatas);
        const requestItemTimes = bus_rdf_join_1.ActorRdfJoin.getRequestItemTimes(metadatas);
        // Reject binding on some operation types
        if (action.entries[1].operation.type === sparqlalgebrajs_1.Algebra.types.EXTEND ||
            action.entries[1].operation.type === sparqlalgebrajs_1.Algebra.types.GROUP) {
            throw new Error(`Actor ${this.name} can not bind on Extend and Group operations`);
        }
        // Determine selectivity of join
        const selectivity = (await this.mediatorJoinSelectivity.mediate({
            entries: action.entries,
            context: action.context,
        })).selectivity * this.selectivityModifier;
        return {
            iterations: metadatas[0].cardinality.value * metadatas[1].cardinality.value * selectivity,
            persistedItems: 0,
            blockingItems: 0,
            requestTime: requestInitialTimes[0] +
                metadatas[0].cardinality.value * selectivity * (requestItemTimes[0] +
                    requestInitialTimes[1] +
                    metadatas[1].cardinality.value * requestItemTimes[1]),
        };
    }
}
exports.ActorRdfJoinOptionalBind = ActorRdfJoinOptionalBind;
//# sourceMappingURL=ActorRdfJoinOptionalBind.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-optional-bind/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-optional-bind/lib/ActorRdfJoinOptionalBind.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-optional-nestedloop/lib/ActorRdfJoinOptionalNestedLoop.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfJoinOptionalNestedLoop = void 0;
const bus_rdf_join_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-join/lib/index.js");
const asyncjoin_1 = __quadstore_comunica_require__("../node_modules/asyncjoin/index.js");
/**
 * A comunica Optional Nested Loop RDF Join Actor.
 */
class ActorRdfJoinOptionalNestedLoop extends bus_rdf_join_1.ActorRdfJoin {
    constructor(args) {
        super(args, {
            logicalType: 'optional',
            physicalName: 'nested-loop',
            limitEntries: 2,
            canHandleUndefs: true,
        });
    }
    async getOutput(action) {
        const join = new asyncjoin_1.NestedLoopJoin(action.entries[0].output.bindingsStream, action.entries[1].output.bindingsStream, bus_rdf_join_1.ActorRdfJoin.joinBindings, { optional: true, autoStart: false });
        return {
            result: {
                type: 'bindings',
                bindingsStream: join,
                metadata: async () => await this.constructResultMetadata(action.entries, await bus_rdf_join_1.ActorRdfJoin.getMetadatas(action.entries), action.context, { canContainUndefs: true }),
            },
        };
    }
    async getJoinCoefficients(action, metadatas) {
        const requestInitialTimes = bus_rdf_join_1.ActorRdfJoin.getRequestInitialTimes(metadatas);
        const requestItemTimes = bus_rdf_join_1.ActorRdfJoin.getRequestItemTimes(metadatas);
        return {
            iterations: metadatas[0].cardinality.value * metadatas[1].cardinality.value,
            persistedItems: 0,
            blockingItems: 0,
            requestTime: requestInitialTimes[0] + metadatas[0].cardinality.value * requestItemTimes[0] +
                requestInitialTimes[1] + metadatas[1].cardinality.value * requestItemTimes[1],
        };
    }
}
exports.ActorRdfJoinOptionalNestedLoop = ActorRdfJoinOptionalNestedLoop;
//# sourceMappingURL=ActorRdfJoinOptionalNestedLoop.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-optional-nestedloop/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-optional-nestedloop/lib/ActorRdfJoinOptionalNestedLoop.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-selectivity-variable-counting/lib/ActorRdfJoinSelectivityVariableCounting.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JoinTypes = exports.ActorRdfJoinSelectivityVariableCounting = void 0;
const bus_rdf_join_selectivity_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-join-selectivity/lib/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
/**
 * A comunica Variable Counting RDF Join Selectivity Actor.
 * Based on the "variable counting predicates" heuristic from
 * "SPARQL basic graph pattern optimization using selectivity estimation."
 */
class ActorRdfJoinSelectivityVariableCounting extends bus_rdf_join_selectivity_1.ActorRdfJoinSelectivity {
    constructor(args) {
        super(args);
    }
    async test(action) {
        return { accuracy: 0.5 };
    }
    static getPatternCost(pattern) {
        let cost = 1;
        if (pattern.subject.termType === 'Variable') {
            cost += 4;
        }
        if (pattern.predicate.termType === 'Variable' || pattern.type === sparqlalgebrajs_1.Algebra.types.PATH) {
            cost += 1;
        }
        if (pattern.object.termType === 'Variable') {
            cost += 2;
        }
        if (pattern.graph.termType === 'Variable') {
            cost += 1;
        }
        return cost / 9;
    }
    static getJoinTypes(operation1, operation2) {
        const joinTypes = [];
        // Check operation1.subject
        if (operation1.subject.termType === 'Variable') {
            if (operation1.subject.equals(operation2.subject)) {
                joinTypes.push(JoinTypes.unboundSS);
            }
            if (operation2.type === 'pattern' && operation1.subject.equals(operation2.predicate)) {
                joinTypes.push(JoinTypes.unboundSP);
            }
            if (operation1.subject.equals(operation2.object)) {
                joinTypes.push(JoinTypes.unboundSO);
            }
            if (operation1.subject.equals(operation2.graph)) {
                joinTypes.push(JoinTypes.unboundSG);
            }
        }
        else {
            if (operation1.subject.equals(operation2.subject)) {
                joinTypes.push(JoinTypes.boundSS);
            }
            if (operation2.type === 'pattern' && operation1.subject.equals(operation2.predicate)) {
                joinTypes.push(JoinTypes.boundSP);
            }
            if (operation1.subject.equals(operation2.object)) {
                joinTypes.push(JoinTypes.boundSO);
            }
            if (operation1.subject.equals(operation2.graph)) {
                joinTypes.push(JoinTypes.boundSG);
            }
        }
        // Check operation1.predicate
        if (operation1.type === 'pattern') {
            if (operation1.predicate.termType === 'Variable') {
                if (operation1.predicate.equals(operation2.subject)) {
                    joinTypes.push(JoinTypes.unboundPS);
                }
                if (operation2.type === 'pattern' && operation1.predicate.equals(operation2.predicate)) {
                    joinTypes.push(JoinTypes.unboundPP);
                }
                if (operation1.predicate.equals(operation2.object)) {
                    joinTypes.push(JoinTypes.unboundPO);
                }
                if (operation1.predicate.equals(operation2.graph)) {
                    joinTypes.push(JoinTypes.unboundPG);
                }
            }
            else {
                if (operation1.predicate.equals(operation2.subject)) {
                    joinTypes.push(JoinTypes.boundPS);
                }
                if (operation2.type === 'pattern' && operation1.predicate.equals(operation2.predicate)) {
                    joinTypes.push(JoinTypes.boundPP);
                }
                if (operation1.predicate.equals(operation2.object)) {
                    joinTypes.push(JoinTypes.boundPO);
                }
                if (operation1.predicate.equals(operation2.graph)) {
                    joinTypes.push(JoinTypes.boundPG);
                }
            }
        }
        // Check operation1.object
        if (operation1.object.termType === 'Variable') {
            if (operation1.object.equals(operation2.subject)) {
                joinTypes.push(JoinTypes.unboundOS);
            }
            if (operation2.type === 'pattern' && operation1.object.equals(operation2.predicate)) {
                joinTypes.push(JoinTypes.unboundOP);
            }
            if (operation1.object.equals(operation2.object)) {
                joinTypes.push(JoinTypes.unboundOO);
            }
            if (operation1.object.equals(operation2.graph)) {
                joinTypes.push(JoinTypes.unboundOG);
            }
        }
        else {
            if (operation1.object.equals(operation2.subject)) {
                joinTypes.push(JoinTypes.boundOS);
            }
            if (operation2.type === 'pattern' && operation1.object.equals(operation2.predicate)) {
                joinTypes.push(JoinTypes.boundOP);
            }
            if (operation1.object.equals(operation2.object)) {
                joinTypes.push(JoinTypes.boundOO);
            }
            if (operation1.object.equals(operation2.graph)) {
                joinTypes.push(JoinTypes.boundOG);
            }
        }
        // Check operation1.graph
        if (operation1.graph.termType === 'Variable') {
            if (operation1.graph.equals(operation2.subject)) {
                joinTypes.push(JoinTypes.unboundGS);
            }
            if (operation2.type === 'pattern' && operation1.graph.equals(operation2.predicate)) {
                joinTypes.push(JoinTypes.unboundGP);
            }
            if (operation1.graph.equals(operation2.object)) {
                joinTypes.push(JoinTypes.unboundGO);
            }
            if (operation1.graph.equals(operation2.graph)) {
                joinTypes.push(JoinTypes.unboundGG);
            }
        }
        else {
            if (operation1.graph.equals(operation2.subject)) {
                joinTypes.push(JoinTypes.boundGS);
            }
            if (operation2.type === 'pattern' && operation1.graph.equals(operation2.predicate)) {
                joinTypes.push(JoinTypes.boundGP);
            }
            if (operation1.graph.equals(operation2.object)) {
                joinTypes.push(JoinTypes.boundGO);
            }
            if (operation1.graph.equals(operation2.graph)) {
                joinTypes.push(JoinTypes.boundGG);
            }
        }
        return joinTypes;
    }
    static getOperationsPairwiseJoinCost(operation1, operation2) {
        let cost = ActorRdfJoinSelectivityVariableCounting.MAX_PAIRWISE_COST;
        for (const joinType of ActorRdfJoinSelectivityVariableCounting.getJoinTypes(operation1, operation2)) {
            switch (joinType) {
                case JoinTypes.boundSS:
                    cost -= 2 * 2;
                    break;
                case JoinTypes.boundSP:
                    cost -= 3 * 2;
                    break;
                case JoinTypes.boundSO:
                    cost -= 1 * 2;
                    break;
                case JoinTypes.boundSG:
                    cost -= 3 * 2;
                    break;
                case JoinTypes.boundPS:
                    cost -= 3 * 2;
                    break;
                case JoinTypes.boundPP:
                    // Special case: patterns with equal (bound) predicates have the highest cost
                    return 1;
                case JoinTypes.boundPO:
                    cost -= 3 * 2;
                    break;
                case JoinTypes.boundPG:
                    cost -= 3 * 2;
                    break;
                case JoinTypes.boundOS:
                    cost -= 1 * 2;
                    break;
                case JoinTypes.boundOP:
                    cost -= 3 * 2;
                    break;
                case JoinTypes.boundOO:
                    cost -= 1 * 2;
                    break;
                case JoinTypes.boundOG:
                    cost -= 3 * 2;
                    break;
                case JoinTypes.boundGS:
                    cost -= 3 * 2;
                    break;
                case JoinTypes.boundGP:
                    cost -= 3 * 2;
                    break;
                case JoinTypes.boundGO:
                    cost -= 3 * 2;
                    break;
                case JoinTypes.boundGG:
                    cost -= 3 * 2;
                    break;
                case JoinTypes.unboundSS:
                    cost -= 2;
                    break;
                case JoinTypes.unboundSP:
                    cost -= 3;
                    break;
                case JoinTypes.unboundSO:
                    cost -= 1;
                    break;
                case JoinTypes.unboundSG:
                    cost -= 3;
                    break;
                case JoinTypes.unboundPS:
                    cost -= 3;
                    break;
                case JoinTypes.unboundPP:
                    cost -= 3;
                    break;
                case JoinTypes.unboundPO:
                    cost -= 3;
                    break;
                case JoinTypes.unboundPG:
                    cost -= 3;
                    break;
                case JoinTypes.unboundOS:
                    cost -= 1;
                    break;
                case JoinTypes.unboundOP:
                    cost -= 3;
                    break;
                case JoinTypes.unboundOO:
                    cost -= 1;
                    break;
                case JoinTypes.unboundOG:
                    cost -= 3;
                    break;
                case JoinTypes.unboundGS:
                    cost -= 3;
                    break;
                case JoinTypes.unboundGP:
                    cost -= 3;
                    break;
                case JoinTypes.unboundGO:
                    cost -= 3;
                    break;
                case JoinTypes.unboundGG:
                    cost -= 3;
                    break;
            }
        }
        return cost / ActorRdfJoinSelectivityVariableCounting.MAX_PAIRWISE_COST;
    }
    static getOperationsJoinCost(operations) {
        // Determine all operations that select values (patterns and paths)
        const patterns = [];
        for (const operation of operations) {
            sparqlalgebrajs_1.Util.recurseOperation(operation, {
                [sparqlalgebrajs_1.Algebra.types.PATTERN](pattern) {
                    patterns.push(pattern);
                    return false;
                },
                [sparqlalgebrajs_1.Algebra.types.PATH](path) {
                    patterns.push(path);
                    return false;
                },
            });
        }
        // Determine pairwise costs
        let totalCost = 0;
        let costEntries = 0;
        for (const pattern1 of patterns) {
            for (const pattern2 of patterns) {
                if (pattern1 !== pattern2) {
                    totalCost += ActorRdfJoinSelectivityVariableCounting.getOperationsPairwiseJoinCost(pattern1, pattern2);
                    costEntries++;
                }
            }
        }
        // Combine all pairwise costs, and multiply with costs of each pattern separately
        return totalCost / costEntries * patterns
            .reduce((factor, pattern) => factor * ActorRdfJoinSelectivityVariableCounting.getPatternCost(pattern), 1);
    }
    async run(action) {
        if (action.entries.length <= 1) {
            return { selectivity: 1 };
        }
        return {
            selectivity: ActorRdfJoinSelectivityVariableCounting
                .getOperationsJoinCost(action.entries.map(entry => entry.operation)),
        };
    }
}
exports.ActorRdfJoinSelectivityVariableCounting = ActorRdfJoinSelectivityVariableCounting;
// Calculated as sum of unbound join type costs times 2 (best-case)
ActorRdfJoinSelectivityVariableCounting.MAX_PAIRWISE_COST = 41 * 2;
var JoinTypes;
(function (JoinTypes) {
    JoinTypes[JoinTypes["boundSS"] = 0] = "boundSS";
    JoinTypes[JoinTypes["boundSP"] = 1] = "boundSP";
    JoinTypes[JoinTypes["boundSO"] = 2] = "boundSO";
    JoinTypes[JoinTypes["boundSG"] = 3] = "boundSG";
    JoinTypes[JoinTypes["boundPS"] = 4] = "boundPS";
    JoinTypes[JoinTypes["boundPP"] = 5] = "boundPP";
    JoinTypes[JoinTypes["boundPO"] = 6] = "boundPO";
    JoinTypes[JoinTypes["boundPG"] = 7] = "boundPG";
    JoinTypes[JoinTypes["boundOS"] = 8] = "boundOS";
    JoinTypes[JoinTypes["boundOP"] = 9] = "boundOP";
    JoinTypes[JoinTypes["boundOO"] = 10] = "boundOO";
    JoinTypes[JoinTypes["boundOG"] = 11] = "boundOG";
    JoinTypes[JoinTypes["boundGS"] = 12] = "boundGS";
    JoinTypes[JoinTypes["boundGP"] = 13] = "boundGP";
    JoinTypes[JoinTypes["boundGO"] = 14] = "boundGO";
    JoinTypes[JoinTypes["boundGG"] = 15] = "boundGG";
    JoinTypes[JoinTypes["unboundSS"] = 16] = "unboundSS";
    JoinTypes[JoinTypes["unboundSP"] = 17] = "unboundSP";
    JoinTypes[JoinTypes["unboundSO"] = 18] = "unboundSO";
    JoinTypes[JoinTypes["unboundSG"] = 19] = "unboundSG";
    JoinTypes[JoinTypes["unboundPS"] = 20] = "unboundPS";
    JoinTypes[JoinTypes["unboundPP"] = 21] = "unboundPP";
    JoinTypes[JoinTypes["unboundPO"] = 22] = "unboundPO";
    JoinTypes[JoinTypes["unboundPG"] = 23] = "unboundPG";
    JoinTypes[JoinTypes["unboundOS"] = 24] = "unboundOS";
    JoinTypes[JoinTypes["unboundOP"] = 25] = "unboundOP";
    JoinTypes[JoinTypes["unboundOO"] = 26] = "unboundOO";
    JoinTypes[JoinTypes["unboundOG"] = 27] = "unboundOG";
    JoinTypes[JoinTypes["unboundGS"] = 28] = "unboundGS";
    JoinTypes[JoinTypes["unboundGP"] = 29] = "unboundGP";
    JoinTypes[JoinTypes["unboundGO"] = 30] = "unboundGO";
    JoinTypes[JoinTypes["unboundGG"] = 31] = "unboundGG";
})(JoinTypes = exports.JoinTypes || (exports.JoinTypes = {}));
//# sourceMappingURL=ActorRdfJoinSelectivityVariableCounting.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-join-selectivity-variable-counting/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-selectivity-variable-counting/lib/ActorRdfJoinSelectivityVariableCounting.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-resolve-quad-pattern-federated/lib/ActorRdfResolveQuadPatternFederated.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfResolveQuadPatternFederated = void 0;
const bus_rdf_resolve_quad_pattern_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-resolve-quad-pattern/lib/index.js");
const FederatedQuadSource_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-resolve-quad-pattern-federated/lib/FederatedQuadSource.js");
/**
 * A comunica Federated RDF Resolve Quad Pattern Actor.
 */
class ActorRdfResolveQuadPatternFederated extends bus_rdf_resolve_quad_pattern_1.ActorRdfResolveQuadPatternSource {
    constructor(args) {
        super(args);
        this.emptyPatterns = new Map();
    }
    async test(action) {
        const sources = (0, bus_rdf_resolve_quad_pattern_1.getContextSources)(action.context);
        if (!sources) {
            throw new Error(`Actor ${this.name} can only resolve quad pattern queries against a sources array.`);
        }
        return true;
    }
    async getSource(context) {
        return new FederatedQuadSource_1.FederatedQuadSource(this.mediatorResolveQuadPattern, context, this.emptyPatterns, this.skipEmptyPatterns);
    }
}
exports.ActorRdfResolveQuadPatternFederated = ActorRdfResolveQuadPatternFederated;
//# sourceMappingURL=ActorRdfResolveQuadPatternFederated.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-resolve-quad-pattern-federated/lib/FederatedQuadSource.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FederatedQuadSource = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const bus_rdf_resolve_quad_pattern_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-resolve-quad-pattern/lib/index.js");
const context_entries_1 = __quadstore_comunica_require__("../node_modules/@comunica/context-entries/lib/index.js");
const data_factory_1 = __quadstore_comunica_require__("../node_modules/@comunica/data-factory/lib/index.js");
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const rdf_terms_1 = __quadstore_comunica_require__("../node_modules/rdf-terms/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A FederatedQuadSource can evaluate quad pattern queries over the union of different heterogeneous sources.
 * It will call the given mediator to evaluate each quad pattern query separately.
 */
class FederatedQuadSource {
    constructor(mediatorResolveQuadPattern, context, emptyPatterns, skipEmptyPatterns) {
        this.mediatorResolveQuadPattern = mediatorResolveQuadPattern;
        this.sources = context.get(context_entries_1.KeysRdfResolveQuadPattern.sources);
        this.contextDefault = context.delete(context_entries_1.KeysRdfResolveQuadPattern.sources);
        this.emptyPatterns = emptyPatterns;
        this.sourceIds = context.get(context_entries_1.KeysRdfResolveQuadPattern.sourceIds) ?? new Map();
        this.skipEmptyPatterns = skipEmptyPatterns;
        this.algebraFactory = new sparqlalgebrajs_1.Factory();
        // Initialize sources in the emptyPatterns datastructure
        if (this.skipEmptyPatterns) {
            for (const source of this.sources) {
                if (!this.emptyPatterns.has(source)) {
                    this.emptyPatterns.set(source, []);
                }
            }
        }
    }
    /**
     * Check if the given RDF term is not bound to an exact value.
     * I.e., if it is not a Variable.
     * @param {RDF.Term} term An RDF term.
     * @return {boolean} If it is not bound.
     */
    static isTermBound(term) {
        return term.termType !== 'Variable';
    }
    /**
     * Checks if the given (child) pattern is a more bound version of the given (parent) pattern.
     * This will also return true if the patterns are equal.
     * @param {RDF.BaseQuad} child A child pattern.
     * @param {RDF.BaseQuad} parent A parent pattern.
     * @return {boolean} If child is a sub-pattern of parent
     */
    static isSubPatternOf(child, parent) {
        return (!FederatedQuadSource.isTermBound(parent.subject) || parent.subject.equals(child.subject)) &&
            (!FederatedQuadSource.isTermBound(parent.predicate) || parent.predicate.equals(child.predicate)) &&
            (!FederatedQuadSource.isTermBound(parent.object) || parent.object.equals(child.object)) &&
            (!FederatedQuadSource.isTermBound(parent.graph) || parent.graph.equals(child.graph));
    }
    /**
     * If the given term is a blank node, return a deterministic named node for it
     * based on the source id and the blank node value.
     * @param term Any RDF term.
     * @param sourceId A source identifier.
     * @return If the given term was a blank node, this will return a skolemized named node, otherwise the original term.
     */
    static skolemizeTerm(term, sourceId) {
        if (term.termType === 'BlankNode') {
            return new data_factory_1.BlankNodeScoped(`bc_${sourceId}_${term.value}`, DF.namedNode(`${FederatedQuadSource.SKOLEM_PREFIX}${sourceId}:${term.value}`));
        }
        return term;
    }
    /**
     * Skolemize all terms in the given quad.
     * @param quad An RDF quad.
     * @param sourceId A source identifier.
     * @return The skolemized quad.
     */
    static skolemizeQuad(quad, sourceId) {
        return (0, rdf_terms_1.mapTerms)(quad, term => FederatedQuadSource.skolemizeTerm(term, sourceId));
    }
    /**
     * If a given term was a skolemized named node for the given source id,
     * deskolemize it again to a blank node.
     * If the given term was a skolemized named node for another source, return false.
     * If the given term was not a skolemized named node, return the original term.
     * @param term Any RDF term.
     * @param sourceId A source identifier.
     */
    static deskolemizeTerm(term, sourceId) {
        if (term.termType === 'BlankNode' && 'skolemized' in term) {
            term = term.skolemized;
        }
        if (term.termType === 'NamedNode' && term.value.startsWith(FederatedQuadSource.SKOLEM_PREFIX)) {
            const colonSeparator = term.value.indexOf(':', FederatedQuadSource.SKOLEM_PREFIX.length);
            const termSourceId = term.value.slice(FederatedQuadSource.SKOLEM_PREFIX.length, colonSeparator);
            // We had a skolemized term
            if (termSourceId === sourceId) {
                // It came from the correct source
                const termLabel = term.value.slice(colonSeparator + 1, term.value.length);
                return DF.blankNode(termLabel);
            }
            // It came from a different source
            return null;
        }
        return term;
    }
    /**
     * Deskolemize all terms in the given quad.
     * @param quad An RDF quad.
     * @param sourceId A source identifier.
     * @return The deskolemized quad.
     */
    static deskolemizeQuad(quad, sourceId) {
        return (0, rdf_terms_1.mapTerms)(quad, (term) => {
            const newTerm = FederatedQuadSource.deskolemizeTerm(term, sourceId);
            // If the term was skolemized in a different source then dont deskolemize it
            return !newTerm ? term : newTerm;
        });
    }
    /**
     * If the given source is guaranteed to produce an empty result for the given pattern.
     *
     * This prediction is done based on the 'emptyPatterns' datastructure that is stored within this actor.
     * Every time an empty pattern is passed, this pattern is stored in this datastructure for this source.
     * If this pattern (or a more bound pattern) is queried, we know for certain that it will be empty again.
     * This is under the assumption that sources will remain static during query evaluation.
     *
     * @param {IQuerySource} source
     * @param {RDF.BaseQuad} pattern
     * @return {boolean}
     */
    isSourceEmpty(source, pattern) {
        if (!this.skipEmptyPatterns) {
            return false;
        }
        const emptyPatterns = this.emptyPatterns.get(source);
        if (emptyPatterns) {
            for (const emptyPattern of emptyPatterns) {
                if (FederatedQuadSource.isSubPatternOf(pattern, emptyPattern)) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Get the unique, deterministic id for the given source.
     * @param source A data source.
     * @return The id of the given source.
     */
    getSourceId(source) {
        let sourceId = this.sourceIds.get(source);
        if (sourceId === undefined) {
            sourceId = `${this.sourceIds.size}`;
            this.sourceIds.set(source, sourceId);
        }
        return sourceId;
    }
    match(subject, predicate, object, graph) {
        // Counters for our metadata
        const metadata = { cardinality: { type: 'exact', value: 0 }, canContainUndefs: false };
        let remainingSources = this.sources.length;
        // Anonymous function to handle cardinality from metadata
        const checkEmitMetadata = (currentTotalItems, source, pattern, lastMetadata) => {
            if (this.skipEmptyPatterns && !currentTotalItems && pattern && !this.isSourceEmpty(source, pattern)) {
                this.emptyPatterns.get(source).push(pattern);
            }
            if (!remainingSources) {
                if (lastMetadata && this.sources.length === 1) {
                    // If we only had one source, emit the metadata as-is.
                    it.setProperty('metadata', lastMetadata);
                }
                else {
                    it.setProperty('metadata', metadata);
                }
            }
        };
        const proxyIt = Promise.all(this.sources.map(async (source) => {
            const sourceId = this.getSourceId(source);
            // Deskolemize terms, so we send the original blank nodes to each source.
            // Note that some sources may not match bnodes by label. SPARQL endpoints for example consider them variables.
            const patternS = FederatedQuadSource.deskolemizeTerm(subject, sourceId);
            const patternP = FederatedQuadSource.deskolemizeTerm(predicate, sourceId);
            const patternO = FederatedQuadSource.deskolemizeTerm(object, sourceId);
            const patternG = FederatedQuadSource.deskolemizeTerm(graph, sourceId);
            let pattern;
            // Prepare the context for this specific source
            let context = (0, bus_rdf_resolve_quad_pattern_1.getDataSourceContext)(source, this.contextDefault);
            context = context.set(context_entries_1.KeysRdfResolveQuadPattern.source, { type: (0, bus_rdf_resolve_quad_pattern_1.getDataSourceType)(source), value: (0, bus_rdf_resolve_quad_pattern_1.getDataSourceValue)(source) });
            let output;
            // If any of the deskolemized blank nodes originate from another source,
            // or if we can predict that the given source will have no bindings for the given pattern,
            // return an empty iterator.
            if (!patternS || !patternP || !patternO || !patternG ||
                // eslint-disable-next-line no-cond-assign
                this.isSourceEmpty(source, pattern = this.algebraFactory
                    .createPattern(patternS, patternP, patternO, patternG))) {
                output = { data: new asynciterator_1.ArrayIterator([], { autoStart: false }) };
                output.data.setProperty('metadata', { cardinality: 0, canContainUndefs: false });
            }
            else {
                output = await this.mediatorResolveQuadPattern.mediate({ pattern, context });
            }
            // Handle the metadata from this source
            output.data.getProperty('metadata', (subMetadata) => {
                if (!subMetadata.cardinality || !Number.isFinite(subMetadata.cardinality.value)) {
                    // We're already at infinite, so ignore any later metadata
                    metadata.cardinality.type = 'estimate';
                    metadata.cardinality.value = Number.POSITIVE_INFINITY;
                    remainingSources = 0;
                }
                else {
                    if (subMetadata.cardinality.type === 'estimate') {
                        metadata.cardinality.type = 'estimate';
                    }
                    metadata.cardinality.value += subMetadata.cardinality.value;
                    remainingSources--;
                }
                if (metadata.requestTime || subMetadata.requestTime) {
                    metadata.requestTime = metadata.requestTime || 0;
                    subMetadata.requestTime = subMetadata.requestTime || 0;
                    metadata.requestTime += subMetadata.requestTime;
                }
                if (metadata.pageSize || subMetadata.pageSize) {
                    metadata.pageSize = metadata.pageSize || 0;
                    subMetadata.pageSize = subMetadata.pageSize || 0;
                    metadata.pageSize += subMetadata.pageSize;
                }
                if (subMetadata.canContainUndefs) {
                    metadata.canContainUndefs = true;
                }
                checkEmitMetadata(metadata.cardinality.value, source, pattern, subMetadata);
            });
            // Determine the data stream from this source
            const data = output.data.map(quad => FederatedQuadSource.skolemizeQuad(quad, sourceId));
            // Forward errors to our final iterator
            data.on('error', error => it.emit('error', error));
            return data;
        }));
        // Take the union of all source streams
        const it = new bus_query_operation_1.ClosableTransformIterator(async () => new asynciterator_1.UnionIterator(await proxyIt), {
            autoStart: false,
            onClose() {
                // Destroy the sub-iterators
                proxyIt.then(proxyItResolved => {
                    for (const subIt of proxyItResolved) {
                        subIt.destroy();
                    }
                }, () => {
                    // Void errors
                });
            },
        });
        // If we have 0 sources, immediately emit metadata
        if (this.sources.length === 0) {
            it.setProperty('metadata', metadata);
        }
        return it;
    }
}
exports.FederatedQuadSource = FederatedQuadSource;
FederatedQuadSource.SKOLEM_PREFIX = 'urn:comunica_skolem:source_';
//# sourceMappingURL=FederatedQuadSource.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-resolve-quad-pattern-federated/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-resolve-quad-pattern-federated/lib/ActorRdfResolveQuadPatternFederated.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-resolve-quad-pattern-federated/lib/FederatedQuadSource.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-resolve-quad-pattern-rdfjs-source/lib/ActorRdfResolveQuadPatternRdfJsSource.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfResolveQuadPatternRdfJsSource = void 0;
const bus_rdf_resolve_quad_pattern_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-resolve-quad-pattern/lib/index.js");
const RdfJsQuadSource_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-resolve-quad-pattern-rdfjs-source/lib/RdfJsQuadSource.js");
/**
 * A comunica RDFJS Source RDF Resolve Quad Pattern Actor.
 */
class ActorRdfResolveQuadPatternRdfJsSource extends bus_rdf_resolve_quad_pattern_1.ActorRdfResolveQuadPatternSource {
    constructor(args) {
        super(args);
    }
    async test(action) {
        if (!(0, bus_rdf_resolve_quad_pattern_1.hasContextSingleSourceOfType)('rdfjsSource', action.context)) {
            throw new Error(`${this.name} requires a single source with an rdfjsSource to be present in the context.`);
        }
        const source = (0, bus_rdf_resolve_quad_pattern_1.getContextSource)(action.context);
        if (!source || typeof source === 'string' || (!('match' in source) && !source.value.match)) {
            throw new Error(`${this.name} received an invalid rdfjsSource.`);
        }
        return true;
    }
    async getSource(context) {
        const source = (0, bus_rdf_resolve_quad_pattern_1.getContextSource)(context);
        return new RdfJsQuadSource_1.RdfJsQuadSource('match' in source ? source : source.value);
    }
}
exports.ActorRdfResolveQuadPatternRdfJsSource = ActorRdfResolveQuadPatternRdfJsSource;
//# sourceMappingURL=ActorRdfResolveQuadPatternRdfJsSource.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-resolve-quad-pattern-rdfjs-source/lib/IRdfJsSourceExtended.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=IRdfJsSourceExtended.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-resolve-quad-pattern-rdfjs-source/lib/RdfJsQuadSource.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RdfJsQuadSource = void 0;
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
/**
 * A quad source that wraps over an {@link RDF.Source}.
 */
class RdfJsQuadSource {
    constructor(source) {
        this.source = source;
    }
    static nullifyVariables(term) {
        return !term || term.termType === 'Variable' ? undefined : term;
    }
    match(subject, predicate, object, graph) {
        // Create an async iterator from the matched quad stream
        const rawStream = this.source.match(RdfJsQuadSource.nullifyVariables(subject), RdfJsQuadSource.nullifyVariables(predicate), RdfJsQuadSource.nullifyVariables(object), RdfJsQuadSource.nullifyVariables(graph));
        const it = (0, asynciterator_1.wrap)(rawStream, { autoStart: false });
        // Determine metadata
        this.setMetadata(it, subject, predicate, object, graph)
            .catch(error => it.destroy(error));
        return it;
    }
    async setMetadata(it, subject, predicate, object, graph) {
        let cardinality;
        if (this.source.countQuads) {
            // If the source provides a dedicated method for determining cardinality, use that.
            cardinality = await this.source.countQuads(RdfJsQuadSource.nullifyVariables(subject), RdfJsQuadSource.nullifyVariables(predicate), RdfJsQuadSource.nullifyVariables(object), RdfJsQuadSource.nullifyVariables(graph));
        }
        else {
            // Otherwise, fallback to a sub-optimal alternative where we just call match again to count the quads.
            // WARNING: we can NOT reuse the original data stream here,
            // because we may loose data elements due to things happening async.
            let i = 0;
            cardinality = await new Promise((resolve, reject) => {
                const matches = this.source.match(RdfJsQuadSource.nullifyVariables(subject), RdfJsQuadSource.nullifyVariables(predicate), RdfJsQuadSource.nullifyVariables(object), RdfJsQuadSource.nullifyVariables(graph));
                matches.on('error', reject);
                matches.on('end', () => resolve(i));
                matches.on('data', () => i++);
            });
        }
        it.setProperty('metadata', { cardinality: { type: 'exact', value: cardinality }, canContainUndefs: false });
    }
}
exports.RdfJsQuadSource = RdfJsQuadSource;
//# sourceMappingURL=RdfJsQuadSource.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-resolve-quad-pattern-rdfjs-source/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-resolve-quad-pattern-rdfjs-source/lib/ActorRdfResolveQuadPatternRdfJsSource.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-resolve-quad-pattern-rdfjs-source/lib/IRdfJsSourceExtended.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-resolve-quad-pattern-rdfjs-source/lib/RdfJsQuadSource.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-update-quads-rdfjs-store/lib/ActorRdfUpdateQuadsRdfJsStore.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfUpdateQuadsRdfJsStore = void 0;
const bus_rdf_update_quads_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-update-quads/lib/index.js");
const RdfJsQuadDestination_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-update-quads-rdfjs-store/lib/RdfJsQuadDestination.js");
/**
 * A comunica RDFJS Store RDF Update Quads Actor.
 */
class ActorRdfUpdateQuadsRdfJsStore extends bus_rdf_update_quads_1.ActorRdfUpdateQuadsDestination {
    constructor(args) {
        super(args);
    }
    async test(action) {
        const destination = (0, bus_rdf_update_quads_1.getContextDestination)(action.context);
        if (!destination || typeof destination === 'string' ||
            (!('remove' in destination) && 'value' in destination && !destination.value.remove)) {
            throw new Error(`${this.name} received an invalid rdfjsStore.`);
        }
        return true;
    }
    async getDestination(context) {
        const destination = (0, bus_rdf_update_quads_1.getContextDestination)(context);
        return new RdfJsQuadDestination_1.RdfJsQuadDestination('remove' in destination ? destination : destination.value);
    }
}
exports.ActorRdfUpdateQuadsRdfJsStore = ActorRdfUpdateQuadsRdfJsStore;
//# sourceMappingURL=ActorRdfUpdateQuadsRdfJsStore.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-update-quads-rdfjs-store/lib/RdfJsQuadDestination.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RdfJsQuadDestination = void 0;
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const rdf_string_1 = __quadstore_comunica_require__("../node_modules/rdf-string/index.js");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A quad destination that wraps around an {@link RDF.Store}.
 */
class RdfJsQuadDestination {
    constructor(store) {
        this.store = store;
    }
    promisifyEventEmitter(eventEmitter) {
        return new Promise((resolve, reject) => {
            eventEmitter.on('end', resolve);
            eventEmitter.on('error', reject);
        });
    }
    delete(quads) {
        return this.promisifyEventEmitter(this.store.remove(quads));
    }
    insert(quads) {
        return this.promisifyEventEmitter(this.store.import(quads));
    }
    async deleteGraphs(graphs, requireExistence, dropGraphs) {
        switch (graphs) {
            case 'ALL':
                /* eslint-disable no-fallthrough */
                // Remove the default graph
                await this.promisifyEventEmitter(this.store.deleteGraph(DF.defaultGraph()));
            // Drop through to remove all named graphs
            case 'NAMED':
                /* eslint-enable no-fallthrough */
                // Warning: this is sub-optimal!
                // Query ALL quads to determine all named graphs
                // eslint-disable-next-line no-case-declarations
                const allQuads = this.store.match();
                // eslint-disable-next-line no-case-declarations
                const namedGraphs = {};
                allQuads.on('data', (quad) => {
                    if (quad.graph.termType !== 'DefaultGraph') {
                        namedGraphs[(0, rdf_string_1.termToString)(quad.graph)] = true;
                    }
                });
                await this.promisifyEventEmitter(allQuads);
                // Delete all named graphs
                await Promise.all(Object.keys(namedGraphs)
                    .map(namedGraph => this.promisifyEventEmitter(this.store
                    .deleteGraph((0, rdf_string_1.stringToTerm)(namedGraph)))));
                break;
            default:
                // Delete the default graph or a named graph
                for (const graph of Array.isArray(graphs) ? graphs : [graphs]) {
                    await this.promisifyEventEmitter(this.store.deleteGraph(graph));
                }
        }
    }
    async createGraphs(graphs, requireNonExistence) {
        // We don't have to create anything, since RDF/JS stores don't record empty graphs.
        // The only check we have to do is error on existence
        if (requireNonExistence) {
            for (const graph of graphs) {
                const eventEmitter = this.store.match(undefined, undefined, undefined, graph);
                await new Promise((resolve, reject) => {
                    eventEmitter.once('data', () => {
                        reject(new Error(`Unable to create graph ${graph.value} as it already exists`));
                    });
                    eventEmitter.on('end', resolve);
                    eventEmitter.on('error', reject);
                });
            }
        }
    }
}
exports.RdfJsQuadDestination = RdfJsQuadDestination;
//# sourceMappingURL=RdfJsQuadDestination.js.map

/***/ }),

/***/ "../node_modules/@comunica/actor-rdf-update-quads-rdfjs-store/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-update-quads-rdfjs-store/lib/ActorRdfUpdateQuadsRdfJsStore.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/bindings-factory/lib/Bindings.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Bindings = void 0;
const immutable_1 = __quadstore_comunica_require__("../packages/immutable/dist/index.js");
const bindingsToString_1 = __quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/bindingsToString.js");
/**
 * An immutable.js-based Bindings object.
 */
class Bindings {
    constructor(dataFactory, entries) {
        this.type = 'bindings';
        this.dataFactory = dataFactory;
        this.entries = entries;
    }
    has(key) {
        return this.entries.has(typeof key === 'string' ? key : key.value);
    }
    get(key) {
        return this.entries.get(typeof key === 'string' ? key : key.value);
    }
    set(key, value) {
        return new Bindings(this.dataFactory, this.entries.set(typeof key === 'string' ? key : key.value, value));
    }
    delete(key) {
        return new Bindings(this.dataFactory, this.entries.delete(typeof key === 'string' ? key : key.value));
    }
    keys() {
        return this.mapIterable(this.iteratorToIterable(this.entries.keys()), key => this.dataFactory.variable(key));
    }
    values() {
        return this.iteratorToIterable(this.entries.values());
    }
    forEach(fn) {
        this.entries.forEach((value, key) => fn(value, this.dataFactory.variable(key)));
    }
    get size() {
        return this.entries.size;
    }
    [Symbol.iterator]() {
        return this.mapIterable(this.iteratorToIterable(this.entries.entries()), ([key, value]) => [this.dataFactory.variable(key), value])[Symbol.iterator]();
    }
    equals(other) {
        if (!other) {
            return false;
        }
        if (this === other) {
            return true;
        }
        // First check if size is equal
        if (this.size !== other.size) {
            return false;
        }
        // Then check if keys and values are equal
        for (const key of this.keys()) {
            if (!this.get(key)?.equals(other.get(key))) {
                return false;
            }
        }
        return true;
    }
    filter(fn) {
        return new Bindings(this.dataFactory, (0, immutable_1.Map)(this.entries
            .filter((value, key) => fn(value, this.dataFactory.variable(key)))));
    }
    map(fn) {
        return new Bindings(this.dataFactory, (0, immutable_1.Map)(this.entries
            .map((value, key) => fn(value, this.dataFactory.variable(key)))));
    }
    merge(other) {
        // Determine the union of keys
        const keys = new Set([
            ...this.iteratorToIterable(this.entries.keys()),
            ...[...other.keys()].map(key => key.value),
        ]);
        // Collect entries
        const entries = [];
        for (const key of keys) {
            const left = this.entries.get(key);
            const right = other.get(this.dataFactory.variable(key));
            if (left && right && !left.equals(right)) {
                return;
            }
            const value = left || right;
            entries.push([key, value]);
        }
        return new Bindings(this.dataFactory, (0, immutable_1.Map)(entries));
    }
    mergeWith(merger, other) {
        // Determine the union of keys
        const keys = new Set([
            ...this.iteratorToIterable(this.entries.keys()),
            ...[...other.keys()].map(key => key.value),
        ]);
        // Collect entries
        const entries = [];
        for (const key of keys) {
            const variable = this.dataFactory.variable(key);
            const left = this.entries.get(key);
            const right = other.get(variable);
            let value;
            if (left && right && !left.equals(right)) {
                value = merger(left, right, variable);
            }
            else {
                value = left || right;
            }
            entries.push([key, value]);
        }
        return new Bindings(this.dataFactory, (0, immutable_1.Map)(entries));
    }
    toString() {
        return (0, bindingsToString_1.bindingsToString)(this);
    }
    *mapIterable(iterable, callback) {
        for (const x of iterable) {
            // eslint-disable-next-line callback-return
            yield callback(x);
        }
    }
    iteratorToIterable(iterator) {
        return {
            [Symbol.iterator]: () => iterator,
        };
    }
}
exports.Bindings = Bindings;
//# sourceMappingURL=Bindings.js.map

/***/ }),

/***/ "../node_modules/@comunica/bindings-factory/lib/BindingsFactory.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BindingsFactory = void 0;
const immutable_1 = __quadstore_comunica_require__("../packages/immutable/dist/index.js");
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const Bindings_1 = __quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/Bindings.js");
/**
 * A Bindings factory that provides Bindings backed by immutable.js.
 */
class BindingsFactory {
    constructor(dataFactory = new rdf_data_factory_1.DataFactory()) {
        this.dataFactory = dataFactory;
    }
    bindings(entries = []) {
        return new Bindings_1.Bindings(this.dataFactory, (0, immutable_1.Map)(entries.map(([key, value]) => [key.value, value])));
    }
    fromBindings(bindings) {
        return this.bindings([...bindings]);
    }
    fromRecord(record) {
        return this.bindings(Object.entries(record).map(([key, value]) => [this.dataFactory.variable(key), value]));
    }
}
exports.BindingsFactory = BindingsFactory;
//# sourceMappingURL=BindingsFactory.js.map

/***/ }),

/***/ "../node_modules/@comunica/bindings-factory/lib/bindingsToString.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bindingsToString = void 0;
const rdf_string_1 = __quadstore_comunica_require__("../node_modules/rdf-string/index.js");
/**
 * Stringify a bindings object.
 * @param bindings A bindings object.
 */
function bindingsToString(bindings) {
    const raw = {};
    for (const key of bindings.keys()) {
        raw[key.value] = (0, rdf_string_1.termToString)(bindings.get(key));
    }
    return JSON.stringify(raw, null, '  ');
}
exports.bindingsToString = bindingsToString;
//# sourceMappingURL=bindingsToString.js.map

/***/ }),

/***/ "../node_modules/@comunica/bindings-factory/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/Bindings.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/BindingsFactory.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/bindingsToString.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-context-preprocess/lib/ActorContextPreprocess.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorContextPreprocess = void 0;
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
/**
 * A comunica actor for context-preprocess events.
 *
 * Actor types:
 * * Input:  IAction:      A context that will be processed.
 * * Test:   <none>
 * * Output: IActorContextPreprocessOutput: The resulting context.
 *
 * @see IActionContextPreprocess
 * @see IActorContextPreprocessOutput
 */
class ActorContextPreprocess extends core_1.Actor {
    /**
     * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     */
    constructor(args) {
        super(args);
    }
}
exports.ActorContextPreprocess = ActorContextPreprocess;
//# sourceMappingURL=ActorContextPreprocess.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-context-preprocess/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-context-preprocess/lib/ActorContextPreprocess.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-hash-bindings/lib/ActorHashBindings.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorHashBindings = void 0;
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
/**
 * A comunica actor for hash-bindings events.
 *
 * Actor types:
 * * Input:  IActionHashBindings:      Metadata for selecting a hash function.
 * * Test:   IActorTest:
 * * Output: IActorHashBindingsOutput: The resulting hash function.
 *
 * @see IActionHashBindings
 * @see IActorHashBindingsTest
 * @see IActorHashBindingsOutput
 */
class ActorHashBindings extends core_1.Actor {
    /**
     * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     */
    constructor(args) {
        super(args);
    }
}
exports.ActorHashBindings = ActorHashBindings;
//# sourceMappingURL=ActorHashBindings.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-hash-bindings/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-hash-bindings/lib/ActorHashBindings.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-init/lib/ActorInit.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorInit = void 0;
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
/**
 * A base actor for listening to init events.
 *
 * Actor types:
 * * Input:  IActionInit:      Contains process information
 *                             such as the list of arguments,
 *                             environment variables and input stream.
 * * Test:   <none>
 * * Output: IActorOutputInit: Contains process output streams.
 *
 * @see IActionInit
 */
class ActorInit extends core_1.Actor {
    /**
     * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     */
    constructor(args) {
        super(args);
    }
}
exports.ActorInit = ActorInit;
//# sourceMappingURL=ActorInit.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-init/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-init/lib/ActorInit.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-optimize-query-operation/lib/ActorOptimizeQueryOperation.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorOptimizeQueryOperation = void 0;
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
/**
 * A comunica actor for optimize-query-operation events.
 *
 * Actor types:
 * * Input:  IActionOptimizeQueryOperation:      An incoming SPARQL operation.
 * * Test:   <none>
 * * Output: IActorOptimizeQueryOperationOutput: A (possibly optimized) outgoing SPARQL operation.
 *
 * @see IActionOptimizeQueryOperation
 * @see IActorOptimizeQueryOperationOutput
 */
class ActorOptimizeQueryOperation extends core_1.Actor {
    /**
     * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     */
    constructor(args) {
        super(args);
    }
}
exports.ActorOptimizeQueryOperation = ActorOptimizeQueryOperation;
//# sourceMappingURL=ActorOptimizeQueryOperation.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-optimize-query-operation/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-optimize-query-operation/lib/ActorOptimizeQueryOperation.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-query-operation/lib/ActorQueryOperation.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperation = void 0;
const context_entries_1 = __quadstore_comunica_require__("../node_modules/@comunica/context-entries/lib/index.js");
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
const data_factory_1 = __quadstore_comunica_require__("../node_modules/@comunica/data-factory/lib/index.js");
const Bindings_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/Bindings.js");
/**
 * A counter that keeps track blank node generated through BNODE() SPARQL
 * expressions.
 *
 * @type {number}
 */
let bnodeCounter = 0;
/**
 * A comunica actor for query-operation events.
 *
 * Actor types:
 * * Input:  IActionQueryOperation:      A SPARQL Algebra operation.
 * * Test:   <none>
 * * Output: IActorQueryOperationOutput: A bindings stream.
 *
 * @see IActionQueryOperation
 * @see IQueryOperationResult
 */
class ActorQueryOperation extends core_1.Actor {
    /**
     * @param args - @defaultNested {<default_bus> a <cbqo:components/BusQueryOperation.jsonld#BusQueryOperation>} bus
     */
    constructor(args) {
        super(args);
    }
    /**
     * Safely cast a query operation output to a bindings output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IQueryOperationResult} output A query operation output.
     * @return {IQueryOperationResultBindings} A bindings query operation output.
     */
    static getSafeBindings(output) {
        ActorQueryOperation.validateQueryOutput(output, 'bindings');
        return output;
    }
    /**
     * Safely cast a query operation output to a quads output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IQueryOperationResult} output A query operation output.
     * @return {IQueryOperationResultQuads} A quads query operation output.
     */
    static getSafeQuads(output) {
        ActorQueryOperation.validateQueryOutput(output, 'quads');
        return output;
    }
    /**
     * Safely cast a query operation output to a boolean output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IQueryOperationResult} output A query operation output.
     * @return {IQueryOperationResultBoolean} A boolean query operation output.
     */
    static getSafeBoolean(output) {
        ActorQueryOperation.validateQueryOutput(output, 'boolean');
        return output;
    }
    /**
     * Safely cast a query operation output to a void output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IQueryOperationResult} output A query operation output.
     * @return {IQueryOperationResultVoid} A void query operation output.
     */
    static getSafeVoid(output) {
        ActorQueryOperation.validateQueryOutput(output, 'void');
        return output;
    }
    /**
     * Convert a metadata callback to a lazy callback where the response value is cached.
     * @param {() => Promise<IMetadata>} metadata A metadata callback
     * @return {() => Promise<{[p: string]: any}>} The callback where the response will be cached.
     */
    static cachifyMetadata(metadata) {
        let lastReturn;
        // eslint-disable-next-line no-return-assign,@typescript-eslint/no-misused-promises
        return () => (lastReturn || (lastReturn = metadata()));
    }
    /**
     * Throw an error if the output type does not match the expected type.
     * @param {IQueryOperationResult} output A query operation output.
     * @param {string} expectedType The expected output type.
     */
    static validateQueryOutput(output, expectedType) {
        if (output.type !== expectedType) {
            throw new Error(`Invalid query output type: Expected '${expectedType}' but got '${output.type}'`);
        }
    }
    static getBaseExpressionContext(context) {
        const now = context.get(context_entries_1.KeysInitQuery.queryTimestamp);
        const baseIRI = context.get(context_entries_1.KeysInitQuery.baseIRI);
        // Handle two variants of providing extension functions
        if (context.has(context_entries_1.KeysInitQuery.extensionFunctionCreator) && context.has(context_entries_1.KeysInitQuery.extensionFunctions)) {
            throw new Error('Illegal simultaneous usage of extensionFunctionCreator and extensionFunctions in context');
        }
        let extensionFunctionCreator = context
            .get(context_entries_1.KeysInitQuery.extensionFunctionCreator);
        // Convert dictionary-based variant to callback
        const extensionFunctions = context
            .get(context_entries_1.KeysInitQuery.extensionFunctions);
        if (extensionFunctions) {
            extensionFunctionCreator = functionNamedNode => extensionFunctions[functionNamedNode.value];
        }
        return { now, baseIRI, extensionFunctionCreator };
    }
    /**
     * Create an options object that can be used to construct a sparqlee synchronous evaluator.
     * @param context An action context.
     * @param mediatorQueryOperation An optional query query operation mediator.
     *                               If defined, the existence resolver will be defined as `exists`.
     */
    static getExpressionContext(context, mediatorQueryOperation) {
        return {
            ...this.getBaseExpressionContext(context),
            bnode: (input) => new data_factory_1.BlankNodeBindingsScoped(input || `BNODE_${bnodeCounter++}`),
        };
    }
    /**
     * Create an options object that can be used to construct a sparqlee asynchronous evaluator.
     * @param context An action context.
     * @param mediatorQueryOperation An optional query query operation mediator.
     *                               If defined, the existence resolver will be defined as `exists`.
     */
    static getAsyncExpressionContext(context, mediatorQueryOperation) {
        const expressionContext = {
            ...this.getBaseExpressionContext(context),
            bnode: (input) => Promise.resolve(new data_factory_1.BlankNodeBindingsScoped(input || `BNODE_${bnodeCounter++}`)),
        };
        if (mediatorQueryOperation) {
            expressionContext.exists = ActorQueryOperation.createExistenceResolver(context, mediatorQueryOperation);
        }
        return expressionContext;
    }
    /**
     * Create an existence resolver for usage within an expression context.
     * @param context An action context.
     * @param mediatorQueryOperation A query operation mediator.
     */
    static createExistenceResolver(context, mediatorQueryOperation) {
        return async (expr, bindings) => {
            const operation = (0, Bindings_1.materializeOperation)(expr.input, bindings);
            const outputRaw = await mediatorQueryOperation.mediate({ operation, context });
            const output = ActorQueryOperation.getSafeBindings(outputRaw);
            return new Promise((resolve, reject) => {
                output.bindingsStream.on('end', () => {
                    resolve(false);
                });
                output.bindingsStream.on('error', reject);
                output.bindingsStream.on('data', () => {
                    output.bindingsStream.close();
                    resolve(true);
                });
            })
                .then((exists) => expr.not ? !exists : exists);
        };
    }
    /**
     * Throw an error if the context contains the readOnly flag.
     * @param context An action context.
     */
    static throwOnReadOnly(context) {
        if (context.get(context_entries_1.KeysQueryOperation.readOnly)) {
            throw new Error(`Attempted a write operation in read-only mode`);
        }
    }
}
exports.ActorQueryOperation = ActorQueryOperation;
//# sourceMappingURL=ActorQueryOperation.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-query-operation/lib/ActorQueryOperationTyped.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationTyped = void 0;
const context_entries_1 = __quadstore_comunica_require__("../node_modules/@comunica/context-entries/lib/index.js");
const ActorQueryOperation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/ActorQueryOperation.js");
/**
 * A base implementation for query operation actors for a specific operation type.
 */
class ActorQueryOperationTyped extends ActorQueryOperation_1.ActorQueryOperation {
    constructor(args, operationName) {
        super({ ...args, operationName });
        if (!this.operationName) {
            throw new Error('A valid "operationName" argument must be provided.');
        }
    }
    async test(action) {
        if (!action.operation) {
            throw new Error('Missing field \'operation\' in a query operation action.');
        }
        if (action.operation.type !== this.operationName) {
            throw new Error(`Actor ${this.name} only supports ${this.operationName} operations, but got ${action.operation.type}`);
        }
        const operation = action.operation;
        return this.testOperation(operation, action.context);
    }
    async run(action) {
        // Log to physical plan
        const physicalQueryPlanLogger = action.context
            .get(context_entries_1.KeysInitQuery.physicalQueryPlanLogger);
        if (physicalQueryPlanLogger) {
            physicalQueryPlanLogger.logOperation(action.operation.type, undefined, action.operation, action.context.get(context_entries_1.KeysInitQuery.physicalQueryPlanNode), this.name, {});
            action.context = action.context.set(context_entries_1.KeysInitQuery.physicalQueryPlanNode, action.operation);
        }
        const operation = action.operation;
        const subContext = action.context.set(context_entries_1.KeysQueryOperation.operation, operation);
        const output = await this.runOperation(operation, subContext);
        if ('metadata' in output) {
            output.metadata = ActorQueryOperation_1.ActorQueryOperation
                .cachifyMetadata(output.metadata);
        }
        return output;
    }
}
exports.ActorQueryOperationTyped = ActorQueryOperationTyped;
//# sourceMappingURL=ActorQueryOperationTyped.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-query-operation/lib/ActorQueryOperationTypedMediated.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryOperationTypedMediated = void 0;
const ActorQueryOperationTyped_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/ActorQueryOperationTyped.js");
/**
 * A base implementation for query operation actors for a specific operation type that have a query operation mediator.
 */
class ActorQueryOperationTypedMediated extends ActorQueryOperationTyped_1.ActorQueryOperationTyped {
    constructor(args, operationName) {
        super(args, operationName);
    }
}
exports.ActorQueryOperationTypedMediated = ActorQueryOperationTypedMediated;
//# sourceMappingURL=ActorQueryOperationTypedMediated.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-query-operation/lib/Bindings.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.materializeOperation = exports.materializeTerm = void 0;
const bindings_factory_1 = __quadstore_comunica_require__("../node_modules/@comunica/bindings-factory/lib/index.js");
const rdf_string_1 = __quadstore_comunica_require__("../node_modules/rdf-string/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
const BF = new bindings_factory_1.BindingsFactory();
/**
 * Materialize a term with the given binding.
 *
 * If the given term is a variable,
 * and that variable exist in the given bindings object,
 * the value of that binding is returned.
 * In all other cases, the term itself is returned.
 *
 * @param {RDF.Term} term A term.
 * @param {Bindings} bindings A bindings object.
 * @return {RDF.Term} The materialized term.
 */
function materializeTerm(term, bindings) {
    if (term.termType === 'Variable') {
        const value = bindings.get(term);
        if (value) {
            return value;
        }
    }
    return term;
}
exports.materializeTerm = materializeTerm;
/**
 * Materialize the given operation (recursively) with the given bindings.
 * Essentially, all variables in the given operation will be replaced
 * by the terms bound to the variables in the given bindings.
 * @param {Operation} operation SPARQL algebra operation.
 * @param {Bindings} bindings A bindings object.
 * @param options Options for materializations.
 * @return Algebra.Operation A new operation materialized with the given bindings.
 */
function materializeOperation(operation, bindings, options = {}) {
    options = {
        strictTargetVariables: 'strictTargetVariables' in options ? options.strictTargetVariables : false,
        bindFilter: 'bindFilter' in options ? options.bindFilter : true,
    };
    return sparqlalgebrajs_1.Util.mapOperation(operation, {
        path(op, factory) {
            // Materialize variables in a path expression.
            // The predicate expression will be recursed.
            return {
                recurse: false,
                result: factory.createPath(materializeTerm(op.subject, bindings), op.predicate, materializeTerm(op.object, bindings), materializeTerm(op.graph, bindings)),
            };
        },
        pattern(op, factory) {
            // Materialize variables in the quad pattern.
            return {
                recurse: false,
                result: factory.createPattern(materializeTerm(op.subject, bindings), materializeTerm(op.predicate, bindings), materializeTerm(op.object, bindings), materializeTerm(op.graph, bindings)),
            };
        },
        extend(op) {
            // Materialize an extend operation.
            // If strictTargetVariables is true, we throw if the extension target variable is attempted to be bound.
            // Otherwise, we remove the extend operation.
            if (bindings.has(op.variable)) {
                if (options.strictTargetVariables) {
                    throw new Error(`Tried to bind variable ${(0, rdf_string_1.termToString)(op.variable)} in a BIND operator.`);
                }
                else {
                    return {
                        recurse: true,
                        result: materializeOperation(op.input, bindings, options),
                    };
                }
            }
            return {
                recurse: true,
                result: op,
            };
        },
        group(op, factory) {
            // Materialize a group operation.
            // If strictTargetVariables is true, we throw if the group target variable is attempted to be bound.
            // Otherwise, we just filter out the bound variables.
            if (options.strictTargetVariables) {
                for (const variable of op.variables) {
                    if (bindings.has(variable)) {
                        throw new Error(`Tried to bind variable ${(0, rdf_string_1.termToString)(variable)} in a GROUP BY operator.`);
                    }
                }
                return {
                    recurse: true,
                    result: op,
                };
            }
            const variables = op.variables.filter(variable => !bindings.has(variable));
            return {
                recurse: true,
                result: factory.createGroup(op.input, variables, op.aggregates),
            };
        },
        project(op, factory) {
            // Materialize a project operation.
            // If strictTargetVariables is true, we throw if the project target variable is attempted to be bound.
            // Otherwise, we just filter out the bound variables.
            if (options.strictTargetVariables) {
                for (const variable of op.variables) {
                    if (bindings.has(variable)) {
                        throw new Error(`Tried to bind variable ${(0, rdf_string_1.termToString)(variable)} in a SELECT operator.`);
                    }
                }
                return {
                    recurse: true,
                    result: op,
                };
            }
            const variables = op.variables.filter(variable => !bindings.has(variable));
            // Only include projected variables in the sub-bindings that will be passed down recursively.
            // If we don't do this, we may be binding variables that may have the same label, but are not considered equal.
            const subBindings = BF.bindings(op.variables.map(variable => {
                const binding = bindings.get(variable);
                if (binding) {
                    return [variable, binding];
                }
                // eslint-disable-next-line no-useless-return
                return;
            }).filter(entry => Boolean(entry)));
            return {
                recurse: false,
                result: factory.createProject(materializeOperation(op.input, subBindings, options), variables),
            };
        },
        values(op, factory) {
            // Materialize a values operation.
            // If strictTargetVariables is true, we throw if the values target variable is attempted to be bound.
            // Otherwise, we just filter out the bound variables and their bindings.
            if (options.strictTargetVariables) {
                for (const variable of op.variables) {
                    if (bindings.has(variable)) {
                        throw new Error(`Tried to bind variable ${(0, rdf_string_1.termToString)(variable)} in a VALUES operator.`);
                    }
                }
            }
            else {
                const variables = op.variables.filter(variable => !bindings.has(variable));
                const valueBindings = op.bindings.map(binding => {
                    const newBinding = { ...binding };
                    let valid = true;
                    bindings.forEach((value, key) => {
                        const keyString = (0, rdf_string_1.termToString)(key);
                        if (keyString in newBinding) {
                            if (!value.equals(newBinding[keyString])) {
                                // If the value of the binding is not equal, remove this binding completely from the VALUES clause
                                valid = false;
                            }
                            delete newBinding[keyString];
                        }
                    });
                    return valid ? newBinding : undefined;
                }).filter(Boolean);
                return {
                    recurse: true,
                    result: factory.createValues(variables, valueBindings),
                };
            }
            return {
                recurse: false,
                result: op,
            };
        },
        expression(op, factory) {
            if (!options.bindFilter) {
                return {
                    recurse: false,
                    result: op,
                };
            }
            if (op.expressionType === 'term') {
                // Materialize a term expression
                return {
                    recurse: false,
                    result: factory.createTermExpression(materializeTerm(op.term, bindings)),
                };
            }
            if (op.expressionType === 'aggregate' &&
                'variable' in op &&
                bindings.has(op.variable)) {
                // Materialize a bound aggregate operation.
                // If strictTargetVariables is true, we throw if the expression target variable is attempted to be bound.
                // Otherwise, we ignore this operation.
                if (options.strictTargetVariables) {
                    throw new Error(`Tried to bind ${(0, rdf_string_1.termToString)(op.variable)} in a ${op.aggregator} aggregate.`);
                }
                else {
                    return {
                        recurse: true,
                        result: op,
                    };
                }
            }
            return {
                recurse: true,
                result: op,
            };
        },
    });
}
exports.materializeOperation = materializeOperation;
//# sourceMappingURL=Bindings.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-query-operation/lib/BusQueryOperation.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BusQueryOperation = void 0;
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
/**
 * Indexed bus for query operations.
 */
class BusQueryOperation extends core_1.BusIndexed {
    constructor(args) {
        super({
            ...args,
            actorIdentifierFields: ['operationName'],
            actionIdentifierFields: ['operation', 'type'],
        });
    }
}
exports.BusQueryOperation = BusQueryOperation;
//# sourceMappingURL=BusQueryOperation.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-query-operation/lib/ClosableTransformIterator.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClosableTransformIterator = void 0;
const asynciterator_1 = __quadstore_comunica_require__("asynciterator");
/**
 * A TransformIterator with a callback for when this iterator is closed in any way.
 */
class ClosableTransformIterator extends asynciterator_1.TransformIterator {
    constructor(source, options) {
        super(source, options);
        this.onClose = options.onClose;
    }
    _end(destroy) {
        this.onClose();
        super._end(destroy);
    }
}
exports.ClosableTransformIterator = ClosableTransformIterator;
//# sourceMappingURL=ClosableTransformIterator.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-query-operation/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/ActorQueryOperation.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/ActorQueryOperationTyped.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/ActorQueryOperationTypedMediated.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/Bindings.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/BusQueryOperation.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/ClosableTransformIterator.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-query-parse/lib/ActorQueryParse.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorQueryParse = void 0;
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
/**
 * A comunica actor for query-parse events.
 *
 * Actor types:
 * * Input:  IActionSparqlParse:      A SPARQL query string.
 * * Test:   <none>
 * * Output: IActorSparqlParseOutput: A parsed query in SPARQL query algebra.
 *
 * @see IActionQueryParse
 * @see IActorQueryParseOutput
 */
class ActorQueryParse extends core_1.Actor {
    /**
     * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     */
    constructor(args) {
        super(args);
    }
}
exports.ActorQueryParse = ActorQueryParse;
//# sourceMappingURL=ActorQueryParse.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-query-parse/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-query-parse/lib/ActorQueryParse.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-rdf-join-entries-sort/lib/ActorRdfJoinEntriesSort.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfJoinEntriesSort = void 0;
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
/**
 * A comunica actor for rdf-join-entries-sort events.
 *
 * Actor types:
 * * Input:  IActionRdfJoinEntriesSort:      Join entries.
 * * Test:   IActorTest:                     Test result.
 * * Output: IActorRdfJoinEntriesSortOutput: The sorted join entries.
 *
 * @see IActionRdfJoinEntriesSort
 * @see IActorTest
 * @see IActorRdfJoinEntriesSortOutput
 */
class ActorRdfJoinEntriesSort extends core_1.Actor {
    /**
     * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     */
    constructor(args) {
        super(args);
    }
}
exports.ActorRdfJoinEntriesSort = ActorRdfJoinEntriesSort;
//# sourceMappingURL=ActorRdfJoinEntriesSort.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-rdf-join-entries-sort/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-join-entries-sort/lib/ActorRdfJoinEntriesSort.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-rdf-join-selectivity/lib/ActorRdfJoinSelectivity.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfJoinSelectivity = void 0;
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
/**
 * A comunica actor for rdf-join-selectivity events.
 *
 * Actor types:
 * * Input:  IActionRdfJoinSelectivity:      Join entries.
 * * Test:   IMediatorTypeAccuracy:          The accuracy of the selectivity calculator.
 * * Output: IActorRdfJoinSelectivityOutput: The calculated join selectivity.
 *
 * @see IActionRdfJoinSelectivity
 * @see IActorRdfJoinSelectivityTest
 * @see IActorRdfJoinSelectivityOutput
 */
class ActorRdfJoinSelectivity extends core_1.Actor {
    /**
     * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     */
    constructor(args) {
        super(args);
    }
}
exports.ActorRdfJoinSelectivity = ActorRdfJoinSelectivity;
//# sourceMappingURL=ActorRdfJoinSelectivity.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-rdf-join-selectivity/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-join-selectivity/lib/ActorRdfJoinSelectivity.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-rdf-join/lib/ActorRdfJoin.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfJoin = void 0;
const bus_query_operation_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js");
const context_entries_1 = __quadstore_comunica_require__("../node_modules/@comunica/context-entries/lib/index.js");
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const rdf_string_1 = __quadstore_comunica_require__("../node_modules/rdf-string/index.js");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A comunica actor for joining 2 binding streams.
 *
 * Actor types:
 * * Input:  IActionRdfJoin:                The streams that need to be joined.
 * * Test:   IMediatorTypeJoinCoefficients: Join coefficients.
 * * Output: IActorRdfJoinOutput:           The resulting joined stream.
 *
 * @see IActionRdfJoin
 * @see IActorQueryOperationOutput
 */
class ActorRdfJoin extends core_1.Actor {
    /**
     * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     * @param options - Actor-specific join options.
     */
    constructor(args, options) {
        super(args);
        /**
         * If this actor will be logged in the debugger and physical query plan logger
         */
        this.includeInLogs = true;
        this.logicalType = options.logicalType;
        this.physicalName = options.physicalName;
        this.limitEntries = options.limitEntries ?? Number.POSITIVE_INFINITY;
        this.limitEntriesMin = options.limitEntriesMin ?? false;
        this.canHandleUndefs = options.canHandleUndefs ?? false;
    }
    /**
     * Creates a hash of the given bindings by concatenating the results of the given variables.
     * This function will not sort the variables and expects them to be in the same order for every call.
     * @param {Bindings} bindings
     * @param {string[]} variables
     * @returns {string}
     */
    static hash(bindings, variables) {
        return variables
            .filter(variable => bindings.has(variable))
            .map(variable => (0, rdf_string_1.termToString)(bindings.get(variable)))
            .join('');
    }
    /**
     * Returns an array containing all the variable names that occur in all bindings streams.
     * @param {MetadataBindings[]} metadatas An array of optional metadata objects for the entries.
     * @returns {string[]}
     */
    static overlappingVariables(metadatas) {
        const variables = metadatas.map(metadata => metadata.variables);
        let baseArray = variables[0];
        for (const array of variables.slice(1)) {
            baseArray = baseArray.filter(el => array.some(value => value.value === el.value));
        }
        return baseArray;
    }
    /**
     * Returns the variables that will occur in the joined bindings.
     * @param {MetadataBindings[]} metadatas An array of metadata objects for the entries.
     * @returns {string[]}
     */
    static joinVariables(metadatas) {
        return [...new Set(metadatas.flatMap(metadata => metadata.variables.map(variable => variable.value)))]
            .map(variable => DF.variable(variable));
    }
    /**
     * Returns the result of joining bindings, or `null` if no join is possible.
     * @param {Bindings[]} bindings
     * @returns {Bindings}
     */
    static joinBindings(...bindings) {
        if (bindings.length === 0) {
            return null;
        }
        if (bindings.length === 1) {
            return bindings[0];
        }
        let acc = bindings[0];
        for (const binding of bindings.slice(1)) {
            const merged = acc.merge(binding);
            if (!merged) {
                return null;
            }
            acc = merged;
        }
        return acc;
    }
    /**
     * Get the estimated number of items from the given metadata.
     * @param {Record<string, any>} metadata A metadata object.
     * @return {number} The estimated number of items, or `Infinity` if cardinality is falsy.
     */
    static getCardinality(metadata) {
        return metadata.cardinality;
    }
    /**
     * Obtain the metadata from all given join entries.
     * @param entries Join entries.
     */
    static async getMetadatas(entries) {
        return await Promise.all(entries.map(entry => entry.output.metadata()));
    }
    /**
     * Obtain the join entries witt metadata from all given join entries.
     * @param entries Join entries.
     */
    static async getEntriesWithMetadatas(entries) {
        const metadatas = await ActorRdfJoin.getMetadatas(entries);
        return entries.map((entry, i) => ({ ...entry, metadata: metadatas[i] }));
    }
    /**
     * Calculate the time to initiate a request for the given metadata entries.
     * @param metadatas An array of checked metadata.
     */
    static getRequestInitialTimes(metadatas) {
        return metadatas.map(metadata => metadata.pageSize ? 0 : metadata.requestTime || 0);
    }
    /**
     * Calculate the time to receive a single item for the given metadata entries.
     * @param metadatas An array of checked metadata.
     */
    static getRequestItemTimes(metadatas) {
        return metadatas
            .map(metadata => !metadata.pageSize ? 0 : (metadata.requestTime || 0) / metadata.pageSize);
    }
    /**
     * Helper function to create a new metadata object for the join result.
     * For required metadata entries that are not provided, sane defaults are calculated.
     * @param entries Join entries.
     * @param metadatas Metadata of the join entries.
     * @param context The action context.
     * @param partialMetadata Partial metadata entries.
     */
    async constructResultMetadata(entries, metadatas, context, partialMetadata = {}) {
        let cardinalityJoined;
        if (partialMetadata.cardinality) {
            cardinalityJoined = partialMetadata.cardinality;
        }
        else {
            cardinalityJoined = metadatas
                .reduce((acc, metadata) => {
                const cardinalityThis = ActorRdfJoin.getCardinality(metadata);
                return {
                    type: cardinalityThis.type === 'estimate' ? 'estimate' : acc.type,
                    value: acc.value * cardinalityThis.value,
                };
            }, { type: 'exact', value: 1 });
            cardinalityJoined.value *= (await this.mediatorJoinSelectivity.mediate({ entries, context })).selectivity;
        }
        return {
            ...partialMetadata,
            cardinality: {
                type: cardinalityJoined.type,
                value: cardinalityJoined.value,
            },
            canContainUndefs: partialMetadata.canContainUndefs ?? metadatas.some(metadata => metadata.canContainUndefs),
            variables: ActorRdfJoin.joinVariables(metadatas),
        };
    }
    /**
     * Default test function for join actors.
     * Checks whether all iterators have metadata.
     * If yes: call the abstract getIterations method, if not: return Infinity.
     * @param {IActionRdfJoin} action The input action containing the relevant iterators
     * @returns {Promise<IMediatorTypeJoinCoefficients>} The join coefficients.
     */
    async test(action) {
        // Validate logical join type
        if (action.type !== this.logicalType) {
            throw new Error(`${this.name} can only handle logical joins of type '${this.logicalType}', while '${action.type}' was given.`);
        }
        // Don't allow joining of one or zero streams
        if (action.entries.length <= 1) {
            throw new Error(`${this.name} requires at least two join entries.`);
        }
        // Check if this actor can handle the given number of streams
        if (this.limitEntriesMin ? action.entries.length < this.limitEntries : action.entries.length > this.limitEntries) {
            throw new Error(`${this.name} requires ${this.limitEntries} join entries at ${this.limitEntriesMin ? 'least' : 'most'}. The input contained ${action.entries.length}.`);
        }
        // Check if all streams are bindings streams
        for (const entry of action.entries) {
            if (entry.output.type !== 'bindings') {
                throw new Error(`Invalid type of a join entry: Expected 'bindings' but got '${entry.output.type}'`);
            }
        }
        const metadatas = await ActorRdfJoin.getMetadatas(action.entries);
        // Check if this actor can handle undefs
        if (!this.canHandleUndefs) {
            for (const metadata of metadatas) {
                if (metadata.canContainUndefs) {
                    throw new Error(`Actor ${this.name} can not join streams containing undefs`);
                }
            }
        }
        return await this.getJoinCoefficients(action, metadatas);
    }
    /**
     * Returns default input for 0 or 1 entries. Calls the getOutput function otherwise
     * @param {IActionRdfJoin} action
     * @returns {Promise<IActorQueryOperationOutput>}
     */
    async run(action) {
        // Prepare logging to physical plan
        // This must be called before getOutput, because we need to override the plan node in the context
        let parentPhysicalQueryPlanNode;
        if (action.context.has(context_entries_1.KeysInitQuery.physicalQueryPlanLogger)) {
            parentPhysicalQueryPlanNode = action.context.get(context_entries_1.KeysInitQuery.physicalQueryPlanNode);
            action.context = action.context.set(context_entries_1.KeysInitQuery.physicalQueryPlanNode, action);
        }
        // Log to physical plan
        const physicalQueryPlanLogger = action.context.get(context_entries_1.KeysInitQuery
            .physicalQueryPlanLogger);
        let planMetadata;
        if (this.includeInLogs && physicalQueryPlanLogger) {
            planMetadata = {};
            physicalQueryPlanLogger.logOperation(`join-${this.logicalType}`, this.physicalName, action, parentPhysicalQueryPlanNode, this.name, planMetadata);
        }
        // Get action output
        const { result, physicalPlanMetadata } = await this.getOutput(action);
        const metadatas = await ActorRdfJoin.getMetadatas(action.entries);
        // Fill in the physical plan metadata after determining action output
        if (planMetadata) {
            Object.assign(planMetadata, physicalPlanMetadata);
            planMetadata.cardinalities = metadatas.map(ActorRdfJoin.getCardinality);
            planMetadata.joinCoefficients = await this.getJoinCoefficients(action, metadatas);
        }
        // Cache metadata
        result.metadata = bus_query_operation_1.ActorQueryOperation.cachifyMetadata(result.metadata);
        return result;
    }
}
exports.ActorRdfJoin = ActorRdfJoin;
//# sourceMappingURL=ActorRdfJoin.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-rdf-join/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-join/lib/ActorRdfJoin.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-rdf-resolve-quad-pattern/lib/ActorRdfResolveQuadPattern.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfResolveQuadPattern = void 0;
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
/**
 * A comunica actor for rdf-resolve-quad-pattern events.
 *
 * Actor types:
 * * Input:  IActionRdfResolveQuadPattern:      A quad pattern and an optional context.
 * * Test:   <none>
 * * Output: IActorRdfResolveQuadPatternOutput: The resulting quad stream and optional metadata.
 *
 * @see IActionRdfResolveQuadPattern
 * @see IActorRdfResolveQuadPatternOutput
 */
class ActorRdfResolveQuadPattern extends core_1.Actor {
    /**
     * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     */
    constructor(args) {
        super(args);
    }
}
exports.ActorRdfResolveQuadPattern = ActorRdfResolveQuadPattern;
//# sourceMappingURL=ActorRdfResolveQuadPattern.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-rdf-resolve-quad-pattern/lib/ActorRdfResolveQuadPatternSource.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfResolveQuadPatternSource = void 0;
const ActorRdfResolveQuadPattern_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-resolve-quad-pattern/lib/ActorRdfResolveQuadPattern.js");
/**
 * A base implementation for rdf-resolve-quad-pattern events
 * that wraps around an {@link IQuadSource}.
 *
 * @see IQuadSource
 */
class ActorRdfResolveQuadPatternSource extends ActorRdfResolveQuadPattern_1.ActorRdfResolveQuadPattern {
    constructor(args) {
        super(args);
    }
    async test(action) {
        return true;
    }
    async run(action) {
        const source = await this.getSource(action.context, action.pattern);
        return await this.getOutput(source, action.pattern, action.context);
    }
    /**
     * Get the output of the given action on a source.
     * @param {IQuadSource} source A quad source, possibly lazy.
     * @param {Algebra.Operation} operation The operation to apply.
     * @param ActionContext context Optional context data.
     * @return {Promise<IActorRdfResolveQuadPatternOutput>} A promise that resolves to a hash containing
     *                                                      a data RDFJS stream.
     */
    async getOutput(source, pattern, context) {
        // Create data stream
        const data = source.match(pattern.subject, pattern.predicate, pattern.object, pattern.graph);
        return { data };
    }
}
exports.ActorRdfResolveQuadPatternSource = ActorRdfResolveQuadPatternSource;
//# sourceMappingURL=ActorRdfResolveQuadPatternSource.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-rdf-resolve-quad-pattern/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-resolve-quad-pattern/lib/ActorRdfResolveQuadPattern.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-resolve-quad-pattern/lib/ActorRdfResolveQuadPatternSource.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-resolve-quad-pattern/lib/utils.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-rdf-resolve-quad-pattern/lib/utils.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasContextSingleSourceOfType = exports.hasContextSingleSource = exports.getContextSourceUrl = exports.getContextSourceFirst = exports.getContextSource = exports.getContextSources = exports.getDataSourceContext = exports.getDataSourceValue = exports.getDataSourceType = exports.isDataSourceRawType = void 0;
const context_entries_1 = __quadstore_comunica_require__("../node_modules/@comunica/context-entries/lib/index.js");
/**
 * Check if the given data source is a string or RDF store.
 * @param dataSource A data source.
 */
function isDataSourceRawType(dataSource) {
    return typeof dataSource === 'string' || 'match' in dataSource;
}
exports.isDataSourceRawType = isDataSourceRawType;
/**
 * Get the data source type.
 * @param dataSource A data source.
 */
function getDataSourceType(dataSource) {
    if (typeof dataSource === 'string') {
        return '';
    }
    return 'match' in dataSource ? 'rdfjsSource' : dataSource.type;
}
exports.getDataSourceType = getDataSourceType;
/**
 * Get the data source value.
 * @param dataSource A data source.
 */
function getDataSourceValue(dataSource) {
    return isDataSourceRawType(dataSource) ? dataSource : dataSource.value;
}
exports.getDataSourceValue = getDataSourceValue;
/**
 * Get the data source from the given context.
 * @param {ActionContext} context An optional context.
 * @param {IDataSource} dataSource The source or undefined.
 */
function getDataSourceContext(dataSource, context) {
    if (typeof dataSource === 'string' || 'match' in dataSource || !dataSource.context) {
        return context;
    }
    return context.merge(dataSource.context);
}
exports.getDataSourceContext = getDataSourceContext;
/**
 * Get the sources from the given context.
 * @param {ActionContext} context An optional context.
 * @return {IDataSource[]} The array of sources or undefined.
 */
function getContextSources(context) {
    return context.get(context_entries_1.KeysRdfResolveQuadPattern.sources);
}
exports.getContextSources = getContextSources;
/**
 * Get the source from the given context.
 * @param {ActionContext} context An optional context.
 * @return {IDataSource} The source or undefined.
 */
function getContextSource(context) {
    return context.get(context_entries_1.KeysRdfResolveQuadPattern.source);
}
exports.getContextSource = getContextSource;
/**
 * Get the single source if the context contains just a single source.
 * This will check both the source and sources context entries.
 * @param {IActionContext} context A context, can be null.
 * @return {IDataSource} The single datasource or undefined.
 */
function getContextSourceFirst(context) {
    if (context.has(context_entries_1.KeysRdfResolveQuadPattern.source)) {
        // If the single source is set
        return context.get(context_entries_1.KeysRdfResolveQuadPattern.source);
    }
    // If multiple sources are set
    const datasources = context.get(context_entries_1.KeysRdfResolveQuadPattern.sources);
    if (datasources?.length === 1) {
        return datasources[0];
    }
}
exports.getContextSourceFirst = getContextSourceFirst;
/**
 * Get the source's raw URL value from the given context.
 * @param {IDataSource} source A source.
 * @return {string} The URL or null.
 */
function getContextSourceUrl(source) {
    if (source) {
        let fileUrl = getDataSourceValue(source);
        if (typeof fileUrl === 'string') {
            // Remove hashes from source
            const hashPosition = fileUrl.indexOf('#');
            if (hashPosition >= 0) {
                fileUrl = fileUrl.slice(0, hashPosition);
            }
            return fileUrl;
        }
    }
}
exports.getContextSourceUrl = getContextSourceUrl;
/**
 * Check if the given context has a single source.
 * @param {ActionContext} context An optional context.
 * @return {boolean} If the given context has a single source of the given type.
 */
function hasContextSingleSource(context) {
    const source = getContextSource(context);
    return Boolean(source && (isDataSourceRawType(source) || source.value));
}
exports.hasContextSingleSource = hasContextSingleSource;
/**
 * Check if the given context has a single source of the given type.
 * @param {string} requiredType The required source type name.
 * @param {ActionContext} context An optional context.
 * @return {boolean} If the given context has a single source of the given type.
 */
function hasContextSingleSourceOfType(requiredType, context) {
    const source = getContextSource(context);
    return Boolean(source && getDataSourceType(source) === requiredType && getDataSourceValue(source));
}
exports.hasContextSingleSourceOfType = hasContextSingleSourceOfType;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-rdf-update-quads/lib/ActorRdfUpdateQuads.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfUpdateQuads = void 0;
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
/**
 * A comunica actor for rdf-update-quads events.
 *
 * Actor types:
 * * Input:  IActionRdfUpdateQuads:      Quad insertion and deletion streams.
 * * Test:   <none>
 * * Output: IActorRdfUpdateQuadsOutput: A promise resolving when the update operation is done.
 *
 * @see IActionRdfUpdateQuads
 * @see IActorRdfUpdateQuadsOutput
 */
class ActorRdfUpdateQuads extends core_1.Actor {
    /**
     * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     */
    constructor(args) {
        super(args);
    }
}
exports.ActorRdfUpdateQuads = ActorRdfUpdateQuads;
//# sourceMappingURL=ActorRdfUpdateQuads.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-rdf-update-quads/lib/ActorRdfUpdateQuadsDestination.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActorRdfUpdateQuadsDestination = exports.deskolemize = exports.deskolemizeStream = void 0;
const actor_rdf_resolve_quad_pattern_federated_1 = __quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-resolve-quad-pattern-federated/lib/index.js");
const context_entries_1 = __quadstore_comunica_require__("../node_modules/@comunica/context-entries/lib/index.js");
const ActorRdfUpdateQuads_1 = __quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-update-quads/lib/ActorRdfUpdateQuads.js");
function deskolemizeStream(stream, id) {
    return stream?.map(quad => actor_rdf_resolve_quad_pattern_federated_1.FederatedQuadSource.deskolemizeQuad(quad, id));
}
exports.deskolemizeStream = deskolemizeStream;
function deskolemize(action) {
    const destination = action.context.get(context_entries_1.KeysRdfUpdateQuads.destination);
    const id = action.context.get(context_entries_1.KeysRdfResolveQuadPattern.sourceIds)?.get(destination);
    if (!id) {
        return action;
    }
    return {
        ...action,
        quadStreamInsert: deskolemizeStream(action.quadStreamInsert, id),
        quadStreamDelete: deskolemizeStream(action.quadStreamDelete, id),
    };
}
exports.deskolemize = deskolemize;
/**
 * A base implementation for rdf-update-quads events
 * that wraps around an {@link IQuadDestination}.
 *
 * @see IQuadDestination
 */
class ActorRdfUpdateQuadsDestination extends ActorRdfUpdateQuads_1.ActorRdfUpdateQuads {
    async test(action) {
        return true;
    }
    async run(action) {
        const destination = await this.getDestination(action.context);
        return await this.getOutput(destination, deskolemize(action), action.context);
    }
    /**
     * Get the output of the given action on a destination.
     * @param {IQuadDestination} destination A quad destination, possibly lazy.
     * @param {IActionRdfUpdateQuads} action The action.
     * @param {ActionContext} context Optional context data.
     */
    async getOutput(destination, action, context) {
        const execute = () => Promise.all([
            action.quadStreamInsert ? destination.insert(action.quadStreamInsert) : Promise.resolve(),
            action.quadStreamDelete ? destination.delete(action.quadStreamDelete) : Promise.resolve(),
            action.deleteGraphs ?
                destination.deleteGraphs(action.deleteGraphs.graphs, action.deleteGraphs.requireExistence, action.deleteGraphs.dropGraphs) :
                Promise.resolve(),
            action.createGraphs ?
                destination.createGraphs(action.createGraphs.graphs, action.createGraphs.requireNonExistence) :
                Promise.resolve(),
        ]).then(() => {
            // Return void
        });
        return { execute };
    }
}
exports.ActorRdfUpdateQuadsDestination = ActorRdfUpdateQuadsDestination;
//# sourceMappingURL=ActorRdfUpdateQuadsDestination.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-rdf-update-quads/lib/IQuadDestination.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateHttpResponse = void 0;
const bus_http_1 = __quadstore_comunica_require__("./require-empty.js");
const stringifyStream = __quadstore_comunica_require__("../node_modules/stream-to-string/index.js");
/**
 * Check if the http response is valid, and throw an error if not.
 * @param url The original URL that was to be updated.
 * @param httpResponse The update response.
 */
async function validateHttpResponse(url, httpResponse) {
    // Check if update was successful
    if (httpResponse.status >= 400) {
        // Consume the body, to avoid process to hang
        let bodyString = 'empty response';
        if (httpResponse.body) {
            const responseStream = bus_http_1.ActorHttp.toNodeReadable(httpResponse.body);
            bodyString = await stringifyStream(responseStream);
        }
        throw new Error(`Could not update ${url} (HTTP status ${httpResponse.status}):\n${bodyString}`);
    }
    // Close response body, as we don't need it
    await httpResponse.body?.cancel();
}
exports.validateHttpResponse = validateHttpResponse;
//# sourceMappingURL=IQuadDestination.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-rdf-update-quads/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-update-quads/lib/ActorRdfUpdateQuads.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-update-quads/lib/ActorRdfUpdateQuadsDestination.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-update-quads/lib/IQuadDestination.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/bus-rdf-update-quads/lib/utils.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/bus-rdf-update-quads/lib/utils.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getContextDestinationUrl = exports.getContextDestinationFirst = exports.getContextDestination = exports.getDataDestinationContext = exports.getDataDestinationValue = exports.getDataDestinationType = exports.isDataDestinationRawType = void 0;
const context_entries_1 = __quadstore_comunica_require__("../node_modules/@comunica/context-entries/lib/index.js");
/**
 * Check if the given data destination is a string or RDF store.
 * @param dataDestination A data destination.
 */
function isDataDestinationRawType(dataDestination) {
    return typeof dataDestination === 'string' || 'remove' in dataDestination;
}
exports.isDataDestinationRawType = isDataDestinationRawType;
/**
 * Get the data destination type.
 * @param dataDestination A data destination.
 */
function getDataDestinationType(dataDestination) {
    if (typeof dataDestination === 'string') {
        return '';
    }
    return 'remove' in dataDestination ? 'rdfjsStore' : dataDestination.type;
}
exports.getDataDestinationType = getDataDestinationType;
/**
 * Get the data destination value.
 * @param dataDestination A data destination.
 */
function getDataDestinationValue(dataDestination) {
    return isDataDestinationRawType(dataDestination) ? dataDestination : dataDestination.value;
}
exports.getDataDestinationValue = getDataDestinationValue;
/**
 * Get the context of the given destination, merged with the given context.
 * @param dataDestination A data destination.
 * @param context A context to merge with.
 */
function getDataDestinationContext(dataDestination, context) {
    if (typeof dataDestination === 'string' || 'remove' in dataDestination || !dataDestination.context) {
        return context;
    }
    return context.merge(dataDestination.context);
}
exports.getDataDestinationContext = getDataDestinationContext;
/**
 * Get the source destination from the given context.
 * @param {ActionContext} context An optional context.
 * @return {IDataDestination} The destination or undefined.
 */
function getContextDestination(context) {
    return context.get(context_entries_1.KeysRdfUpdateQuads.destination);
}
exports.getContextDestination = getContextDestination;
/**
 * Get the single destination if the context contains just a single destination.
 * @param {ActionContext} context A context, can be null.
 * @return {IDataDestination} The single datadestination or undefined.
 */
function getContextDestinationFirst(context) {
    if (context.has(context_entries_1.KeysRdfUpdateQuads.destination)) {
        // If the single destination is set
        return context.get(context_entries_1.KeysRdfUpdateQuads.destination);
    }
}
exports.getContextDestinationFirst = getContextDestinationFirst;
/**
 * Get the destination's raw URL value from the given context.
 * @param {IDataDestination} destination A destination.
 * @return {string} The URL or undefined.
 */
function getContextDestinationUrl(destination) {
    if (destination) {
        let fileUrl = getDataDestinationValue(destination);
        if (typeof fileUrl === 'string') {
            // Remove hashes from source
            const hashPosition = fileUrl.indexOf('#');
            if (hashPosition >= 0) {
                fileUrl = fileUrl.slice(0, hashPosition);
            }
            return fileUrl;
        }
    }
}
exports.getContextDestinationUrl = getContextDestinationUrl;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "../node_modules/@comunica/context-entries/lib/Keys.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeysRdfUpdateQuads = exports.KeysRdfResolveQuadPattern = exports.KeysRdfParseHtmlScript = exports.KeysRdfParseJsonLd = exports.KeysQueryOperation = exports.KeysInitQuery = exports.KeysHttpProxy = exports.KeysHttpMemento = exports.KeysHttp = exports.KeysCore = void 0;
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
/**
 * When adding entries to this file, also add a shortcut for them in the contextKeyShortcuts TSDoc comment in
 * ActorIniQueryBase in @comunica/actor-init-query if it makes sense to use this entry externally.
 * Also, add this shortcut to IQueryContextCommon in @comunica/types.
 */
exports.KeysCore = {
    // We create the core context keys in @comunica/core to avoid a cyclic dependency
    /**
     * A logger instance.
     */
    log: core_1.CONTEXT_KEY_LOGGER,
};
exports.KeysHttp = {
    /**
     * Include credentials flags.
     */
    includeCredentials: new core_1.ActionContextKey('@comunica/bus-http:include-credentials'),
    /**
     * Authentication for a source as a "username:password"-pair.
     */
    auth: new core_1.ActionContextKey('@comunica/bus-http:auth'),
    /**
     * Fetch function implementation.
     */
    fetch: new core_1.ActionContextKey('@comunica/bus-http:fetch'),
    /**
     * HTTP request timeout in milliseconds.
     */
    httpTimeout: new core_1.ActionContextKey('@comunica/bus-http:http-timeout'),
    /**
     * Makes the HTTP timeout not only apply until the response starts streaming in
     * but until the response is fully consumed.
     */
    httpBodyTimeout: new core_1.ActionContextKey('@comunica/bus-http:http-body-timeout'),
};
exports.KeysHttpMemento = {
    /**
     * The desired datetime for Memento datetime-negotiation.
     */
    datetime: new core_1.ActionContextKey('@comunica/actor-http-memento:datetime'),
};
exports.KeysHttpProxy = {
    /**
     * Interface.
     */
    httpProxyHandler: new core_1.ActionContextKey('@comunica/actor-http-proxy:httpProxyHandler'),
};
exports.KeysInitQuery = {
    /**
     * Variables that have to be pre-bound to values in the query.
     */
    initialBindings: new core_1.ActionContextKey('@comunica/actor-init-query:initialBindings'),
    /**
     * The provided query's format.
     * Defaults to { language: 'sparql', version: '1.1' }
     */
    queryFormat: new core_1.ActionContextKey('@comunica/actor-init-query:queryFormat'),
    /**
     * Which GraphQL bindings should be singularized.
     */
    graphqlSingularizeVariables: new core_1.ActionContextKey('@comunica/actor-init-query:singularizeVariables'),
    /**
     * If HTTP and parsing failures are ignored.
     */
    lenient: new core_1.ActionContextKey('@comunica/actor-init-query:lenient'),
    /**
     * The original query string.
     */
    queryString: new core_1.ActionContextKey('@comunica/actor-init-query:queryString'),
    /**
     * The original parsed query.
     */
    query: new core_1.ActionContextKey('@comunica/actor-init-query:query'),
    /**
     * The query's base IRI.
     */
    baseIRI: new core_1.ActionContextKey('@comunica/actor-init-query:baseIRI'),
    /**
     * A timestamp representing the current time.
     *                 This is required for certain SPARQL operations such as NOW().
     */
    queryTimestamp: new core_1.ActionContextKey('@comunica/actor-init-query:queryTimestamp'),
    /**
     * @range {functionNamedNode: RDF.NamedNode) => ((args: RDF.Term[]) => Promise<RDF.Term>) | undefined}
     * Extension function creator for a given function IRI.
     * Returned value should be an async function implementation.
     * Undefined may be returned if no implementation exists for the given function IRI.
     *
     * The dictionary-based extensionFunctions context entry may be used instead, but not simultaneously.
     */
    extensionFunctionCreator: new core_1.ActionContextKey('@comunica/actor-init-query:extensionFunctionCreator'),
    /**
     * Dictionary of extension functions.
     * Key is the IRI of the function, and value is the async function implementation.
     *
     * The callback-based extensionFunctionCreator context entry may be used instead, but not simultaneously.
     */
    extensionFunctions: new core_1.ActionContextKey('@comunica/actor-init-query:extensionFunctions'),
    /**
     * Enables manipulation of the CLI arguments and their processing.
     */
    cliArgsHandlers: new core_1.ActionContextKey('@comunica/actor-init-query:cliArgsHandlers'),
    /**
     * Explain mode of the query. Can be 'parsed', 'logical', or 'physical'.
     */
    explain: new core_1.ActionContextKey('@comunica/actor-init-query:explain'),
    /**
     * Logs the used physical operators
     */
    physicalQueryPlanLogger: new core_1.ActionContextKey('@comunica/actor-init-query:physicalQueryPlanLogger'),
    /**
     * The current physical operator within the query plan.
     *              This is used to pass parent-child relationships for invoking the query plan logger.
     */
    physicalQueryPlanNode: new core_1.ActionContextKey('@comunica/actor-init-query:physicalQueryPlanNode'),
    /**
     * A JSON-LD context
     */
    jsonLdContext: new core_1.ActionContextKey('@context'),
};
exports.KeysQueryOperation = {
    /**
     * Context entry for the current query operation.
     */
    operation: new core_1.ActionContextKey('@comunica/bus-query-operation:operation'),
    /**
     * @type {any} The metadata from the left streams within a join operation.
     */
    joinLeftMetadata: new core_1.ActionContextKey('@comunica/bus-query-operation:joinLeftMetadata'),
    /**
     * An array of metadata from the right streams within a join operation.
     */
    joinRightMetadatas: new core_1.ActionContextKey('@comunica/bus-query-operation:joinRightMetadatas'),
    /**
     * Indicates the bindings that were used to bind the operation.
     */
    joinBindings: new core_1.ActionContextKey('@comunica/bus-query-operation:joinBindings'),
    /**
     * Flag for indicating that only read operations are allowed, defaults to false.
     */
    readOnly: new core_1.ActionContextKey('@comunica/bus-query-operation:readOnly'),
    /**
     * An internal context entry to mark that a property path with arbitrary length and a distinct key is being processed.
     */
    isPathArbitraryLengthDistinctKey: new core_1.ActionContextKey('@comunica/bus-query-operation:isPathArbitraryLengthDistinct'),
    /**
     * An indicator that the stream will be limited to the given number of elements afterwards.
     */
    limitIndicator: new core_1.ActionContextKey('@comunica/bus-query-operation:limitIndicator'),
    /**
     * If the default graph should also contain the union of all named graphs.
     */
    unionDefaultGraph: new core_1.ActionContextKey('@comunica/bus-query-operation:unionDefaultGraph'),
};
exports.KeysRdfParseJsonLd = {
    /**
     * @range {IDocumentLoader}
     */
    documentLoader: new core_1.ActionContextKey('@comunica/actor-rdf-parse-jsonld:documentLoader'),
    /**
     * @range {boolean}
     */
    strictValues: new core_1.ActionContextKey('@comunica/actor-rdf-parse-jsonld:strictValues'),
    /**
     * @range {Record<string, any>}
     */
    parserOptions: new core_1.ActionContextKey('@comunica/actor-rdf-parse-jsonld:parserOptions'),
};
exports.KeysRdfParseHtmlScript = {
    /**
     * An internal context flag to determine if the engine is already processing an HTML script tag.
     */
    processingHtmlScript: new core_1.ActionContextKey('@comunica/actor-rdf-parse-html-script:processingHtmlScript'),
    /**
     * If all HTML script tags must be considered.
     */
    extractAllScripts: new core_1.ActionContextKey('extractAllScripts'),
};
exports.KeysRdfResolveQuadPattern = {
    /**
     * Data sources.
     */
    sources: new core_1.ActionContextKey('@comunica/bus-rdf-resolve-quad-pattern:sources'),
    /**
     * A data source.
     */
    source: new core_1.ActionContextKey('@comunica/bus-rdf-resolve-quad-pattern:source'),
    /**
     * A map containing unique IDs for each source
     */
    sourceIds: new core_1.ActionContextKey('@comunica/bus-rdf-resolve-quad-pattern:sourceIds'),
};
exports.KeysRdfUpdateQuads = {
    /**
     * A data destination.
     */
    destination: new core_1.ActionContextKey('@comunica/bus-rdf-update-quads:destination'),
};
//# sourceMappingURL=Keys.js.map

/***/ }),

/***/ "../node_modules/@comunica/context-entries/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/context-entries/lib/Keys.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/core/lib/ActionContext.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActionContextKey = exports.ActionContext = void 0;
const immutable_1 = __quadstore_comunica_require__("../packages/immutable/dist/index.js");
/**
 * Implementation of {@link IActionContext} using Immutable.js.
 */
class ActionContext {
    constructor(data = {}) {
        this.map = (0, immutable_1.Map)(data);
    }
    /**
     * Will only set the value if the key is not already set.
     */
    setDefault(key, value) {
        return this.has(key) ? this : this.set(key, value);
    }
    set(key, value) {
        return this.setRaw(key.name, value);
    }
    setRaw(key, value) {
        return new ActionContext(this.map.set(key, value));
    }
    delete(key) {
        return new ActionContext(this.map.delete(key.name));
    }
    get(key) {
        return this.getRaw(key.name);
    }
    getRaw(key) {
        return this.map.get(key);
    }
    getSafe(key) {
        if (!this.has(key)) {
            throw new Error(`Context entry ${key.name} is required but not available`);
        }
        return this.get(key);
    }
    has(key) {
        return this.hasRaw(key.name);
    }
    hasRaw(key) {
        return this.map.has(key);
    }
    merge(...contexts) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this
        let context = this;
        for (const source of contexts) {
            for (const key of source.keys()) {
                context = context.set(key, source.get(key));
            }
        }
        return context;
    }
    keys() {
        return [...this.map.keys()]
            .map(keyName => new ActionContextKey(keyName));
    }
    toJS() {
        return this.map.toJS();
    }
    toString() {
        return `ActionContext(${JSON.stringify(this.map.toJS())})`;
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return `ActionContext(${JSON.stringify(this.map.toJS(), null, '  ')})`;
    }
    /**
     * Convert the given object to an action context object if it is not an action context object yet.
     * If it already is an action context object, return the object as-is.
     * @param maybeActionContext An action context or record.
     * @return {ActionContext} An action context object.
     */
    static ensureActionContext(maybeActionContext) {
        return maybeActionContext instanceof ActionContext ?
            maybeActionContext :
            new ActionContext((0, immutable_1.Map)(maybeActionContext || {}));
    }
}
exports.ActionContext = ActionContext;
/**
 * Simple implementation of {@link IActionContextKey}.
 */
class ActionContextKey {
    constructor(name) {
        this.name = name;
    }
}
exports.ActionContextKey = ActionContextKey;
//# sourceMappingURL=ActionContext.js.map

/***/ }),

/***/ "../node_modules/@comunica/core/lib/ActionObserver.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActionObserver = void 0;
/**
 * An ActionObserver can passively listen to {@link Actor#run} inputs and outputs for all actors on a certain bus.
 *
 * ActionObserver should not edit inputs and outputs,
 * they should be considered immutable.
 *
 * @see Actor
 * @see Bus
 *
 * @template I The input type of an actor.
 * @template O The output type of an actor.
 */
class ActionObserver {
    /**
     * All enumerable properties from the `args` object are inherited to this observer.
     *
     * The observer will NOT automatically subscribe to the given bus when this constructor is called.
     *
     * @param {IActionObserverArgs<I extends IAction, O extends IActorOutput>} args Arguments object
     * @throws When required arguments are missing.
     */
    constructor(args) {
        Object.assign(this, args);
    }
}
exports.ActionObserver = ActionObserver;
//# sourceMappingURL=ActionObserver.js.map

/***/ }),

/***/ "../node_modules/@comunica/core/lib/Actor.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Actor = void 0;
const ContextEntries_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/ContextEntries.js");
/**
 * An actor can act on messages of certain types and provide output of a certain type.
 *
 * The flow of an actor is as follows:
 * 1. Send a message to {@link Actor#test} to test if an actor can run that action.
 * 2. If the actor can reply to the message, let the actor run the action using {@link Actor#run}.
 *
 * An actor is typically subscribed to a bus,
 * using which the applicability to an action can be tested.
 *
 * @see Bus
 *
 * @template I The input type of an actor.
 * @template T The test type of an actor.
 * @template O The output type of an actor.
 */
class Actor {
    /**
     * All enumerable properties from the `args` object are inherited to this actor.
     *
     * The actor will subscribe to the given bus when this constructor is called.
     *
     * @param {IActorArgs<I extends IAction, T extends IActorTest, O extends IActorOutput>} args Arguments object
     * @param {string} args.name The name for this actor.
     * @param {Bus<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest, O extends IActorOutput>} args.bus
     *        The bus this actor subscribes to.
     * @throws When required arguments are missing.
     */
    constructor(args) {
        this.beforeActors = [];
        Object.assign(this, args);
        this.bus.subscribe(this);
        if (this.beforeActors.length > 0) {
            this.bus.addDependencies(this, this.beforeActors);
        }
    }
    /**
     * Get the logger from the given context.
     * @param {ActionContext} context An optional context.
     * @return {Logger} The logger or undefined.
     */
    static getContextLogger(context) {
        return context.get(ContextEntries_1.CONTEXT_KEY_LOGGER);
    }
    /**
     * Run the given action on this actor
     * AND invokes the {@link Bus#onRun} method.
     *
     * @param {I} action The action to run.
     * @return {Promise<T>} A promise that resolves to the run result.
     */
    runObservable(action) {
        const output = this.run(action);
        this.bus.onRun(this, action, output);
        return output;
    }
    /**
     * Initialize this actor.
     * This should be used for doing things that take a while,
     * such as opening files.
     *
     * @return {Promise<void>} A promise that resolves when the actor has been initialized.
     */
    async initialize() {
        return true;
    }
    /**
     * Deinitialize this actor.
     * This should be used for cleaning up things when the application is shut down,
     * such as closing files and removing temporary files.
     *
     * @return {Promise<void>} A promise that resolves when the actor has been deinitialized.
     */
    async deinitialize() {
        return true;
    }
    /* Proxy methods for the (optional) logger that is defined in the context */
    getDefaultLogData(context, data) {
        const dataActual = data ? data() : {};
        dataActual.actor = this.name;
        return dataActual;
    }
    logTrace(context, message, data) {
        const logger = Actor.getContextLogger(context);
        if (logger) {
            logger.trace(message, this.getDefaultLogData(context, data));
        }
    }
    logDebug(context, message, data) {
        const logger = Actor.getContextLogger(context);
        if (logger) {
            logger.debug(message, this.getDefaultLogData(context, data));
        }
    }
    logInfo(context, message, data) {
        const logger = Actor.getContextLogger(context);
        if (logger) {
            logger.info(message, this.getDefaultLogData(context, data));
        }
    }
    logWarn(context, message, data) {
        const logger = Actor.getContextLogger(context);
        if (logger) {
            logger.warn(message, this.getDefaultLogData(context, data));
        }
    }
    logError(context, message, data) {
        const logger = Actor.getContextLogger(context);
        if (logger) {
            logger.error(message, this.getDefaultLogData(context, data));
        }
    }
    logFatal(context, message, data) {
        const logger = Actor.getContextLogger(context);
        if (logger) {
            logger.fatal(message, this.getDefaultLogData(context, data));
        }
    }
}
exports.Actor = Actor;
//# sourceMappingURL=Actor.js.map

/***/ }),

/***/ "../node_modules/@comunica/core/lib/Bus.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Bus = void 0;
/**
 * A publish-subscribe bus for sending actions to actors
 * to test whether or not they can run an action.
 *
 * This bus does not run the action itself,
 * for that a {@link Mediator} can be used.
 *
 * @see Actor
 * @see Mediator
 *
 * @template A The actor type that can subscribe to the sub.
 * @template I The input type of an actor.
 * @template T The test type of an actor.
 * @template O The output type of an actor.
 */
class Bus {
    /**
     * All enumerable properties from the `args` object are inherited to this bus.
     *
     * @param {IBusArgs} args Arguments object
     * @param {string} args.name The name for the bus
     * @throws When required arguments are missing.
     */
    constructor(args) {
        this.actors = [];
        this.observers = [];
        // Mapping from dependency (after) to dependents (before)
        this.dependencyLinks = new Map();
        Object.assign(this, args);
    }
    /**
     * Subscribe the given actor to the bus.
     * After this, the given actor can be unsubscribed from the bus by calling {@link Bus#unsubscribe}.
     *
     * An actor that is subscribed multiple times will exist that amount of times in the bus.
     *
     * @param {A} actor The actor to subscribe.
     */
    subscribe(actor) {
        this.actors.push(actor);
        this.reorderForDependencies();
    }
    /**
     * Subscribe the given observer to the bus.
     * After this, the given observer can be unsubscribed from the bus by calling {@link Bus#unsubscribeObserver}.
     *
     * An observer that is subscribed multiple times will exist that amount of times in the bus.
     *
     * @param {ActionObserver<I, O>} observer The observer to subscribe.
     */
    subscribeObserver(observer) {
        this.observers.push(observer);
    }
    /**
     * Unsubscribe the given actor from the bus.
     *
     * An actor that is subscribed multiple times will be unsubscribed only once.
     *
     * @param {A} actor The actor to unsubscribe
     * @return {boolean} If the given actor was successfully unsubscribed,
     *         otherwise it was not subscribed before.
     */
    unsubscribe(actor) {
        const index = this.actors.indexOf(actor);
        if (index >= 0) {
            this.actors.splice(index, 1);
            return true;
        }
        return false;
    }
    /**
     * Unsubscribe the given observer from the bus.
     *
     * An observer that is subscribed multiple times will be unsubscribed only once.
     *
     * @param {ActionObserver<I, O>} observer The observer to unsubscribe.
     * @return {boolean} If the given observer was successfully unsubscribed,
     *         otherwise it was not subscribed before.
     */
    unsubscribeObserver(observer) {
        const index = this.observers.indexOf(observer);
        if (index >= 0) {
            this.observers.splice(index, 1);
            return true;
        }
        return false;
    }
    /**
     * Publish an action to all actors in the bus to test if they can run the action.
     *
     * @param {I} action An action to publish
     * @return {IActorReply<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest,
     *         O extends IActorOutput>[]}
     *         An array of reply objects. Each object contains a reference to the actor,
     *         and a promise to its {@link Actor#test} result.
     */
    publish(action) {
        return this.actors.map((actor) => ({ actor, reply: actor.test(action) }));
    }
    /**
     * Invoked when an action was run by an actor.
     *
     * @param actor               The action on which the {@link Actor#run} method was invoked.
     * @param {I}          action The original action input.
     * @param {Promise<O>} output A promise resolving to the final action output.
     */
    onRun(actor, action, output) {
        for (const observer of this.observers) {
            observer.onRun(actor, action, output);
        }
    }
    /**
     * Indicate that the given actor has the given actor dependencies.
     *
     * This will ensure that the given actor will be present in the bus *before* the given dependencies.
     *
     * @param {A} dependent A dependent actor that will be placed before the given actors.
     * @param {A[]} dependencies Actor dependencies that will be placed after the given actor.
     */
    addDependencies(dependent, dependencies) {
        for (const dependency of dependencies) {
            let existingDependencies = this.dependencyLinks.get(dependency);
            if (!existingDependencies) {
                existingDependencies = [];
                this.dependencyLinks.set(dependency, existingDependencies);
            }
            existingDependencies.push(dependent);
        }
        this.reorderForDependencies();
    }
    /**
     * Reorder the bus based on all present dependencies.
     */
    reorderForDependencies() {
        if (this.dependencyLinks.size > 0) {
            const actorsAfter = [];
            // Temporarily remove all actors that have dependencies
            for (const actorAfter of this.dependencyLinks.keys()) {
                const dependentPos = this.actors.indexOf(actorAfter);
                if (dependentPos >= 0) {
                    this.actors.splice(dependentPos, 1);
                    actorsAfter.push(actorAfter);
                }
            }
            // Iteratively append actors based on the first dependency link
            // that has all of its dependencies available in the array
            while (actorsAfter.length > 0) {
                // Find the first actor that has all of its dependencies available.
                let activeActorAfterId = -1;
                for (let i = 0; i < actorsAfter.length; i++) {
                    let validLink = true;
                    for (const dependency of this.dependencyLinks.get(actorsAfter[i])) {
                        if (!this.actors.includes(dependency) && actorsAfter.includes(dependency)) {
                            validLink = false;
                            break;
                        }
                    }
                    if (validLink) {
                        activeActorAfterId = i;
                        break;
                    }
                }
                // If none of the pending links are possible, there must be a cyclic dependency
                if (activeActorAfterId < 0) {
                    throw new Error(`Cyclic dependency links detected in bus ${this.name}`);
                }
                // The dependent may not be available (yet), so we don't add it to the array (yet).
                const activeActorAfter = actorsAfter.splice(activeActorAfterId, 1)[0];
                this.actors.push(activeActorAfter);
            }
        }
    }
}
exports.Bus = Bus;
//# sourceMappingURL=Bus.js.map

/***/ }),

/***/ "../node_modules/@comunica/core/lib/BusIndexed.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BusIndexed = void 0;
const Bus_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/Bus.js");
/**
 * A bus that indexes identified actors,
 * so that actions with a corresponding identifier can be published more efficiently.
 *
 * Multiple actors with the same identifier can be subscribed.
 *
 * If actors or actions do not have a valid identifier,
 * then this will fallback to the normal bus behaviour.
 *
 * @see Bus
 *
 * @template A The actor type that can subscribe to the sub.
 * @template I The input type of an actor.
 * @template T The test type of an actor.
 * @template O The output type of an actor.
 */
class BusIndexed extends Bus_1.Bus {
    /**
     * All enumerable properties from the `args` object are inherited to this bus.
     *
     * @param {IBusIndexedArgs} args Arguments object
     * @param {string} args.name The name for the bus
     * @throws When required arguments are missing.
     */
    constructor(args) {
        super(args);
        this.actorsIndex = {};
    }
    subscribe(actor) {
        const actorId = this.getActorIdentifier(actor) || '_undefined_';
        let actors = this.actorsIndex[actorId];
        if (!actors) {
            actors = this.actorsIndex[actorId] = [];
        }
        actors.push(actor);
        super.subscribe(actor);
    }
    unsubscribe(actor) {
        const actorId = this.getActorIdentifier(actor) || '_undefined_';
        const actors = this.actorsIndex[actorId];
        if (actors) {
            const i = actors.indexOf(actor);
            if (i >= 0) {
                actors.splice(i, 1);
            }
            if (actors.length === 0) {
                delete this.actorsIndex[actorId];
            }
        }
        return super.unsubscribe(actor);
    }
    publish(action) {
        const actionId = this.getActionIdentifier(action);
        if (actionId) {
            const actors = [...this.actorsIndex[actionId] || [], ...this.actorsIndex._undefined_ || []];
            return actors.map((actor) => ({ actor, reply: actor.test(action) }));
        }
        return super.publish(action);
    }
    getActorIdentifier(actor) {
        return this.actorIdentifierFields.reduce((object, field) => object[field], actor);
    }
    getActionIdentifier(action) {
        return this.actionIdentifierFields.reduce((object, field) => object[field], action);
    }
}
exports.BusIndexed = BusIndexed;
//# sourceMappingURL=BusIndexed.js.map

/***/ }),

/***/ "../node_modules/@comunica/core/lib/ContextEntries.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CONTEXT_KEY_LOGGER = void 0;
const ActionContext_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/ActionContext.js");
exports.CONTEXT_KEY_LOGGER = new ActionContext_1.ActionContextKey('@comunica/core:log');
//# sourceMappingURL=ContextEntries.js.map

/***/ }),

/***/ "../node_modules/@comunica/core/lib/Mediator.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Mediator = void 0;
/**
 * A mediator can mediate an action over a bus of actors.
 *
 * It does the following:
 * 1. Accepts an action in {@link Mediator#mediate}.
 * 2. Sends the action to the bus to test its applicability on all actors.
 * 3. It _mediates_ over these test results.
 * 4. It selects the _best_ actor.
 * 5. The action is run by the _best_ actor, and the result if returned.
 *
 * The _mediates_ and _best_ parts are filled in by subclasses of this abstract Mediator class.
 *
 * @template A The type of actor to mediator over.
 * @template I The input type of an actor.
 * @template T The test type of an actor.
 * @template O The output type of an actor.
 */
class Mediator {
    /**
     * All enumerable properties from the `args` object are inherited to this mediator.
     *
     * @param {IMediatorArgs<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest,
     * O extends IActorOutput>} args Arguments object
     * @param {string} args.name The name for this mediator.
     * @param {Bus<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest, O extends IActorOutput>} args.bus
     *        The bus this mediator will mediate over.
     * @throws When required arguments are missing.
     */
    constructor(args) {
        Object.assign(this, args);
    }
    /**
     * Publish the given action in the bus.
     *
     * This will send the test action on all actors in the bus.
     * All actor replies will be returned.
     *
     * @param {I} action The action to mediate for.
     * @return {IActorReply<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest, O extends IActorOutput>[]}
     * The list of actor replies.
     */
    publish(action) {
        // Test all actors in the bus
        const actors = this.bus.publish(action);
        if (actors.length === 0) {
            throw new Error(`No actors are able to reply to a message in the bus ${this.bus.name}`);
        }
        return actors;
    }
    /**
     * Mediate for the given action to get an actor.
     *
     * This will send the test action on all actors in the bus.
     * The actor that tests _best_ will be returned.
     *
     * @param {I} action The action to mediate for.
     * @return {Promise<O extends IActorOutput>} A promise that resolves to the _best_ actor.
     */
    async mediateActor(action) {
        // Mediate to one actor and run that actor.
        return await this.mediateWith(action, this.publish(action));
    }
    /**
     * Mediate for the given action.
     *
     * This will send the test action on all actors in the bus.
     * The action will be run on the actor that tests _best_,
     * of which the result will be returned.
     *
     * @param {I} action The action to mediate for.
     * @return {Promise<O extends IActorOutput>} A promise that resolves to the mediation result.
     */
    async mediate(action) {
        // Mediate to one actor and run the action on it
        const actor = await this.mediateActor(action);
        return actor.runObservable(action);
    }
}
exports.Mediator = Mediator;
//# sourceMappingURL=Mediator.js.map

/***/ }),

/***/ "../node_modules/@comunica/core/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Logger = void 0;
/* eslint no-redeclare: "off" */
const types_1 = __quadstore_comunica_require__("../node_modules/@comunica/types/lib/index.js");
// TODO: Remove this export, and move test suite to \@comunica/types in the next release
/**
 * @deprecated Logger should be imported from \@comunica/types
 */
const Logger = types_1.Logger;
exports.Logger = Logger;
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/core/lib/ActionContext.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/core/lib/Bus.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/core/lib/BusIndexed.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/core/lib/ContextEntries.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/core/lib/ActionObserver.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/core/lib/Actor.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/core/lib/Mediator.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/data-factory/lib/BlankNodeBindingsScoped.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BlankNodeBindingsScoped = void 0;
/**
 * A blank node that is scoped to a set of bindings.
 */
class BlankNodeBindingsScoped {
    constructor(value) {
        this.termType = 'BlankNode';
        this.singleBindingsScope = true;
        this.value = value;
    }
    equals(other) {
        // eslint-disable-next-line no-implicit-coercion
        return !!other && other.termType === 'BlankNode' && other.value === this.value;
    }
}
exports.BlankNodeBindingsScoped = BlankNodeBindingsScoped;
//# sourceMappingURL=BlankNodeBindingsScoped.js.map

/***/ }),

/***/ "../node_modules/@comunica/data-factory/lib/BlankNodeScoped.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BlankNodeScoped = void 0;
/**
 * A blank node that is scoped to a certain source.
 */
class BlankNodeScoped {
    constructor(value, skolemized) {
        this.termType = 'BlankNode';
        this.value = value;
        this.skolemized = skolemized;
    }
    equals(other) {
        // eslint-disable-next-line no-implicit-coercion
        return !!other && other.termType === 'BlankNode' && other.value === this.value;
    }
}
exports.BlankNodeScoped = BlankNodeScoped;
//# sourceMappingURL=BlankNodeScoped.js.map

/***/ }),

/***/ "../node_modules/@comunica/data-factory/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/data-factory/lib/BlankNodeScoped.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/data-factory/lib/BlankNodeBindingsScoped.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/logger-void/lib/LoggerVoid.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoggerVoid = void 0;
const types_1 = __quadstore_comunica_require__("../node_modules/@comunica/types/lib/index.js");
/**
 * A logger that voids everything.
 */
class LoggerVoid extends types_1.Logger {
    debug() {
        // Void
    }
    error() {
        // Void
    }
    fatal() {
        // Void
    }
    info() {
        // Void
    }
    trace() {
        // Void
    }
    warn() {
        // Void
    }
}
exports.LoggerVoid = LoggerVoid;
//# sourceMappingURL=LoggerVoid.js.map

/***/ }),

/***/ "../node_modules/@comunica/logger-void/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/logger-void/lib/LoggerVoid.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/mediator-all/lib/MediatorAll.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MediatorAll = void 0;
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
/**
 * A comunica mediator that runs all actors that resolve their test.
 * This mediator will always resolve to the first actor's output.
 */
class MediatorAll extends core_1.Mediator {
    constructor(args) {
        super(args);
    }
    async mediate(action) {
        // Collect all actors that resolve their test
        const validActors = [];
        let testResults;
        try {
            testResults = this.publish(action);
        }
        catch {
            testResults = [];
        }
        for (const testResult of testResults) {
            try {
                await testResult.reply;
                validActors.push(testResult.actor);
            }
            catch {
                // Ignore errors
            }
        }
        // Send action to all valid actors
        const outputs = await Promise.all(validActors.map(actor => actor.runObservable(action)));
        return outputs[0];
    }
    async mediateWith() {
        throw new Error('Unsupported operation: MediatorAll#mediateWith');
    }
}
exports.MediatorAll = MediatorAll;
//# sourceMappingURL=MediatorAll.js.map

/***/ }),

/***/ "../node_modules/@comunica/mediator-all/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/mediator-all/lib/MediatorAll.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/mediator-combine-pipeline/lib/MediatorCombinePipeline.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MediatorCombinePipeline = void 0;
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
/**
 * A comunica mediator that goes over all actors in sequence and forwards I/O.
 * This required the action input and the actor output to be of the same type.
 */
class MediatorCombinePipeline extends core_1.Mediator {
    constructor(args) {
        super(args);
    }
    async mediate(action) {
        let testResults;
        try {
            testResults = this.publish(action);
        }
        catch {
            // If no actors are available, just return the input as output
            return action;
        }
        if (this.filterErrors) {
            const _testResults = [];
            for (const result of testResults) {
                try {
                    await result.reply;
                    _testResults.push(result);
                }
                catch {
                    // Ignore errors
                }
            }
            testResults = _testResults;
        }
        // Delegate test errors.
        testResults = await Promise.all(testResults.map(async ({ actor, reply }) => ({ actor, reply: await reply })));
        // Order the test results if ordering is enabled
        if (this.order) {
            // A function used to extract an ordering value from a test result
            const getOrder = (elem) => {
                // If there is a field key use it, otherwise use the input
                // element for ordering
                const value = this.field ? elem[this.field] : elem;
                // Check the ordering value is a number
                if (typeof value !== 'number') {
                    throw new Error('Cannot order elements that are not numbers.');
                }
                return value;
            };
            testResults = testResults.sort((actor1, actor2) => (this.order === 'increasing' ? 1 : -1) *
                (getOrder(actor1.reply) - getOrder(actor2.reply)));
        }
        // Pass action to first actor,
        // and each actor output as input to the following actor.
        let handle = action;
        for (const { actor } of testResults) {
            handle = { ...handle, ...await actor.runObservable(handle) };
        }
        // Return the final actor output
        return handle;
    }
    mediateWith() {
        throw new Error('Method not supported.');
    }
}
exports.MediatorCombinePipeline = MediatorCombinePipeline;
//# sourceMappingURL=MediatorCombinePipeline.js.map

/***/ }),

/***/ "../node_modules/@comunica/mediator-combine-pipeline/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/mediator-combine-pipeline/lib/MediatorCombinePipeline.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/mediator-combine-union/lib/MediatorCombineUnion.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MediatorCombineUnion = void 0;
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
/**
 * A comunica mediator that takes the union of all actor results.
 *
 * The actors that are registered first will have priority on setting overlapping fields.
 */
class MediatorCombineUnion extends core_1.Mediator {
    constructor(args) {
        super(args);
        this.combiner = this.createCombiner();
    }
    async mediate(action) {
        let testResults;
        try {
            testResults = this.publish(action);
        }
        catch {
            testResults = [];
        }
        // Delegate test errors.
        await Promise.all(testResults.map(({ reply }) => reply));
        // Run action on all actors.
        const results = await Promise.all(testResults.map(result => result.actor.runObservable(action)));
        // Return the combined results.
        return this.combiner(results);
    }
    mediateWith() {
        throw new Error('Method not supported.');
    }
    createCombiner() {
        return (results) => {
            const data = {};
            data[this.field] = {};
            // eslint-disable-next-line unicorn/prefer-spread
            [{}].concat(results.map((result) => result[this.field]))
                .forEach((value, index, arr) => {
                data[this.field] = { ...value, ...data[this.field] };
            });
            return data;
        };
    }
}
exports.MediatorCombineUnion = MediatorCombineUnion;
//# sourceMappingURL=MediatorCombineUnion.js.map

/***/ }),

/***/ "../node_modules/@comunica/mediator-combine-union/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/mediator-combine-union/lib/MediatorCombineUnion.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/mediator-join-coefficients-fixed/lib/MediatorJoinCoefficientsFixed.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MediatorJoinCoefficientsFixed = void 0;
const context_entries_1 = __quadstore_comunica_require__("../node_modules/@comunica/context-entries/lib/index.js");
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
/**
 * A mediator that mediates over actors implementing the Join Coefficients mediator type and assigns fixed weights
 * to calculate an overall score and pick the actor with the lowest score.
 */
class MediatorJoinCoefficientsFixed extends core_1.Mediator {
    constructor(args) {
        super(args);
    }
    async mediateWith(action, testResults) {
        // Obtain test results
        const errors = [];
        const promises = testResults
            .map(({ reply }) => reply)
            .map(promise => promise.catch(error => {
            errors.push(error);
        }));
        const coefficients = await Promise.all(promises);
        // Calculate costs
        let costs = coefficients
            // eslint-disable-next-line array-callback-return
            .map((coeff, i) => {
            if (coeff) {
                return coeff.iterations * this.cpuWeight +
                    coeff.persistedItems * this.memoryWeight +
                    coeff.blockingItems * this.timeWeight +
                    coeff.requestTime * this.ioWeight;
            }
        });
        const maxCost = Math.max(...costs.filter(cost => cost !== undefined));
        // If we have a limit indicator in the context,
        // increase cost of entries that have a number of iterations that is higher than the limit AND persist items.
        // In these cases, join operators that produce results early on will be preferred.
        const limitIndicator = action.context.get(context_entries_1.KeysQueryOperation.limitIndicator);
        if (limitIndicator) {
            costs = costs.map((cost, i) => {
                if (cost !== undefined && coefficients[i].persistedItems > 0 && coefficients[i].iterations > limitIndicator) {
                    return cost + maxCost;
                }
                return cost;
            });
        }
        // Determine index with lowest cost
        let minIndex = -1;
        let minValue = Number.POSITIVE_INFINITY;
        for (const [i, cost] of costs.entries()) {
            if (cost !== undefined && (minIndex === -1 || cost < minValue)) {
                minIndex = i;
                minValue = cost;
            }
        }
        // Reject if all actors rejected
        if (minIndex < 0) {
            throw new Error(`All actors rejected their test in ${this.name}\n${errors.map(error => error.message).join('\n')}`);
        }
        // Return actor with lowest cost
        const bestActor = testResults[minIndex].actor;
        // Emit calculations in logger
        if (bestActor.includeInLogs) {
            core_1.Actor.getContextLogger(action.context)?.debug(`Determined physical join operator '${bestActor.logicalType}-${bestActor.physicalName}'`, {
                entries: action.entries.length,
                variables: await Promise.all(action.entries
                    .map(async (entry) => (await entry.output.metadata()).variables.map(variable => variable.value))),
                costs: Object.fromEntries(costs.map((coeff, i) => [
                    `${testResults[i].actor.logicalType}-${testResults[i].actor.physicalName}`,
                    coeff,
                ])),
                coefficients: Object.fromEntries(coefficients.map((coeff, i) => [
                    `${testResults[i].actor.logicalType}-${testResults[i].actor.physicalName}`,
                    coeff,
                ])),
            });
        }
        return bestActor;
    }
}
exports.MediatorJoinCoefficientsFixed = MediatorJoinCoefficientsFixed;
//# sourceMappingURL=MediatorJoinCoefficientsFixed.js.map

/***/ }),

/***/ "../node_modules/@comunica/mediator-join-coefficients-fixed/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/mediator-join-coefficients-fixed/lib/MediatorJoinCoefficientsFixed.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/mediator-number/lib/MediatorNumber.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MediatorNumber = void 0;
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
/**
 * A mediator that can mediate over a single number field.
 *
 * It takes the required 'field' and 'type' parameters.
 * The 'field' parameter represents the field name of the test result field over which must be mediated.
 * The 'type' parameter
 */
class MediatorNumber extends core_1.Mediator {
    constructor(args) {
        super(args);
        this.indexPicker = this.createIndexPicker();
    }
    /**
     * @return {(tests: T[]) => number} A function that returns the index of the test result
     *                                  that has been chosen by this mediator.
     */
    createIndexPicker() {
        switch (this.type) {
            case 'min':
                return (tests) => tests.reduce((prev, curr, i) => {
                    const val = this.getOrDefault(curr[this.field], Number.POSITIVE_INFINITY);
                    return val !== null && (Number.isNaN(prev[0]) || prev[0] > val) ? [val, i] : prev;
                }, [Number.NaN, -1])[1];
            case 'max':
                return (tests) => tests.reduce((prev, curr, i) => {
                    const val = this.getOrDefault(curr[this.field], Number.NEGATIVE_INFINITY);
                    return val !== null && (Number.isNaN(prev[0]) || prev[0] < val) ? [val, i] : prev;
                }, [Number.NaN, -1])[1];
            default:
                throw new Error(`No valid "type" value was given, must be either 'min' or 'max', but got: ${this.type}`);
        }
    }
    getOrDefault(value, defaultValue) {
        return value === undefined ? defaultValue : value;
    }
    async mediateWith(action, testResults) {
        let promises = testResults.map(({ reply }) => reply);
        const errors = [];
        if (this.ignoreErrors) {
            const dummy = {};
            dummy[this.field] = null;
            promises = promises.map(promise => promise.catch(error => {
                errors.push(error);
                return dummy;
            }));
        }
        const results = await Promise.all(promises);
        const index = this.indexPicker(results);
        if (index < 0) {
            throw new Error(`All actors rejected their test in ${this.name}\n${errors.map(error => error.message).join('\n')}`);
        }
        return testResults[index].actor;
    }
}
exports.MediatorNumber = MediatorNumber;
//# sourceMappingURL=MediatorNumber.js.map

/***/ }),

/***/ "../node_modules/@comunica/mediator-number/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/mediator-number/lib/MediatorNumber.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/mediator-race/lib/MediatorRace.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MediatorRace = void 0;
const core_1 = __quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js");
/**
 * A mediator that picks the first actor that resolves its test.
 */
class MediatorRace extends core_1.Mediator {
    constructor(args) {
        super(args);
    }
    mediateWith(action, testResults) {
        return new Promise((resolve, reject) => {
            const errors = [];
            for (const testResult of testResults) {
                testResult.reply.then(() => {
                    resolve(testResult.actor);
                }).catch(error => {
                    // Reject if all replies were rejected
                    errors.push(error);
                    if (errors.length === testResults.length) {
                        reject(new Error(`${this.name} mediated over all rejecting actors:\n${errors.map(subError => subError.message).join('\n')}`));
                    }
                });
            }
        });
    }
}
exports.MediatorRace = MediatorRace;
//# sourceMappingURL=MediatorRace.js.map

/***/ }),

/***/ "../node_modules/@comunica/mediator-race/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/mediator-race/lib/MediatorRace.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@comunica/types/lib/Bindings.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=Bindings.js.map

/***/ }),

/***/ "../node_modules/@comunica/types/lib/IActionContext.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=IActionContext.js.map

/***/ }),

/***/ "../node_modules/@comunica/types/lib/ICliArgsHandler.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=ICliArgsHandler.js.map

/***/ }),

/***/ "../node_modules/@comunica/types/lib/IDataDestination.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=IDataDestination.js.map

/***/ }),

/***/ "../node_modules/@comunica/types/lib/IDataSource.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=IDataSource.js.map

/***/ }),

/***/ "../node_modules/@comunica/types/lib/IJoinEntry.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=IJoinEntry.js.map

/***/ }),

/***/ "../node_modules/@comunica/types/lib/IMetadata.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=IMetadata.js.map

/***/ }),

/***/ "../node_modules/@comunica/types/lib/IPhysicalQueryPlanLogger.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=IPhysicalQueryPlanLogger.js.map

/***/ }),

/***/ "../node_modules/@comunica/types/lib/IProxyHandler.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=IProxyHandler.js.map

/***/ }),

/***/ "../node_modules/@comunica/types/lib/IQueryContext.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=IQueryContext.js.map

/***/ }),

/***/ "../node_modules/@comunica/types/lib/IQueryEngine.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=IQueryEngine.js.map

/***/ }),

/***/ "../node_modules/@comunica/types/lib/IQueryOperationResult.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=IQueryOperationResult.js.map

/***/ }),

/***/ "../node_modules/@comunica/types/lib/Logger.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Logger = void 0;
/**
 * A logger accepts messages from different levels
 * and emits them in a certain way.
 */
class Logger {
    /**
     * Convert a string-based logging level to a numerical logging level.
     * @param level A string-based logging level
     * @return The numerical logging level, or undefined.
     */
    static getLevelOrdinal(level) {
        return Logger.LEVELS[level];
    }
}
exports.Logger = Logger;
/**
 * All available logging levels.
 * @type {{trace: number; debug: number; info: number; warn: number; error: number; fatal: number}}
 */
Logger.LEVELS = {
    trace: 0,
    debug: 1,
    info: 2,
    warn: 3,
    error: 4,
    fatal: 5,
};
//# sourceMappingURL=Logger.js.map

/***/ }),

/***/ "../node_modules/@comunica/types/lib/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/types/lib/Bindings.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/types/lib/IActionContext.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/types/lib/ICliArgsHandler.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/types/lib/IDataDestination.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/types/lib/IDataSource.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/types/lib/IJoinEntry.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/types/lib/IMetadata.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/types/lib/IPhysicalQueryPlanLogger.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/types/lib/IProxyHandler.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/types/lib/IQueryContext.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/types/lib/IQueryEngine.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/types/lib/IQueryOperationResult.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/@comunica/types/lib/Logger.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/asyncjoin/index.js":
/***/ ((module, __unused_webpack_exports, __quadstore_comunica_require__) => {


const DynamicNestedLoopJoin = __quadstore_comunica_require__("../node_modules/asyncjoin/join/DynamicNestedLoopJoin.js");
const HashJoin = __quadstore_comunica_require__("../node_modules/asyncjoin/join/HashJoin.js");
const NestedLoopJoin = __quadstore_comunica_require__("../node_modules/asyncjoin/join/NestedLoopJoin.js");
const SymmetricHashJoin = __quadstore_comunica_require__("../node_modules/asyncjoin/join/SymmetricHashJoin.js");

const MergeStream = __quadstore_comunica_require__("../node_modules/asyncjoin/util/MergeIterator.js");

module.exports = {
    DynamicNestedLoopJoin,
    HashJoin,
    NestedLoopJoin,
    SymmetricHashJoin,

    MergeStream
};

/***/ }),

/***/ "../node_modules/asyncjoin/join/DynamicNestedLoopJoin.js":
/***/ ((module, __unused_webpack_exports, __quadstore_comunica_require__) => {


let AsyncIterator = __quadstore_comunica_require__("asynciterator");
let MultiTransformIterator = AsyncIterator.MultiTransformIterator;
let SimpleTransformIterator = AsyncIterator.SimpleTransformIterator;

// Nested Loop Join, but the values of the inner loop are determined by each value of the outer loop, possibly reducing the number of necessary checks
class DynamicNestedLoopJoin extends MultiTransformIterator
{
    constructor (left, funRight, funJoin, options)
    {
        super(left, options);

        this.funRight = funRight;
        this.funJoin = funJoin;
    }

    _createTransformer (leftItem)
    {
        return new SimpleTransformIterator(this.funRight(leftItem), { transform: (rightItem, done, push) =>
        {
            let result = this.funJoin(leftItem, rightItem);
            if (result !== null)
                push(result);
            done();
        }});
    }
}

module.exports = DynamicNestedLoopJoin;


/***/ }),

/***/ "../node_modules/asyncjoin/join/HashJoin.js":
/***/ ((module, __unused_webpack_exports, __quadstore_comunica_require__) => {


let AsyncIterator = (__quadstore_comunica_require__("asynciterator").AsyncIterator);

// https://en.wikipedia.org/wiki/Hash_join
class HashJoin extends AsyncIterator
{
    constructor (left, right, funHash, funJoin)
    {
        super();

        this.addedDataListener = false;
        this.left = left;
        this.right = right;
        this.funHash = funHash;
        this.funJoin = funJoin;

        this.leftMap = new Map();

        this.match    = null;
        this.matches  = [];
        this.matchIdx = 0;

        this.left.on('error', (error) => this.destroy(error));
        this.right.on('error', (error) => this.destroy(error));

        this.readable = false;

        this.left.on('end', allowJoining.bind(this));

        function allowJoining ()
        {
            if (this.leftMap.size <= 0)
                return this.close();
            this.readable = true;
            this.right.on('readable', () => this.readable = true);
            this.right.on('end', () => { if (!this.hasResults()) this._end(); });
        }

        this.on('newListener', (eventName) =>
        {
            if (eventName === 'data' && !this.addedDataListener)
            {
                this.addedDataListener = true;
                this._addDataListener();
            }
        })
    }

    hasResults ()
    {
        return !this.right.ended || this.matchIdx < this.matches.length;
    }

    _end ()
    {
        super._end();
        this.left.destroy();
        this.right.destroy();
    }

    read ()
    {
        if (!this.addedDataListener)
        {
            this.addedDataListener = true;
            this._addDataListener();
        }

        while(true) {
            if (this.ended || !this.readable)
                return null;

            while (this.matchIdx < this.matches.length)
            {
                let item = this.matches[this.matchIdx++];
                let result = this.funJoin(item, this.match);
                if (result !== null)
                    return result;
            }

            if (!this.hasResults())
                this._end();

            this.match = this.right.read();

            if (this.match === null)
            {
                this.readable = false;
                return null;
            }

            let hash = this.funHash(this.match);
            this.matches = this.leftMap.get(hash) || [];
            this.matchIdx = 0;
        }
    }

    _addDataListener()
    {
        this.left.on('data', addItem.bind(this));

        function addItem(item)
        {
            let hash = this.funHash(item);
            if (!this.leftMap.has(hash))
                this.leftMap.set(hash, []);
            let arr = this.leftMap.get(hash);
            arr.push(item);
        }
    }
}

module.exports = HashJoin;


/***/ }),

/***/ "../node_modules/asyncjoin/join/NestedLoopJoin.js":
/***/ ((module, __unused_webpack_exports, __quadstore_comunica_require__) => {


const { MultiTransformIterator, SimpleTransformIterator, scheduleTask } = __quadstore_comunica_require__("asynciterator");

// https://en.wikipedia.org/wiki/Nested_loop_join
class NestedLoopJoin extends MultiTransformIterator
{
    constructor (left, right, funJoin, options)
    {
        super(left, options);

        this.right = right;
        this.funJoin = funJoin; // function that joins 2 elements or returns null if join is not possible
        this.on('end', () => this.right.close());
    }

    _end ()
    {
        super._end();
        scheduleTask(() => this.right.destroy());
    }

    _createTransformer (leftItem)
    {
        return new SimpleTransformIterator(this.right.clone(), { transform: (rightItem, done, push) =>
        {
            let result = this.funJoin(leftItem, rightItem);
            if (result !== null)
                push(result);
            done();
        }});
    }
}

module.exports = NestedLoopJoin;


/***/ }),

/***/ "../node_modules/asyncjoin/join/SymmetricHashJoin.js":
/***/ ((module, __unused_webpack_exports, __quadstore_comunica_require__) => {


let AsyncIterator = (__quadstore_comunica_require__("asynciterator").AsyncIterator);

// https://en.wikipedia.org/wiki/Symmetric_Hash_Join
class SymmetricHashJoin extends AsyncIterator
{
    constructor (left, right, funHash, funJoin)
    {
        super();

        this.left  = left;
        this.right = right;

        this.funHash = funHash;
        this.funJoin = funJoin;

        this.usedLeft = false;
        this.leftMap  = new Map();
        this.rightMap = new Map();

        this.on('end', () => this._cleanup() );

        this.match    = null;
        this.matches  = [];
        this.matchIdx = 0;

        if (this.left.readable || this.right.readable)
        {
            this.readable = true;
        }

        this.left.on('error', (error) => this.destroy(error));
        this.right.on('error', (error) => this.destroy(error));

        this.left.on('readable', () => this.readable = true);
        this.right.on('readable', () => this.readable = true);

        // this needs to be here since it's possible the left/right streams only get ended after there are no more results left
        this.left.on ('end', () => { if (!this.hasResults()) this._end(); });
        this.right.on('end', () => { if (!this.hasResults()) this._end(); });
    }

    hasResults()
    {
        // The "!!this.match" condition was added as a workaround to race
        // conditions and/or duplicate "end" events that may lead to premature
        // cleanups of the "this.matches" array.
        // See https://github.com/joachimvh/asyncjoin/issues/7
        return !this.left.ended  || !this.right.ended || (!!this.matches && this.matchIdx < this.matches.length);
    }

    _cleanup ()
    {
        // motivate garbage collector to remove these
        this.leftMap = null;
        this.rightMap = null;
        this.matches = null;
    }

    _end ()
    {
        super._end();
        this.left.destroy();
        this.right.destroy();
    }

    read ()
    {
        if (this.ended)
            return null;

        while (this.matchIdx < this.matches.length)
        {
            let item = this.matches[this.matchIdx++];
            let result = this.usedLeft ? this.funJoin(this.match, item) : this.funJoin(item, this.match);
            if (result !== null)
                return result;
        }

        if (!this.hasResults())
            this._end();

        let item = null;
        // try both streams if the first one has no value
        for (let i = 0; i < 2; ++i)
        {
            item = this.usedLeft ? this.right.read() : this.left.read();
            this.usedLeft = !this.usedLeft; // try other stream next time

            // found a result, no need to check the other stream this run
            if (item !== null)
                break;
        }

        if (this.done || item === null)
        {
            this.readable = false;
            return null;
        }

        let hash = this.funHash(item);
        let map = this.usedLeft ? this.leftMap : this.rightMap;
        if (!map.has(hash))
            map.set(hash, []);
        let arr = map.get(hash);
        arr.push(item);

        this.match = item;
        this.matches = (this.usedLeft ? this.rightMap : this.leftMap).get(hash) || [];
        this.matchIdx = 0;

        // array is filled again so recursive call can have results
        return this.read();
    }
}

module.exports = SymmetricHashJoin;


/***/ }),

/***/ "../node_modules/asyncjoin/util/MergeIterator.js":
/***/ ((module, __unused_webpack_exports, __quadstore_comunica_require__) => {


let AsyncIterator = (__quadstore_comunica_require__("asynciterator").AsyncIterator);

// merges the contents of multiple streams
class MergeIterator extends AsyncIterator
{
    constructor (streams)
    {
        super();
        
        if (!Array.isArray(streams))
            streams = Array.prototype.slice.call(arguments);
        
        this.streams = streams;
        
        for (let stream of streams)
        {
            stream.on('readable', () => this.emit('readable'));
            stream.on('end', () => this._removeStream(stream));
        }
        
        if (this.streams.length === 0)
            this.close();
        
        this.idx = this.streams.length-1;
    }
    
    _removeStream (stream)
    {
        let idx = this.streams.indexOf(stream);
        if (idx < 0)
            return;
        
        this.streams.splice(idx, 1);
        if (this.idx >= this.streams.length)
            --this.idx;
        
        if (this.streams.length === 0)
            this._end();
    }
    
    close ()
    {
        super.close();
        for (let stream of this.streams)
            stream.close();
    }
    
    read ()
    {
        for (let attempts = 0; attempts < this.streams.length; ++attempts)
        {
            this.idx = (this.idx + 1) % this.streams.length;
            let item = this.streams[this.idx].read();
            if (item !== null)
                return item;
        }
        
        return null;
    }
}

module.exports = MergeIterator;

/***/ }),

/***/ "../node_modules/bignumber.js/bignumber.js":
/***/ (function(module, exports, __quadstore_comunica_require__) {

var __QUADSTORE_COMUNICA_AMD_DEFINE_RESULT__;;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.1.0
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                       // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',        // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
      alphabetHasNormalDecimalDigits = true;


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10 && alphabetHasNormalDecimalDigits) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on ±Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and ±Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to ±Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = ±Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return ±0, else return ±Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) {
        t = xc;
        xc = yc;
        yc = t;
        y.s = -y.s;
      }  

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, ±Infinity or ±0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return ±Infinity if either is ±Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return ±0 if either is ±0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) {
        zc = xc;
        xc = yc;
        yc = zc;
        i = xcL;
        xcL = ycL;
        ycL = i;
      }  

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return ±Infinity if either ±Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) {
        t = yc;
        yc = xc;
        xc = t;
        b = a;
      }  

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) {
          i = g1;
          g1 = g2;
          g2 = i;
          len -= i;
        }  

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10 && alphabetHasNormalDecimalDigits) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (true) {
    !(__QUADSTORE_COMUNICA_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __quadstore_comunica_require__, exports, module),
		__QUADSTORE_COMUNICA_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __QUADSTORE_COMUNICA_AMD_DEFINE_RESULT__));

  // Node.js and other environments that support module.exports.
  } else {}
})(this);


/***/ }),

/***/ "../node_modules/canonicalize/lib/canonicalize.js":
/***/ ((module) => {

/* jshint esversion: 6 */
/* jslint node: true */


module.exports = function serialize (object) {
  if (object === null || typeof object !== 'object' || object.toJSON != null) {
    return JSON.stringify(object);
  }

  if (Array.isArray(object)) {
    return '[' + object.reduce((t, cv, ci) => {
      const comma = ci === 0 ? '' : ',';
      const value = cv === undefined || typeof cv === 'symbol' ? null : cv;
      return t + comma + serialize(value);
    }, '') + ']';
  }

  return '{' + Object.keys(object).sort().reduce((t, cv, ci) => {
    if (object[cv] === undefined ||
        typeof object[cv] === 'symbol') {
      return t;
    }
    const comma = t.length === 0 ? '' : ',';
    return t + comma + serialize(cv) + ':' + serialize(object[cv]);
  }, '') + '}';
};


/***/ }),

/***/ "../node_modules/hash.js/lib/hash.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {

var hash = exports;

hash.utils = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/utils.js");
hash.common = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/common.js");
hash.sha = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/sha.js");
hash.ripemd = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/ripemd.js");
hash.hmac = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/hmac.js");

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;


/***/ }),

/***/ "../node_modules/hash.js/lib/hash/common.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {



var utils = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/utils.js");
var assert = __quadstore_comunica_require__("../node_modules/minimalistic-assert/index.js");

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),

/***/ "../node_modules/hash.js/lib/hash/hmac.js":
/***/ ((module, __unused_webpack_exports, __quadstore_comunica_require__) => {



var utils = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/utils.js");
var assert = __quadstore_comunica_require__("../node_modules/minimalistic-assert/index.js");

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};


/***/ }),

/***/ "../node_modules/hash.js/lib/hash/ripemd.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {



var utils = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/utils.js");
var common = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/common.js");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];


/***/ }),

/***/ "../node_modules/hash.js/lib/hash/sha.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {



exports.sha1 = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/sha/1.js");
exports.sha224 = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/sha/224.js");
exports.sha256 = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/sha/256.js");
exports.sha384 = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/sha/384.js");
exports.sha512 = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/sha/512.js");


/***/ }),

/***/ "../node_modules/hash.js/lib/hash/sha/1.js":
/***/ ((module, __unused_webpack_exports, __quadstore_comunica_require__) => {



var utils = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/utils.js");
var common = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/common.js");
var shaCommon = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/sha/common.js");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ "../node_modules/hash.js/lib/hash/sha/224.js":
/***/ ((module, __unused_webpack_exports, __quadstore_comunica_require__) => {



var utils = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/utils.js");
var SHA256 = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/sha/256.js");

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};



/***/ }),

/***/ "../node_modules/hash.js/lib/hash/sha/256.js":
/***/ ((module, __unused_webpack_exports, __quadstore_comunica_require__) => {



var utils = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/utils.js");
var common = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/common.js");
var shaCommon = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/sha/common.js");
var assert = __quadstore_comunica_require__("../node_modules/minimalistic-assert/index.js");

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ "../node_modules/hash.js/lib/hash/sha/384.js":
/***/ ((module, __unused_webpack_exports, __quadstore_comunica_require__) => {



var utils = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/utils.js");

var SHA512 = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/sha/512.js");

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};


/***/ }),

/***/ "../node_modules/hash.js/lib/hash/sha/512.js":
/***/ ((module, __unused_webpack_exports, __quadstore_comunica_require__) => {



var utils = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/utils.js");
var common = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/common.js");
var assert = __quadstore_comunica_require__("../node_modules/minimalistic-assert/index.js");

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}


/***/ }),

/***/ "../node_modules/hash.js/lib/hash/sha/common.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {



var utils = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash/utils.js");
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;


/***/ }),

/***/ "../node_modules/hash.js/lib/hash/utils.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {



var assert = __quadstore_comunica_require__("../node_modules/minimalistic-assert/index.js");
var inherits = __quadstore_comunica_require__("../node_modules/inherits/inherits_browser.js");

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;


/***/ }),

/***/ "../node_modules/inherits/inherits_browser.js":
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "../node_modules/lru-cache/index.js":
/***/ ((module, __unused_webpack_exports, __quadstore_comunica_require__) => {



// A linked list to keep track of recently-used-ness
const Yallist = __quadstore_comunica_require__("../node_modules/yallist/yallist.js")

const MAX = Symbol('max')
const LENGTH = Symbol('length')
const LENGTH_CALCULATOR = Symbol('lengthCalculator')
const ALLOW_STALE = Symbol('allowStale')
const MAX_AGE = Symbol('maxAge')
const DISPOSE = Symbol('dispose')
const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')
const LRU_LIST = Symbol('lruList')
const CACHE = Symbol('cache')
const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')

const naiveLength = () => 1

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
  constructor (options) {
    if (typeof options === 'number')
      options = { max: options }

    if (!options)
      options = {}

    if (options.max && (typeof options.max !== 'number' || options.max < 0))
      throw new TypeError('max must be a non-negative number')
    // Kind of weird to have a default max of Infinity, but oh well.
    const max = this[MAX] = options.max || Infinity

    const lc = options.length || naiveLength
    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc
    this[ALLOW_STALE] = options.stale || false
    if (options.maxAge && typeof options.maxAge !== 'number')
      throw new TypeError('maxAge must be a number')
    this[MAX_AGE] = options.maxAge || 0
    this[DISPOSE] = options.dispose
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
    this.reset()
  }

  // resize the cache when the max changes.
  set max (mL) {
    if (typeof mL !== 'number' || mL < 0)
      throw new TypeError('max must be a non-negative number')

    this[MAX] = mL || Infinity
    trim(this)
  }
  get max () {
    return this[MAX]
  }

  set allowStale (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  }
  get allowStale () {
    return this[ALLOW_STALE]
  }

  set maxAge (mA) {
    if (typeof mA !== 'number')
      throw new TypeError('maxAge must be a non-negative number')

    this[MAX_AGE] = mA
    trim(this)
  }
  get maxAge () {
    return this[MAX_AGE]
  }

  // resize the cache when the lengthCalculator changes.
  set lengthCalculator (lC) {
    if (typeof lC !== 'function')
      lC = naiveLength

    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      })
    }
    trim(this)
  }
  get lengthCalculator () { return this[LENGTH_CALCULATOR] }

  get length () { return this[LENGTH] }
  get itemCount () { return this[LRU_LIST].length }

  rforEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].tail; walker !== null;) {
      const prev = walker.prev
      forEachStep(this, fn, walker, thisp)
      walker = prev
    }
  }

  forEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].head; walker !== null;) {
      const next = walker.next
      forEachStep(this, fn, walker, thisp)
      walker = next
    }
  }

  keys () {
    return this[LRU_LIST].toArray().map(k => k.key)
  }

  values () {
    return this[LRU_LIST].toArray().map(k => k.value)
  }

  reset () {
    if (this[DISPOSE] &&
        this[LRU_LIST] &&
        this[LRU_LIST].length) {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))
    }

    this[CACHE] = new Map() // hash of items by key
    this[LRU_LIST] = new Yallist() // list of items in order of use recency
    this[LENGTH] = 0 // length of items in the list
  }

  dump () {
    return this[LRU_LIST].map(hit =>
      isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter(h => h)
  }

  dumpLru () {
    return this[LRU_LIST]
  }

  set (key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE]

    if (maxAge && typeof maxAge !== 'number')
      throw new TypeError('maxAge must be a number')

    const now = maxAge ? Date.now() : 0
    const len = this[LENGTH_CALCULATOR](value, key)

    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key))
        return false
      }

      const node = this[CACHE].get(key)
      const item = node.value

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value)
      }

      item.now = now
      item.maxAge = maxAge
      item.value = value
      this[LENGTH] += len - item.length
      item.length = len
      this.get(key)
      trim(this)
      return true
    }

    const hit = new Entry(key, value, len, now, maxAge)

    // oversized objects fall out of cache automatically.
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value)

      return false
    }

    this[LENGTH] += hit.length
    this[LRU_LIST].unshift(hit)
    this[CACHE].set(key, this[LRU_LIST].head)
    trim(this)
    return true
  }

  has (key) {
    if (!this[CACHE].has(key)) return false
    const hit = this[CACHE].get(key).value
    return !isStale(this, hit)
  }

  get (key) {
    return get(this, key, true)
  }

  peek (key) {
    return get(this, key, false)
  }

  pop () {
    const node = this[LRU_LIST].tail
    if (!node)
      return null

    del(this, node)
    return node.value
  }

  del (key) {
    del(this, this[CACHE].get(key))
  }

  load (arr) {
    // reset the cache
    this.reset()

    const now = Date.now()
    // A previous serialized cache has the most recent items first
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l]
      const expiresAt = hit.e || 0
      if (expiresAt === 0)
        // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v)
      else {
        const maxAge = expiresAt - now
        // dont add already expired items
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge)
        }
      }
    }
  }

  prune () {
    this[CACHE].forEach((value, key) => get(this, key, false))
  }
}

const get = (self, key, doUse) => {
  const node = self[CACHE].get(key)
  if (node) {
    const hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE])
        return undefined
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET])
          node.value.now = Date.now()
        self[LRU_LIST].unshiftNode(node)
      }
    }
    return hit.value
  }
}

const isStale = (self, hit) => {
  if (!hit || (!hit.maxAge && !self[MAX_AGE]))
    return false

  const diff = Date.now() - hit.now
  return hit.maxAge ? diff > hit.maxAge
    : self[MAX_AGE] && (diff > self[MAX_AGE])
}

const trim = self => {
  if (self[LENGTH] > self[MAX]) {
    for (let walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      const prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

const del = (self, node) => {
  if (node) {
    const hit = node.value
    if (self[DISPOSE])
      self[DISPOSE](hit.key, hit.value)

    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

class Entry {
  constructor (key, value, length, now, maxAge) {
    this.key = key
    this.value = value
    this.length = length
    this.now = now
    this.maxAge = maxAge || 0
  }
}

const forEachStep = (self, fn, node, thisp) => {
  let hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE])
      hit = undefined
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self)
}

module.exports = LRUCache


/***/ }),

/***/ "../node_modules/minimalistic-assert/index.js":
/***/ ((module) => {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),

/***/ "../node_modules/rdf-data-factory/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/rdf-data-factory/lib/BlankNode.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/rdf-data-factory/lib/DataFactory.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/rdf-data-factory/lib/DefaultGraph.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/rdf-data-factory/lib/Literal.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/rdf-data-factory/lib/NamedNode.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/rdf-data-factory/lib/Quad.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/rdf-data-factory/lib/Variable.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/rdf-data-factory/lib/BlankNode.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BlankNode = void 0;
/**
 * A term that represents an RDF blank node with a label.
 */
class BlankNode {
    constructor(value) {
        this.termType = 'BlankNode';
        this.value = value;
    }
    equals(other) {
        return !!other && other.termType === 'BlankNode' && other.value === this.value;
    }
}
exports.BlankNode = BlankNode;
//# sourceMappingURL=BlankNode.js.map

/***/ }),

/***/ "../node_modules/rdf-data-factory/lib/DataFactory.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataFactory = void 0;
const BlankNode_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/lib/BlankNode.js");
const DefaultGraph_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/lib/DefaultGraph.js");
const Literal_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/lib/Literal.js");
const NamedNode_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/lib/NamedNode.js");
const Quad_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/lib/Quad.js");
const Variable_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/lib/Variable.js");
let dataFactoryCounter = 0;
/**
 * A factory for instantiating RDF terms and quads.
 */
class DataFactory {
    constructor(options) {
        this.blankNodeCounter = 0;
        options = options || {};
        this.blankNodePrefix = options.blankNodePrefix || `df_${dataFactoryCounter++}_`;
    }
    /**
     * @param value The IRI for the named node.
     * @return A new instance of NamedNode.
     * @see NamedNode
     */
    namedNode(value) {
        return new NamedNode_1.NamedNode(value);
    }
    /**
     * @param value The optional blank node identifier.
     * @return A new instance of BlankNode.
     *         If the `value` parameter is undefined a new identifier
     *         for the blank node is generated for each call.
     * @see BlankNode
     */
    blankNode(value) {
        return new BlankNode_1.BlankNode(value || `${this.blankNodePrefix}${this.blankNodeCounter++}`);
    }
    /**
     * @param value              The literal value.
     * @param languageOrDatatype The optional language or datatype.
     *                           If `languageOrDatatype` is a NamedNode,
     *                           then it is used for the value of `NamedNode.datatype`.
     *                           Otherwise `languageOrDatatype` is used for the value
     *                           of `NamedNode.language`.
     * @return A new instance of Literal.
     * @see Literal
     */
    literal(value, languageOrDatatype) {
        return new Literal_1.Literal(value, languageOrDatatype);
    }
    /**
     * This method is optional.
     * @param value The variable name
     * @return A new instance of Variable.
     * @see Variable
     */
    variable(value) {
        return new Variable_1.Variable(value);
    }
    /**
     * @return An instance of DefaultGraph.
     */
    defaultGraph() {
        return DefaultGraph_1.DefaultGraph.INSTANCE;
    }
    /**
     * @param subject   The quad subject term.
     * @param predicate The quad predicate term.
     * @param object    The quad object term.
     * @param graph     The quad graph term.
     * @return A new instance of Quad.
     * @see Quad
     */
    quad(subject, predicate, object, graph) {
        return new Quad_1.Quad(subject, predicate, object, graph || this.defaultGraph());
    }
    /**
     * Create a deep copy of the given term using this data factory.
     * @param original An RDF term.
     * @return A deep copy of the given term.
     */
    fromTerm(original) {
        // TODO: remove nasty any casts when this TS bug has been fixed:
        //  https://github.com/microsoft/TypeScript/issues/26933
        switch (original.termType) {
            case 'NamedNode':
                return this.namedNode(original.value);
            case 'BlankNode':
                return this.blankNode(original.value);
            case 'Literal':
                if (original.language) {
                    return this.literal(original.value, original.language);
                }
                if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {
                    return this.literal(original.value, this.fromTerm(original.datatype));
                }
                return this.literal(original.value);
            case 'Variable':
                return this.variable(original.value);
            case 'DefaultGraph':
                return this.defaultGraph();
            case 'Quad':
                return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));
        }
    }
    /**
     * Create a deep copy of the given quad using this data factory.
     * @param original An RDF quad.
     * @return A deep copy of the given quad.
     */
    fromQuad(original) {
        return this.fromTerm(original);
    }
    /**
     * Reset the internal blank node counter.
     */
    resetBlankNodeCounter() {
        this.blankNodeCounter = 0;
    }
}
exports.DataFactory = DataFactory;
//# sourceMappingURL=DataFactory.js.map

/***/ }),

/***/ "../node_modules/rdf-data-factory/lib/DefaultGraph.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultGraph = void 0;
/**
 * A singleton term instance that represents the default graph.
 * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.
 */
class DefaultGraph {
    constructor() {
        this.termType = 'DefaultGraph';
        this.value = '';
        // Private constructor
    }
    equals(other) {
        return !!other && other.termType === 'DefaultGraph';
    }
}
exports.DefaultGraph = DefaultGraph;
DefaultGraph.INSTANCE = new DefaultGraph();
//# sourceMappingURL=DefaultGraph.js.map

/***/ }),

/***/ "../node_modules/rdf-data-factory/lib/Literal.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Literal = void 0;
const NamedNode_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/lib/NamedNode.js");
/**
 * A term that represents an RDF literal, containing a string with an optional language tag or datatype.
 */
class Literal {
    constructor(value, languageOrDatatype) {
        this.termType = 'Literal';
        this.value = value;
        if (typeof languageOrDatatype === 'string') {
            this.language = languageOrDatatype;
            this.datatype = Literal.RDF_LANGUAGE_STRING;
        }
        else if (languageOrDatatype) {
            this.language = '';
            this.datatype = languageOrDatatype;
        }
        else {
            this.language = '';
            this.datatype = Literal.XSD_STRING;
        }
    }
    equals(other) {
        return !!other && other.termType === 'Literal' && other.value === this.value &&
            other.language === this.language && other.datatype.equals(this.datatype);
    }
}
exports.Literal = Literal;
Literal.RDF_LANGUAGE_STRING = new NamedNode_1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');
Literal.XSD_STRING = new NamedNode_1.NamedNode('http://www.w3.org/2001/XMLSchema#string');
//# sourceMappingURL=Literal.js.map

/***/ }),

/***/ "../node_modules/rdf-data-factory/lib/NamedNode.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NamedNode = void 0;
/**
 * A term that contains an IRI.
 */
class NamedNode {
    constructor(value) {
        this.termType = 'NamedNode';
        this.value = value;
    }
    equals(other) {
        return !!other && other.termType === 'NamedNode' && other.value === this.value;
    }
}
exports.NamedNode = NamedNode;
//# sourceMappingURL=NamedNode.js.map

/***/ }),

/***/ "../node_modules/rdf-data-factory/lib/Quad.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Quad = void 0;
/**
 * An instance of DefaultGraph represents the default graph.
 * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.
 */
class Quad {
    constructor(subject, predicate, object, graph) {
        this.termType = 'Quad';
        this.value = '';
        this.subject = subject;
        this.predicate = predicate;
        this.object = object;
        this.graph = graph;
    }
    equals(other) {
        // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.
        return !!other && (other.termType === 'Quad' || !other.termType) &&
            this.subject.equals(other.subject) &&
            this.predicate.equals(other.predicate) &&
            this.object.equals(other.object) &&
            this.graph.equals(other.graph);
    }
}
exports.Quad = Quad;
//# sourceMappingURL=Quad.js.map

/***/ }),

/***/ "../node_modules/rdf-data-factory/lib/Variable.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Variable = void 0;
/**
 * A term that represents a variable.
 */
class Variable {
    constructor(value) {
        this.termType = 'Variable';
        this.value = value;
    }
    equals(other) {
        return !!other && other.termType === 'Variable' && other.value === this.value;
    }
}
exports.Variable = Variable;
//# sourceMappingURL=Variable.js.map

/***/ }),

/***/ "../node_modules/rdf-string/index.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.termToString = exports.stringToTerm = exports.stringQuadToQuad = exports.quadToStringQuad = exports.getLiteralValue = exports.getLiteralType = exports.getLiteralLanguage = void 0;
const TermUtil_1 = __quadstore_comunica_require__("../node_modules/rdf-string/lib/TermUtil.js");
Object.defineProperty(exports, "getLiteralLanguage", ({ enumerable: true, get: function () { return TermUtil_1.getLiteralLanguage; } }));
Object.defineProperty(exports, "getLiteralType", ({ enumerable: true, get: function () { return TermUtil_1.getLiteralType; } }));
Object.defineProperty(exports, "getLiteralValue", ({ enumerable: true, get: function () { return TermUtil_1.getLiteralValue; } }));
Object.defineProperty(exports, "quadToStringQuad", ({ enumerable: true, get: function () { return TermUtil_1.quadToStringQuad; } }));
Object.defineProperty(exports, "stringQuadToQuad", ({ enumerable: true, get: function () { return TermUtil_1.stringQuadToQuad; } }));
Object.defineProperty(exports, "stringToTerm", ({ enumerable: true, get: function () { return TermUtil_1.stringToTerm; } }));
Object.defineProperty(exports, "termToString", ({ enumerable: true, get: function () { return TermUtil_1.termToString; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/rdf-string/lib/TermUtil.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringQuadToQuad = exports.quadToStringQuad = exports.stringToTerm = exports.getLiteralLanguage = exports.getLiteralType = exports.getLiteralValue = exports.termToString = void 0;
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const FACTORY = new rdf_data_factory_1.DataFactory();
/**
 * Utility methods for converting between string-based RDF representations and RDFJS objects.
 *
 * RDF Terms are represented as follows:
 * * Blank nodes: '_:myBlankNode'
 * * Variables:   '?myVariable'
 * * Literals:    '"myString"', '"myLanguageString"@en-us', '"3"^^xsd:number'
 * * URIs:        'http://example.org'
 *
 * Quads/triples are represented as hashes with 'subject', 'predicate', 'object' and 'graph' (optional)
 * as keys, and string-based RDF terms as values.
 */
/**
 * Convert an RDFJS term to a string-based representation.
 * @param {RDF.Term} term An RDFJS term.
 * @return {string} A string-based term representation.
 */
function termToString(term) {
    // TODO: remove nasty any casts when this TS bug has been fixed: https://github.com/microsoft/TypeScript/issues/26933
    if (!term) {
        return undefined;
    }
    switch (term.termType) {
        case 'NamedNode': return term.value;
        case 'BlankNode': return ('_:' + term.value);
        case 'Literal':
            const literalValue = term;
            return ('"' + literalValue.value + '"' +
                (literalValue.datatype &&
                    literalValue.datatype.value !== 'http://www.w3.org/2001/XMLSchema#string' &&
                    literalValue.datatype.value !== 'http://www.w3.org/1999/02/22-rdf-syntax-ns#langString' ?
                    '^^' + literalValue.datatype.value : '') +
                (literalValue.language ? '@' + literalValue.language : ''));
        case 'Quad': return `<<${termToString(term.subject)} ${termToString(term.predicate)} ${termToString(term.object)}${term.graph.termType === 'DefaultGraph' ? '' : ' ' + termToString(term.graph)}>>`;
        case 'Variable': return ('?' + term.value);
        case 'DefaultGraph': return term.value;
    }
}
exports.termToString = termToString;
/**
 * Get the string value of a literal.
 * @param {string} literalValue An RDF literal enclosed by '"'.
 * @return {string} The literal value inside the '"'.
 */
function getLiteralValue(literalValue) {
    const match = /^"([^]*)"/.exec(literalValue);
    if (!match) {
        throw new Error(literalValue + ' is not a literal');
    }
    return match[1];
}
exports.getLiteralValue = getLiteralValue;
/**
 * Get the datatype of the given literal.
 * @param {string} literalValue An RDF literal.
 * @return {string} The datatype of the literal.
 */
function getLiteralType(literalValue) {
    const match = /^"[^]*"(?:\^\^([^"]+)|(@)[^@"]+)?$/.exec(literalValue);
    if (!match) {
        throw new Error(literalValue + ' is not a literal');
    }
    return match[1] || (match[2]
        ? 'http://www.w3.org/1999/02/22-rdf-syntax-ns#langString' : 'http://www.w3.org/2001/XMLSchema#string');
}
exports.getLiteralType = getLiteralType;
/**
 * Get the language of the given literal.
 * @param {string} literalValue An RDF literal.
 * @return {string} The language of the literal.
 */
function getLiteralLanguage(literalValue) {
    const match = /^"[^]*"(?:@([^@"]+)|\^\^[^"]+)?$/.exec(literalValue);
    if (!match) {
        throw new Error(literalValue + ' is not a literal');
    }
    return match[1] ? match[1].toLowerCase() : '';
}
exports.getLiteralLanguage = getLiteralLanguage;
/**
 * Transform a string-based RDF term to an RDFJS term.
 * @param {string} value A string-based RDF-term.
 * @param {RDF.DataFactory} dataFactory An optional datafactory to create terms with.
 * @return {RDF.Term} An RDF-JS term.
 */
function stringToTerm(value, dataFactory) {
    dataFactory = dataFactory || FACTORY;
    if (!value || !value.length) {
        return dataFactory.defaultGraph();
    }
    switch (value[0]) {
        case '_': return dataFactory.blankNode(value.substr(2));
        case '?':
            if (!dataFactory.variable) {
                throw new Error(`Missing 'variable()' method on the given DataFactory`);
            }
            return dataFactory.variable(value.substr(1));
        case '"':
            const language = getLiteralLanguage(value);
            const type = dataFactory.namedNode(getLiteralType(value));
            return dataFactory.literal(getLiteralValue(value), language || type);
        case '<':
        default:
            if (value.startsWith('<<') && value.endsWith('>>')) {
                // Iterate character-by-character to detect spaces that are *not* wrapped in <<>>
                const terms = value.slice(2, -2);
                const stringTerms = [];
                let ignoreTags = 0;
                let lastIndex = 0;
                for (let i = 0; i < terms.length; i++) {
                    const char = terms[i];
                    if (char === '<')
                        ignoreTags++;
                    if (char === '>') {
                        if (ignoreTags === 0) {
                            throw new Error('Found closing tag without opening tag in ' + value);
                        }
                        else {
                            ignoreTags--;
                        }
                    }
                    if (char === ' ' && ignoreTags === 0) {
                        stringTerms.push(terms.slice(lastIndex, i));
                        lastIndex = i + 1;
                    }
                }
                if (ignoreTags !== 0) {
                    throw new Error('Found opening tag without closing tag in ' + value);
                }
                stringTerms.push(terms.slice(lastIndex, terms.length));
                // We require 3 or 4 components
                if (stringTerms.length !== 3 && stringTerms.length !== 4) {
                    throw new Error('Nested quad syntax error ' + value);
                }
                return dataFactory.quad(stringToTerm(stringTerms[0]), stringToTerm(stringTerms[1]), stringToTerm(stringTerms[2]), stringTerms[3] ? stringToTerm(stringTerms[3]) : undefined);
            }
            return dataFactory.namedNode(value);
    }
}
exports.stringToTerm = stringToTerm;
/**
 * Convert an RDFJS quad to a string-based quad representation.
 * @param {Quad} q An RDFJS quad.
 * @return {IStringQuad} A hash with string-based quad terms.
 * @template Q The type of quad, defaults to RDF.Quad.
 */
function quadToStringQuad(q) {
    // tslint:disable:object-literal-sort-keys
    return {
        subject: termToString(q.subject),
        predicate: termToString(q.predicate),
        object: termToString(q.object),
        graph: termToString(q.graph),
    };
    // tslint:enable:object-literal-sort-keys
}
exports.quadToStringQuad = quadToStringQuad;
/**
 * Convert a string-based quad representation to an RDFJS quad.
 * @param {IStringQuad} stringQuad A hash with string-based quad terms.
 * @param {RDF.DataFactory} dataFactory An optional datafactory to create terms with.
 * @return {Q} An RDFJS quad.
 * @template Q The type of quad, defaults to RDF.Quad.
 */
function stringQuadToQuad(stringQuad, dataFactory) {
    dataFactory = dataFactory || FACTORY;
    return dataFactory.quad(stringToTerm(stringQuad.subject, dataFactory), stringToTerm(stringQuad.predicate, dataFactory), stringToTerm(stringQuad.object, dataFactory), stringToTerm(stringQuad.graph, dataFactory));
}
exports.stringQuadToQuad = stringQuadToQuad;
//# sourceMappingURL=TermUtil.js.map

/***/ }),

/***/ "../node_modules/rdf-terms/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/rdf-terms/lib/QuadTermUtil.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/rdf-terms/lib/TermUtil.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/rdf-terms/lib/QuadTermUtil.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.matchPatternMappings = exports.matchPatternComplete = exports.matchPattern = exports.matchTerm = exports.someTerms = exports.everyTerms = exports.reduceTerms = exports.mapTerms = exports.filterQuadTermNames = exports.filterTerms = exports.forEachTerms = exports.collectNamedTerms = exports.getNamedTerms = exports.getTermsNested = exports.getTerms = exports.TRIPLE_TERM_NAMES = exports.QUAD_TERM_NAMES = void 0;
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * All available quad term names.
 * @type {[string , string , string , string]}
 */
exports.QUAD_TERM_NAMES = ['subject', 'predicate', 'object', 'graph'];
/**
 * All available triple term names.
 * @type {[string , string , string]}
 */
exports.TRIPLE_TERM_NAMES = ['subject', 'predicate', 'object'];
/**
 * Get all terms in the given quad.
 * @param {BaseQuad} quad An RDFJS quad.
 * @param {boolean} ignoreDefaultGraph If true and the quad has the default graph as graph,
 *                                     this term will not be returned in the array.
 *                                     (default: false)
 * @return {Term[]} The available terms in the quad.
 */
function getTerms(quad, ignoreDefaultGraph) {
    if (ignoreDefaultGraph && quad.graph.termType === 'DefaultGraph') {
        return [quad.subject, quad.predicate, quad.object];
    }
    return [quad.subject, quad.predicate, quad.object, quad.graph];
}
exports.getTerms = getTerms;
/**
 * Get all terms in the given quad, including nested quads.
 * @param {BaseQuad} quad An RDFJS quad.
 * @param {boolean} ignoreDefaultGraph If true and the quad has the default graph as graph,
 *                                     this term will not be returned in the array.
 *                                     (default: false)
 * @return {Term[]} The available terms in the nested quad, excluding quad terms.
 */
function getTermsNested(quad, ignoreDefaultGraph) {
    const terms = [];
    for (const term of getTerms(quad, ignoreDefaultGraph)) {
        if (term.termType === 'Quad') {
            getTermsNested(term, ignoreDefaultGraph).forEach(subTerm => terms.push(subTerm));
        }
        else {
            terms.push(term);
        }
    }
    return terms;
}
exports.getTermsNested = getTermsNested;
/**
 * Convert the given quad to an array of named terms.
 * This is the reverse operation of {@link collectNamedTerms}.
 * @param {BaseQuad} quad An RDFJS quad.
 * @return {INamedTerm[]} An array of named terms.
 */
function getNamedTerms(quad) {
    return [
        { key: 'subject', value: quad.subject },
        { key: 'predicate', value: quad.predicate },
        { key: 'object', value: quad.object },
        { key: 'graph', value: quad.graph },
    ];
}
exports.getNamedTerms = getNamedTerms;
/**
 * Convert an array of named terms to an RDFJS quad.
 * This is the reverse operation of {@link getNamedTerms}.
 * @param {INamedTerm[]} namedTerms An array of named terms.
 * @param {(termName: QuadTermName) => Term} defaultCb An optional callback for when
 *                                                     certain terms are not available in the array.
 * @param {RDF.DataFactory} dataFactory A custom data factory to create quads.
 * @return {Q} The resulting RDFJS quad.
 * @template Q The type of quad to output, defaults to RDF.Quad.
 */
function collectNamedTerms(namedTerms, defaultCb, dataFactory) {
    const elements = {};
    namedTerms.forEach((namedTerm) => elements[namedTerm.key] = namedTerm.value);
    if (defaultCb) {
        elements.subject = elements.subject || defaultCb('subject');
        elements.predicate = elements.predicate || defaultCb('predicate');
        elements.object = elements.object || defaultCb('object');
        elements.graph = elements.graph || defaultCb('graph');
    }
    return (dataFactory || DF).quad(elements.subject, elements.predicate, elements.object, elements.graph);
}
exports.collectNamedTerms = collectNamedTerms;
/**
 * Iterats over each term.
 * @param {BaseQuad} quad An RDFJS quad.
 * @param {(value: Term, key: QuadTermName} cb A callback function.
 */
function forEachTerms(quad, cb) {
    cb(quad.subject, 'subject');
    cb(quad.predicate, 'predicate');
    cb(quad.object, 'object');
    cb(quad.graph, 'graph');
}
exports.forEachTerms = forEachTerms;
/**
 * Get all terms in the given quad that return true on the given filter function.
 * @param {BaseQuad} quad A quad.
 * @param {(value: Term, key: QuadTermName) => boolean} filter A filter callback.
 * @return {Term[]} The list of matching terms.
 */
function filterTerms(quad, filter) {
    const terms = [];
    if (filter(quad.subject, 'subject')) {
        terms.push(quad.subject);
    }
    if (filter(quad.predicate, 'predicate')) {
        terms.push(quad.predicate);
    }
    if (filter(quad.object, 'object')) {
        terms.push(quad.object);
    }
    if (filter(quad.graph, 'graph')) {
        terms.push(quad.graph);
    }
    return terms;
}
exports.filterTerms = filterTerms;
/**
 * Get all quad term names in the given quad that return true on the given filter function.
 * @param {BaseQuad} quad A quad.
 * @param {(value: Term, key: QuadTermName, all: INamedTerm[]) => boolean} filter A filter callback.
 * @return {QuadTermName[]} The list of matching quad term names.
 */
function filterQuadTermNames(quad, filter) {
    const names = [];
    if (filter(quad.subject, 'subject')) {
        names.push('subject');
    }
    if (filter(quad.predicate, 'predicate')) {
        names.push('predicate');
    }
    if (filter(quad.object, 'object')) {
        names.push('object');
    }
    if (filter(quad.graph, 'graph')) {
        names.push('graph');
    }
    return names;
}
exports.filterQuadTermNames = filterQuadTermNames;
/**
 * Map all terms of a quad.
 * @param {Quad} quad An RDFJS quad.
 * @param {(value: Term, key: QuadTermName) => Term} mapper A mapper function.
 * @param {RDF.DataFactory} dataFactory A custom data factory to create quads.
 * @return {Quad} A new RDFJS quad.
 * @template Q The type of quad, defaults to RDF.Quad.
 */
function mapTerms(quad, mapper, dataFactory) {
    return (dataFactory || DF).quad(mapper(quad.subject, 'subject'), mapper(quad.predicate, 'predicate'), mapper(quad.object, 'object'), mapper(quad.graph, 'graph'));
}
exports.mapTerms = mapTerms;
/**
 * Reduce all terms of a quad.
 * @param {BaseQuad} quad An RDFJS quad.
 * @param {(previousValue: U, currentValue: Term, key: QuadTermName) => U} reducer A reduce function.
 * @param {U} initialValue The initial value.
 * @return {U} The final value.
 */
function reduceTerms(quad, reducer, initialValue) {
    let value = initialValue;
    value = reducer(value, quad.subject, 'subject');
    value = reducer(value, quad.predicate, 'predicate');
    value = reducer(value, quad.object, 'object');
    return reducer(value, quad.graph, 'graph');
}
exports.reduceTerms = reduceTerms;
/**
 * Determines whether all terms satisfy the specified test.
 * @param {BaseQuad} quad An RDFJS quad.
 * @param {(value: Term, key: QuadTermName} checker A checker function.
 * @return {boolean} If all terms satisfy the specified test.
 */
function everyTerms(quad, checker) {
    return checker(quad.subject, 'subject')
        && checker(quad.predicate, 'predicate')
        && checker(quad.object, 'object')
        && checker(quad.graph, 'graph');
}
exports.everyTerms = everyTerms;
/**
 * Determines whether at least one term satisfies the specified test.
 * @param {BaseQuad} quad An RDFJS quad.
 * @param {(value: Term, key: QuadTermName} checker A checker function.
 * @return {boolean} If at least one term satisfies the specified test.
 */
function someTerms(quad, checker) {
    return checker(quad.subject, 'subject')
        || checker(quad.predicate, 'predicate')
        || checker(quad.object, 'object')
        || checker(quad.graph, 'graph');
}
exports.someTerms = someTerms;
/**
 * Check if the given terms match.
 *
 * At least one of the following must be true:
 * * Term B is undefined.
 * * Term B is a variable.
 * * Term A and B are quads, and return true for `matchPatternComplete`.
 * * Quad term and term are equal (`termB.equals(termA)` return true)
 *
 * @param termA A term.
 * @param termB An optional term.
 */
function matchTerm(termA, termB) {
    return !termB
        || termB.termType === 'Variable'
        || (termB.termType === 'Quad' && termA.termType === 'Quad' && matchPatternComplete(termA, termB))
        || termB.equals(termA);
}
exports.matchTerm = matchTerm;
/**
 * Check if the given quad matches with the given quad terms.
 *
 * Each term must match at least one of the following:
 * * Term is undefined.
 * * Term is a variable.
 * * Quad term and term are both quads, and return true for `matchPatternComplete`.
 * * Quad term and term are equal (`quadTerm.equals(term)` return true)
 *
 * @param {BaseQuad} quad A quad to match with (can not contain variables).
 * @param {Term} subject An optional subject.
 * @param {Term} predicate An optional predicate.
 * @param {Term} object An optional object.
 * @param {Term} graph An optional graph.
 * @return {boolean} If the quad matches with the quad terms.
 */
function matchPattern(quad, subject, predicate, object, graph) {
    return matchTerm(quad.subject, subject)
        && matchTerm(quad.predicate, predicate)
        && matchTerm(quad.object, object)
        && matchTerm(quad.graph, graph);
}
exports.matchPattern = matchPattern;
/**
 * Check if the first quad matches with all terms from the second quad.
 *
 * Each term must match at least one of the following:
 * * Quad2 term is a variable.
 * * Quad1 term and Quad2 term are equal (`term1.equals(term2)` return true)
 *
 * @param {BaseQuad} quad A quad (can not contain variables).
 * @param {BaseQuad} pattern A quad pattern (can contain variables).
 * @return {boolean} If the quad terms match.
 */
function matchPatternComplete(quad, pattern) {
    return matchPattern(quad, pattern.subject, pattern.predicate, pattern.object, pattern.graph);
}
exports.matchPatternComplete = matchPatternComplete;
function matchPatternMappings(quad, pattern, opt = {}) {
    const map = {};
    function match(_pattern, _quad) {
        return everyTerms(_pattern, (t1, key) => {
            var _a, _b;
            const t2 = _quad[key];
            switch (t1.termType) {
                case 'Variable':
                    return (opt.skipVarMapping && t2.termType === 'Variable')
                        || ((_b = (_a = map[t1.value]) === null || _a === void 0 ? void 0 : _a.equals(t2)) !== null && _b !== void 0 ? _b : (map[t1.value] = t2, true));
                case 'Quad':
                    return t2.termType === 'Quad' && match(t1, t2);
                default:
                    return t1.equals(t2);
            }
        });
    }
    return match(pattern, quad) && (opt.returnMappings ? map : true);
}
exports.matchPatternMappings = matchPatternMappings;
//# sourceMappingURL=QuadTermUtil.js.map

/***/ }),

/***/ "../node_modules/rdf-terms/lib/TermUtil.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getQuads = exports.getDefaultGraphs = exports.getVariables = exports.getLiterals = exports.getBlankNodes = exports.getNamedNodes = exports.getTermsOfType = exports.uniqTerms = exports.TERM_TYPES = void 0;
const rdf_string_1 = __quadstore_comunica_require__("../node_modules/rdf-string/index.js");
/**
 * All known term types.
 * @see RDF.Term
 * @type {[string , string , string , string , string, string]}
 */
exports.TERM_TYPES = ['NamedNode', 'BlankNode', 'Literal', 'Variable', 'DefaultGraph', 'Quad'];
/*
 * Utility methods for handling RDFJS terms.
 */
/**
 * Create an array of unique terms from the given array.
 * @param {T[]} terms An array of RDFJS terms.
 * @return {T[]} A new array of unique RDFJS terms.
 */
function uniqTerms(terms) {
    const hash = {};
    return terms.filter(term => {
        const termString = rdf_string_1.termToString(term);
        return !(termString in hash) && (hash[termString] = true);
    });
}
exports.uniqTerms = uniqTerms;
/**
 * Find all terms of the given type in the given array.
 * @param {Term[]} terms An array of RDFJS terms.
 * @param {"NamedNode" | "BlankNode" | "Literal" | "Variable" | "DefaultGraph" | "Quad"} termType A term type.
 * @return {Term[]} A new array with elements from the given array only containing elements of the given type.
 */
function getTermsOfType(terms, termType) {
    return terms.filter((term) => term.termType === termType);
}
exports.getTermsOfType = getTermsOfType;
/**
 * Find all named nodes in the given array.
 * @param {Term[]} terms An array of RDFJS terms.
 * @return {NamedNode[]} A new array with elements from the given array only containing named nodes.
 */
function getNamedNodes(terms) {
    return getTermsOfType(terms, 'NamedNode');
}
exports.getNamedNodes = getNamedNodes;
/**
 * Find all blank nodes in the given array.
 * @param {Term[]} terms An array of RDFJS terms.
 * @return {BlankNode[]} A new array with elements from the given array only containing blank nodes.
 */
function getBlankNodes(terms) {
    return getTermsOfType(terms, 'BlankNode');
}
exports.getBlankNodes = getBlankNodes;
/**
 * Find all literals in the given array.
 * @param {Term[]} terms An array of RDFJS terms.
 * @return {Literal[]} A new array with elements from the given array only containing literals.
 */
function getLiterals(terms) {
    return getTermsOfType(terms, 'Literal');
}
exports.getLiterals = getLiterals;
/**
 * Find all variables in the given array.
 * @param {Term[]} terms An array of RDFJS terms.
 * @return {Variable[]} A new array with elements from the given array only containing variables.
 */
function getVariables(terms) {
    return getTermsOfType(terms, 'Variable');
}
exports.getVariables = getVariables;
/**
 * Find all default graphs in the given array.
 * @param {Term[]} terms An array of RDFJS terms.
 * @return {DefaultGraph[]} A new array with elements from the given array only containing default graphs.
 */
function getDefaultGraphs(terms) {
    return getTermsOfType(terms, 'DefaultGraph');
}
exports.getDefaultGraphs = getDefaultGraphs;
/**
 * Find all quads in the given array.
 * @param {Term[]} terms An array of RDFJS terms.
 * @return {BaseQuad[]} A new array with elements from the given array only containing quads.
 */
function getQuads(terms) {
    return getTermsOfType(terms, 'Quad');
}
exports.getQuads = getQuads;
//# sourceMappingURL=TermUtil.js.map

/***/ }),

/***/ "../node_modules/relative-to-absolute-iri/index.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__quadstore_comunica_require__("../node_modules/relative-to-absolute-iri/lib/Resolve.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/relative-to-absolute-iri/lib/Resolve.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Convert the given relative IRI to an absolute IRI
 * by taking into account the given optional baseIRI.
 *
 * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.
 * @param {string} baseIRI The optional base IRI.
 * @return {string} an absolute IRI.
 */
function resolve(relativeIRI, baseIRI) {
    baseIRI = baseIRI || '';
    const baseFragmentPos = baseIRI.indexOf('#');
    // Ignore any fragments in the base IRI
    if (baseFragmentPos > 0) {
        baseIRI = baseIRI.substr(0, baseFragmentPos);
    }
    // Convert empty value directly to base IRI
    if (!relativeIRI.length) {
        // At this point, the baseIRI MUST be absolute, otherwise we error
        if (baseIRI.indexOf(':') < 0) {
            throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);
        }
        return baseIRI;
    }
    // If the value starts with a query character, concat directly (but strip the existing query)
    if (relativeIRI.startsWith('?')) {
        const baseQueryPos = baseIRI.indexOf('?');
        if (baseQueryPos > 0) {
            baseIRI = baseIRI.substr(0, baseQueryPos);
        }
        return baseIRI + relativeIRI;
    }
    // If the value starts with a fragment character, concat directly
    if (relativeIRI.startsWith('#')) {
        return baseIRI + relativeIRI;
    }
    // Ignore baseIRI if it is empty
    if (!baseIRI.length) {
        const relativeColonPos = relativeIRI.indexOf(':');
        if (relativeColonPos < 0) {
            throw new Error(`Found invalid relative IRI '${relativeIRI}' for a missing baseIRI`);
        }
        return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);
    }
    // Ignore baseIRI if the value is absolute
    const valueColonPos = relativeIRI.indexOf(':');
    if (valueColonPos >= 0) {
        return removeDotSegmentsOfPath(relativeIRI, valueColonPos);
    }
    // At this point, the baseIRI MUST be absolute, otherwise we error
    const baseColonPos = baseIRI.indexOf(':');
    if (baseColonPos < 0) {
        throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);
    }
    const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1);
    // Inherit the baseIRI scheme if the value starts with '//'
    if (relativeIRI.indexOf('//') === 0) {
        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
    }
    // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.
    let baseSlashAfterColonPos;
    if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {
        // If there is no additional '/' after the '//'.
        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);
        if (baseSlashAfterColonPos < 0) {
            // If something other than a '/' follows the '://', append the value after a '/',
            // otherwise, prefix the value with only the baseIRI scheme.
            if (baseIRI.length > baseColonPos + 3) {
                return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
            }
            else {
                return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
            }
        }
    }
    else {
        // If there is not even a single '/' after the ':'
        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);
        if (baseSlashAfterColonPos < 0) {
            // If we don't have a '/' after the ':',
            // prefix the value with only the baseIRI scheme.
            return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
        }
    }
    // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.
    if (relativeIRI.indexOf('/') === 0) {
        return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);
    }
    let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);
    const baseIRILastSlashPos = baseIRIPath.lastIndexOf('/');
    // Ignore everything after the last '/' in the baseIRI path
    if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {
        baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1);
        // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')
        // This change is only allowed if there is something else following the path
        if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {
            relativeIRI = relativeIRI.substr(1);
        }
    }
    // Prefix the value with the baseIRI path where
    relativeIRI = baseIRIPath + relativeIRI;
    // Remove dot segment from the IRI
    relativeIRI = removeDotSegments(relativeIRI);
    // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.
    return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;
}
exports.resolve = resolve;
/**
 * Remove dot segments from the given path,
 * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).
 * @param {string} path An IRI path.
 * @return {string} A path, will always start with a '/'.
 */
function removeDotSegments(path) {
    // Prepare a buffer with segments between each '/.
    // Each segment represents an array of characters.
    const segmentBuffers = [];
    let i = 0;
    while (i < path.length) {
        // Remove '/.' or '/..'
        switch (path[i]) {
            case '/':
                if (path[i + 1] === '.') {
                    if (path[i + 2] === '.') {
                        // Start a new segment if we find an invalid character after the '.'
                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {
                            segmentBuffers.push([]);
                            i++;
                            break;
                        }
                        // Go to parent directory,
                        // so we remove a parent segment
                        segmentBuffers.pop();
                        // Ensure that we end with a slash if there is a trailing '/..'
                        if (!path[i + 3]) {
                            segmentBuffers.push([]);
                        }
                        i += 3;
                    }
                    else {
                        // Start a new segment if we find an invalid character after the '.'
                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {
                            segmentBuffers.push([]);
                            i++;
                            break;
                        }
                        // Ensure that we end with a slash if there is a trailing '/.'
                        if (!path[i + 2]) {
                            segmentBuffers.push([]);
                        }
                        // Go to the current directory,
                        // so we do nothing
                        i += 2;
                    }
                }
                else {
                    // Start a new segment
                    segmentBuffers.push([]);
                    i++;
                }
                break;
            case '#':
            case '?':
                // Query and fragment string should be appended unchanged
                if (!segmentBuffers.length) {
                    segmentBuffers.push([]);
                }
                segmentBuffers[segmentBuffers.length - 1].push(path.substr(i));
                // Break the while loop
                i = path.length;
                break;
            default:
                // Not a special character, just append it to our buffer
                if (!segmentBuffers.length) {
                    segmentBuffers.push([]);
                }
                segmentBuffers[segmentBuffers.length - 1].push(path[i]);
                i++;
                break;
        }
    }
    return '/' + segmentBuffers.map((buffer) => buffer.join('')).join('/');
}
exports.removeDotSegments = removeDotSegments;
/**
 * Removes dot segments of the given IRI.
 * @param {string} iri An IRI (or part of IRI).
 * @param {number} colonPosition The position of the first ':' in the IRI.
 * @return {string} The IRI where dot segments were removed.
 */
function removeDotSegmentsOfPath(iri, colonPosition) {
    // Determine where we should start looking for the first '/' that indicates the start of the path
    let searchOffset = colonPosition + 1;
    if (colonPosition >= 0) {
        if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {
            searchOffset = colonPosition + 3;
        }
    }
    else {
        if (iri[0] === '/' && iri[1] === '/') {
            searchOffset = 2;
        }
    }
    // Determine the path
    const pathSeparator = iri.indexOf('/', searchOffset);
    if (pathSeparator < 0) {
        return iri;
    }
    const base = iri.substr(0, pathSeparator);
    const path = iri.substr(pathSeparator);
    // Remove dot segments from the path
    return base + removeDotSegments(path);
}
exports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;
function isCharacterAllowedAfterRelativePathSegment(character) {
    return !character || character === '#' || character === '?' || character === '/';
}
//# sourceMappingURL=Resolve.js.map

/***/ }),

/***/ "../node_modules/spark-md5/spark-md5.js":
/***/ ((module) => {

(function (factory) {
    if (true) {
        // Node/CommonJS
        module.exports = factory();
    } else { var glob; }
}(function (undefined) {

    'use strict';

    /*
     * Fastest md5 implementation around (JKM md5).
     * Credits: Joseph Myers
     *
     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
     * @see http://jsperf.com/md5-shootout/7
     */

    /* this function is much faster,
      so if possible we use it. Some IEs
      are the only ones I know of that
      need the idiotic second function,
      generated by an if clause.  */
    var add32 = function (a, b) {
        return (a + b) & 0xFFFFFFFF;
    },
        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];


    function cmn(q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32((a << s) | (a >>> (32 - s)), b);
    }

    function md5cycle(x, k) {
        var a = x[0],
            b = x[1],
            c = x[2],
            d = x[3];

        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;

        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;

        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;

        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b  = (b << 21 | b >>> 11) + c | 0;

        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
    }

    function md5blk(s) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
    }

    function md5blk_array(a) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        }
        return md5blks;
    }

    function md51(s) {
        var n = s.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
        }
        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);
        return state;
    }

    function md51_array(a) {
        var n = a.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        }

        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
        // containing the last element of the parent array if the sub array specified starts
        // beyond the length of the parent array - weird.
        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= a[i] << ((i % 4) << 3);
        }

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);

        return state;
    }

    function rhex(n) {
        var s = '',
            j;
        for (j = 0; j < 4; j += 1) {
            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
        }
        return s;
    }

    function hex(x) {
        var i;
        for (i = 0; i < x.length; i += 1) {
            x[i] = rhex(x[i]);
        }
        return x.join('');
    }

    // In some cases the fast add32 function cannot be used..
    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {
        add32 = function (x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        };
    }

    // ---------------------------------------------------

    /**
     * ArrayBuffer slice polyfill.
     *
     * @see https://github.com/ttaubert/node-arraybuffer-slice
     */

    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
        (function () {
            function clamp(val, length) {
                val = (val | 0) || 0;

                if (val < 0) {
                    return Math.max(val + length, 0);
                }

                return Math.min(val, length);
            }

            ArrayBuffer.prototype.slice = function (from, to) {
                var length = this.byteLength,
                    begin = clamp(from, length),
                    end = length,
                    num,
                    target,
                    targetArray,
                    sourceArray;

                if (to !== undefined) {
                    end = clamp(to, length);
                }

                if (begin > end) {
                    return new ArrayBuffer(0);
                }

                num = end - begin;
                target = new ArrayBuffer(num);
                targetArray = new Uint8Array(target);

                sourceArray = new Uint8Array(this, begin, num);
                targetArray.set(sourceArray);

                return target;
            };
        })();
    }

    // ---------------------------------------------------

    /**
     * Helpers.
     */

    function toUtf8(str) {
        if (/[\u0080-\uFFFF]/.test(str)) {
            str = unescape(encodeURIComponent(str));
        }

        return str;
    }

    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length,
           buff = new ArrayBuffer(length),
           arr = new Uint8Array(buff),
           i;

        for (i = 0; i < length; i += 1) {
            arr[i] = str.charCodeAt(i);
        }

        return returnUInt8Array ? arr : buff;
    }

    function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
    }

    function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);

        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);

        return returnUInt8Array ? result : result.buffer;
    }

    function hexToBinaryString(hex) {
        var bytes = [],
            length = hex.length,
            x;

        for (x = 0; x < length - 1; x += 2) {
            bytes.push(parseInt(hex.substr(x, 2), 16));
        }

        return String.fromCharCode.apply(String, bytes);
    }

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation.
     *
     * Use this class to perform an incremental md5, otherwise use the
     * static methods instead.
     */

    function SparkMD5() {
        // call reset to init the instance
        this.reset();
    }

    /**
     * Appends a string.
     * A conversion will be applied if an utf8 string is detected.
     *
     * @param {String} str The string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.append = function (str) {
        // Converts the string to utf8 bytes if necessary
        // Then append as binary
        this.appendBinary(toUtf8(str));

        return this;
    };

    /**
     * Appends a binary string.
     *
     * @param {String} contents The binary string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.appendBinary = function (contents) {
        this._buff += contents;
        this._length += contents.length;

        var length = this._buff.length,
            i;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
        }

        this._buff = this._buff.substring(i - 64);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            i,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.reset = function () {
        this._buff = '';
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.prototype.getState = function () {
        return {
            buff: this._buff,
            length: this._length,
            hash: this._hash.slice()
        };
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.setState = function (state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;

        return this;
    };

    /**
     * Releases memory used by the incremental buffer and other additional
     * resources. If you plan to use the instance again, use reset instead.
     */
    SparkMD5.prototype.destroy = function () {
        delete this._hash;
        delete this._buff;
        delete this._length;
    };

    /**
     * Finish the final calculation based on the tail.
     *
     * @param {Array}  tail   The tail (will be modified)
     * @param {Number} length The length of the remaining buffer
     */
    SparkMD5.prototype._finish = function (tail, length) {
        var i = length,
            tmp,
            lo,
            hi;

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(this._hash, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Do the final computation based on the tail and length
        // Beware that the final length may not fit in 32 bits so we take care of that
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
    };

    /**
     * Performs the md5 hash on a string.
     * A conversion will be applied if utf8 string is detected.
     *
     * @param {String}  str The string
     * @param {Boolean} [raw] True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hash = function (str, raw) {
        // Converts the string to utf8 bytes if necessary
        // Then compute it using the binary function
        return SparkMD5.hashBinary(toUtf8(str), raw);
    };

    /**
     * Performs the md5 hash on a binary string.
     *
     * @param {String}  content The binary string
     * @param {Boolean} [raw]     True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hashBinary = function (content, raw) {
        var hash = md51(content),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation for array buffers.
     *
     * Use this class to perform an incremental md5 ONLY for array buffers.
     */
    SparkMD5.ArrayBuffer = function () {
        // call reset to init the instance
        this.reset();
    };

    /**
     * Appends an array buffer.
     *
     * @param {ArrayBuffer} arr The array to be appended
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
            length = buff.length,
            i;

        this._length += arr.byteLength;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
        }

        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            i,
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff[i] << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.reset = function () {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.ArrayBuffer.prototype.getState = function () {
        var state = SparkMD5.prototype.getState.call(this);

        // Convert buffer to a string
        state.buff = arrayBuffer2Utf8Str(state.buff);

        return state;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.setState = function (state) {
        // Convert string to buffer
        state.buff = utf8Str2ArrayBuffer(state.buff, true);

        return SparkMD5.prototype.setState.call(this, state);
    };

    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

    /**
     * Performs the md5 hash on an array buffer.
     *
     * @param {ArrayBuffer} arr The array buffer
     * @param {Boolean}     [raw] True to get the raw string, false to get the hex one
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
        var hash = md51_array(new Uint8Array(arr)),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    return SparkMD5;
}));


/***/ }),

/***/ "../node_modules/sparqlee/dist/index.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsyncAggregateEvaluator = exports.orderTypes = exports.isExpressionError = exports.ExpressionError = exports.AggregateEvaluator = exports.SyncEvaluator = exports.AsyncEvaluator = void 0;
// TODO: this form is deprecated, we should not rename these types. Should change in next mayor update.
var AsyncEvaluator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/evaluators/AsyncEvaluator.js");
Object.defineProperty(exports, "AsyncEvaluator", ({ enumerable: true, get: function () { return AsyncEvaluator_1.AsyncEvaluator; } }));
var SyncEvaluator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/evaluators/SyncEvaluator.js");
Object.defineProperty(exports, "SyncEvaluator", ({ enumerable: true, get: function () { return SyncEvaluator_1.SyncEvaluator; } }));
var AggregateEvaluator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/evaluators/AggregateEvaluator.js");
Object.defineProperty(exports, "AggregateEvaluator", ({ enumerable: true, get: function () { return AggregateEvaluator_1.AggregateEvaluator; } }));
var Errors_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Errors.js");
Object.defineProperty(exports, "ExpressionError", ({ enumerable: true, get: function () { return Errors_1.ExpressionError; } }));
Object.defineProperty(exports, "isExpressionError", ({ enumerable: true, get: function () { return Errors_1.isExpressionError; } }));
var Ordering_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Ordering.js");
Object.defineProperty(exports, "orderTypes", ({ enumerable: true, get: function () { return Ordering_1.orderTypes; } }));
var AsyncAggregateEvaluator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/evaluators/AsyncAggregateEvaluator.js");
Object.defineProperty(exports, "AsyncAggregateEvaluator", ({ enumerable: true, get: function () { return AsyncAggregateEvaluator_1.AsyncAggregateEvaluator; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/aggregators/Average.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Average = void 0;
const E = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/index.js");
const functions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/index.js");
const Helpers_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/Helpers.js");
const C = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Consts.js");
const BaseAggregator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/aggregators/BaseAggregator.js");
class Average extends BaseAggregator_1.BaseAggregator {
    constructor() {
        super(...arguments);
        this.summer = functions_1.regularFunctions[C.RegularOperator.ADDITION];
        this.divider = functions_1.regularFunctions[C.RegularOperator.DIVISION];
    }
    static emptyValue() {
        return (0, Helpers_1.integer)(0).toRDF();
    }
    init(start) {
        const sum = this.termToNumericOrError(start);
        return { sum, count: 1 };
    }
    put(state, term) {
        const internalTerm = this.termToNumericOrError(term);
        const sum = this.summer.apply([state.sum, internalTerm], this.sharedContext);
        return {
            sum,
            count: state.count + 1,
        };
    }
    result(state) {
        const count = new E.IntegerLiteral(state.count);
        const result = this.divider.apply([state.sum, count], this.sharedContext);
        return result.toRDF();
    }
}
exports.Average = Average;
//# sourceMappingURL=Average.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/aggregators/BaseAggregator.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseAggregator = void 0;
const TermTransformer_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/transformers/TermTransformer.js");
const Consts_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Consts.js");
const TypeHandling_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/TypeHandling.js");
class BaseAggregator {
    constructor(expr, sharedContext) {
        this.sharedContext = sharedContext;
        this.distinct = expr.distinct;
        this.separator = expr.separator || ' ';
        this.termTransformer = new TermTransformer_1.TermTransformer(sharedContext.superTypeProvider, sharedContext.enableExtendedXsdTypes);
    }
    termToNumericOrError(term) {
        // TODO: Check behaviour
        if (term.termType !== 'Literal') {
            throw new Error(`Term with value ${term.value} has type ${term.termType} and is not a numeric literal`);
        }
        else if (!(0, TypeHandling_1.isSubTypeOf)(term.datatype.value, Consts_1.TypeAlias.SPARQL_NUMERIC, this.sharedContext.superTypeProvider)) {
            throw new Error(`Term datatype ${term.datatype.value} with value ${term.value} has type ${term.termType} and is not a numeric literal`);
        }
        return this.termTransformer.transformLiteral(term);
    }
    extractValue(term) {
        if (term.termType !== 'Literal') {
            throw new Error(`Term with value ${term.value} has type ${term.termType} and is not a literal`);
        }
        const transformedLit = this.termTransformer.transformLiteral(term);
        return { type: transformedLit.dataType, value: transformedLit.typedValue };
    }
    static emptyValue() {
        return undefined;
    }
}
exports.BaseAggregator = BaseAggregator;
//# sourceMappingURL=BaseAggregator.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/aggregators/Count.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Count = void 0;
const Helpers_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/Helpers.js");
const BaseAggregator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/aggregators/BaseAggregator.js");
class Count extends BaseAggregator_1.BaseAggregator {
    static emptyValue() {
        return (0, Helpers_1.integer)(0).toRDF();
    }
    init(start) {
        return 1;
    }
    put(state, term) {
        return state + 1;
    }
    result(state) {
        return (0, Helpers_1.integer)(state).toRDF();
    }
}
exports.Count = Count;
//# sourceMappingURL=Count.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/aggregators/GroupConcat.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupConcat = void 0;
const Helpers_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/Helpers.js");
const BaseAggregator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/aggregators/BaseAggregator.js");
class GroupConcat extends BaseAggregator_1.BaseAggregator {
    static emptyValue() {
        return (0, Helpers_1.string)('').toRDF();
    }
    init(start) {
        return start.value;
    }
    put(state, term) {
        return state + this.separator + term.value;
    }
    result(state) {
        return (0, Helpers_1.string)(state).toRDF();
    }
}
exports.GroupConcat = GroupConcat;
//# sourceMappingURL=GroupConcat.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/aggregators/Max.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Max = void 0;
const BaseAggregator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/aggregators/BaseAggregator.js");
class Max extends BaseAggregator_1.BaseAggregator {
    init(start) {
        const { value } = this.extractValue(start);
        if (start.termType === 'Literal') {
            return { extremeValue: value, term: start };
        }
        throw new Error('Term should be a literal');
    }
    put(state, term) {
        const extracted = this.extractValue(term);
        if (extracted.value > state.extremeValue && term.termType === 'Literal') {
            return {
                extremeValue: extracted.value,
                term,
            };
        }
        return state;
    }
    result(state) {
        return state.term;
    }
}
exports.Max = Max;
//# sourceMappingURL=Max.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/aggregators/Min.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Min = void 0;
const BaseAggregator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/aggregators/BaseAggregator.js");
class Min extends BaseAggregator_1.BaseAggregator {
    init(start) {
        const { value } = this.extractValue(start);
        if (start.termType === 'Literal') {
            return { extremeValue: value, term: start };
        }
        throw new Error('Term should be a literal');
    }
    put(state, term) {
        const extracted = this.extractValue(term);
        if (extracted.value < state.extremeValue && term.termType === 'Literal') {
            return {
                extremeValue: extracted.value,
                term,
            };
        }
        return state;
    }
    result(state) {
        return state.term;
    }
}
exports.Min = Min;
//# sourceMappingURL=Min.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/aggregators/Sample.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sample = void 0;
const BaseAggregator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/aggregators/BaseAggregator.js");
class Sample extends BaseAggregator_1.BaseAggregator {
    init(start) {
        return start;
    }
    put(state, term) {
        // First value is our sample
        return state;
    }
    result(state) {
        return state;
    }
}
exports.Sample = Sample;
//# sourceMappingURL=Sample.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/aggregators/Sum.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sum = void 0;
const functions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/index.js");
const Helpers_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/Helpers.js");
const C = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Consts.js");
const BaseAggregator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/aggregators/BaseAggregator.js");
class Sum extends BaseAggregator_1.BaseAggregator {
    constructor() {
        super(...arguments);
        this.summer = functions_1.regularFunctions[C.RegularOperator.ADDITION];
    }
    static emptyValue() {
        return (0, Helpers_1.integer)(0).toRDF();
    }
    init(start) {
        return this.termToNumericOrError(start);
    }
    put(state, term) {
        const internalTerm = this.termToNumericOrError(term);
        const sum = this.summer.apply([state, internalTerm], this.sharedContext);
        return sum;
    }
    result(state) {
        return state.toRDF();
    }
}
exports.Sum = Sum;
//# sourceMappingURL=Sum.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/aggregators/index.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aggregators = void 0;
const Average_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/aggregators/Average.js");
const Count_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/aggregators/Count.js");
const GroupConcat_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/aggregators/GroupConcat.js");
const Max_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/aggregators/Max.js");
const Min_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/aggregators/Min.js");
const Sample_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/aggregators/Sample.js");
const Sum_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/aggregators/Sum.js");
exports.aggregators = {
    count: Count_1.Count,
    sum: Sum_1.Sum,
    min: Min_1.Min,
    max: Max_1.Max,
    avg: Average_1.Average,
    group_concat: GroupConcat_1.GroupConcat,
    sample: Sample_1.Sample,
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/evaluators/AggregateEvaluator.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AggregateEvaluator = void 0;
const BaseAggregateEvaluator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/evaluators/evaluatorHelpers/BaseAggregateEvaluator.js");
const SyncEvaluator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/evaluators/SyncEvaluator.js");
// TODO: Support hooks & change name to SyncAggregateEvaluator
class AggregateEvaluator extends BaseAggregateEvaluator_1.BaseAggregateEvaluator {
    constructor(expr, context, throwError) {
        super(expr, SyncEvaluator_1.SyncEvaluator.completeContext(context || {}), throwError);
        this.evaluator = new SyncEvaluator_1.SyncEvaluator(expr.expression, context);
    }
    put(bindings) {
        this.init(bindings);
    }
    __put(bindings) {
        try {
            const term = this.evaluator.evaluate(bindings);
            this.state = this.aggregator.put(this.state, term);
        }
        catch (error) {
            this.safeThrow(error);
        }
    }
    safeThrow(err) {
        if (this.throwError) {
            throw err;
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            this.put = () => { };
            // eslint-disable-next-line unicorn/no-useless-undefined
            this.result = () => undefined;
        }
    }
    init(start) {
        try {
            const startTerm = this.evaluator.evaluate(start);
            this.state = this.aggregator.init(startTerm);
            if (this.state) {
                this.put = this.__put.bind(this);
                this.result = this.__result.bind(this);
            }
        }
        catch (error) {
            this.safeThrow(error);
        }
    }
}
exports.AggregateEvaluator = AggregateEvaluator;
//# sourceMappingURL=AggregateEvaluator.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/evaluators/AsyncAggregateEvaluator.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsyncAggregateEvaluator = void 0;
const AsyncEvaluator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/evaluators/AsyncEvaluator.js");
const BaseAggregateEvaluator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/evaluators/evaluatorHelpers/BaseAggregateEvaluator.js");
class AsyncAggregateEvaluator extends BaseAggregateEvaluator_1.BaseAggregateEvaluator {
    constructor(expr, context, throwError) {
        super(expr, AsyncEvaluator_1.AsyncEvaluator.completeContext(context || {}), throwError);
        this.evaluator = new AsyncEvaluator_1.AsyncEvaluator(expr.expression, context);
        this.errorOccurred = false;
    }
    put(bindings) {
        return this.init(bindings);
    }
    async __put(bindings) {
        try {
            const term = await this.evaluator.evaluate(bindings);
            this.state = this.aggregator.put(this.state, term);
        }
        catch (error) {
            this.safeThrow(error);
        }
    }
    safeThrow(err) {
        if (this.throwError) {
            throw err;
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            this.put = async () => { };
            // eslint-disable-next-line unicorn/no-useless-undefined
            this.result = () => undefined;
            this.errorOccurred = true;
        }
    }
    async init(start) {
        try {
            const startTerm = await this.evaluator.evaluate(start);
            if (!startTerm || this.errorOccurred) {
                return;
            }
            if (this.state) {
                // Another put already initialized this, we should just handle the put as in __put and not init anymore
                this.state = this.aggregator.put(this.state, startTerm);
                return;
            }
            this.state = this.aggregator.init(startTerm);
            if (this.state) {
                this.put = this.__put.bind(this);
                this.result = this.__result.bind(this);
            }
        }
        catch (error) {
            this.safeThrow(error);
        }
    }
}
exports.AsyncAggregateEvaluator = AsyncAggregateEvaluator;
//# sourceMappingURL=AsyncAggregateEvaluator.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/evaluators/AsyncEvaluator.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsyncEvaluator = void 0;
const LRUCache = __quadstore_comunica_require__("../node_modules/lru-cache/index.js");
const AlgebraTransformer_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/transformers/AlgebraTransformer.js");
const AsyncRecursiveEvaluator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/evaluators/evaluatorHelpers/AsyncRecursiveEvaluator.js");
class AsyncEvaluator {
    constructor(algExpr, context = {}) {
        this.algExpr = algExpr;
        // eslint-disable-next-line unicorn/no-useless-undefined
        const creator = context.extensionFunctionCreator || (() => undefined);
        const baseContext = AsyncEvaluator.completeContext(context);
        const transformer = new AlgebraTransformer_1.AlgebraTransformer(Object.assign({ type: 'async', creator }, baseContext));
        this.expr = transformer.transformAlgebra(algExpr);
        this.evaluator = new AsyncRecursiveEvaluator_1.AsyncRecursiveEvaluator(baseContext, transformer);
    }
    static completeContext(context) {
        return {
            now: context.now || new Date(Date.now()),
            baseIRI: context.baseIRI || undefined,
            overloadCache: context.overloadCache || new LRUCache(),
            superTypeProvider: {
                cache: context.typeCache || new LRUCache(),
                discoverer: context.getSuperType || (() => 'term'),
            },
            extensionFunctionCreator: context.extensionFunctionCreator,
            exists: context.exists,
            aggregate: context.aggregate,
            bnode: context.bnode,
            enableExtendedXsdTypes: context.enableExtendedXsdTypes || false,
        };
    }
    async evaluate(mapping) {
        const result = await this.evaluator.evaluate(this.expr, mapping);
        return result.toRDF();
    }
    async evaluateAsEBV(mapping) {
        const result = await this.evaluator.evaluate(this.expr, mapping);
        return result.coerceEBV();
    }
    async evaluateAsInternal(mapping) {
        const result = await this.evaluator.evaluate(this.expr, mapping);
        return result;
    }
}
exports.AsyncEvaluator = AsyncEvaluator;
//# sourceMappingURL=AsyncEvaluator.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/evaluators/SyncEvaluator.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyncEvaluator = void 0;
const LRUCache = __quadstore_comunica_require__("../node_modules/lru-cache/index.js");
const AlgebraTransformer_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/transformers/AlgebraTransformer.js");
const SyncRecursiveEvaluator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/evaluators/evaluatorHelpers/SyncRecursiveEvaluator.js");
class SyncEvaluator {
    constructor(algExpr, context = {}) {
        this.algExpr = algExpr;
        this.context = context;
        // eslint-disable-next-line unicorn/no-useless-undefined
        const creator = context.extensionFunctionCreator || (() => undefined);
        const baseContext = SyncEvaluator.completeContext(context);
        const transformer = new AlgebraTransformer_1.AlgebraTransformer(Object.assign({ type: 'sync', creator }, baseContext));
        this.expr = transformer.transformAlgebra(algExpr);
        this.evaluator = new SyncRecursiveEvaluator_1.SyncRecursiveEvaluator(baseContext, transformer);
    }
    static completeContext(context) {
        return {
            now: context.now || new Date(Date.now()),
            baseIRI: context.baseIRI || undefined,
            overloadCache: context.overloadCache || new LRUCache(),
            superTypeProvider: {
                cache: context.typeCache || new LRUCache(),
                discoverer: context.getSuperType || (() => 'term'),
            },
            extensionFunctionCreator: context.extensionFunctionCreator,
            exists: context.exists,
            aggregate: context.aggregate,
            bnode: context.bnode,
            enableExtendedXsdTypes: context.enableExtendedXsdTypes || false,
        };
    }
    evaluate(mapping) {
        const result = this.evaluator.evaluate(this.expr, mapping);
        return result.toRDF();
    }
    evaluateAsEBV(mapping) {
        const result = this.evaluator.evaluate(this.expr, mapping);
        return result.coerceEBV();
    }
    evaluateAsInternal(mapping) {
        const result = this.evaluator.evaluate(this.expr, mapping);
        return result;
    }
}
exports.SyncEvaluator = SyncEvaluator;
//# sourceMappingURL=SyncEvaluator.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/evaluators/evaluatorHelpers/AsyncRecursiveEvaluator.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsyncRecursiveEvaluator = void 0;
const E = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/index.js");
const TermTransformer_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/transformers/TermTransformer.js");
const Err = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Errors.js");
const BaseExpressionEvaluator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/evaluators/evaluatorHelpers/BaseExpressionEvaluator.js");
class AsyncRecursiveEvaluator extends BaseExpressionEvaluator_1.BaseExpressionEvaluator {
    constructor(context, termTransformer) {
        super(termTransformer || new TermTransformer_1.TermTransformer(context.superTypeProvider, context.enableExtendedXsdTypes));
        this.context = context;
        this.subEvaluators = {
            // Shared
            [E.ExpressionType.Term]: this.term.bind(this),
            [E.ExpressionType.Variable]: this.variable.bind(this),
            // Async
            [E.ExpressionType.Operator]: this.evalOperator.bind(this),
            [E.ExpressionType.SpecialOperator]: this.evalSpecialOperator.bind(this),
            [E.ExpressionType.Named]: this.evalNamed.bind(this),
            [E.ExpressionType.Existence]: this.evalExistence.bind(this),
            [E.ExpressionType.Aggregate]: this.evalAggregate.bind(this),
            [E.ExpressionType.AsyncExtension]: this.evalAsyncExtension.bind(this),
        };
    }
    async evaluate(expr, mapping) {
        const evaluator = this.subEvaluators[expr.expressionType];
        if (!evaluator) {
            throw new Err.InvalidExpressionType(expr);
        }
        return evaluator.bind(this)(expr, mapping);
    }
    async evalOperator(expr, mapping) {
        const argPromises = expr.args.map(arg => this.evaluate(arg, mapping));
        const argResults = await Promise.all(argPromises);
        return expr.apply(argResults);
    }
    async evalSpecialOperator(expr, mapping) {
        const evaluate = this.evaluate.bind(this);
        const context = {
            args: expr.args,
            mapping,
            superTypeProvider: this.context.superTypeProvider,
            now: this.context.now,
            baseIRI: this.context.baseIRI,
            overloadCache: this.context.overloadCache,
            evaluate,
            bnode: this.context.bnode,
            enableExtendedXsdTypes: this.context.enableExtendedXsdTypes,
        };
        return expr.applyAsync(context);
    }
    async _evalAsyncArgs(args, mapping) {
        const argPromises = args.map(arg => this.evaluate(arg, mapping));
        return await Promise.all(argPromises);
    }
    async evalNamed(expr, mapping) {
        return expr.apply(await this._evalAsyncArgs(expr.args, mapping));
    }
    async evalAsyncExtension(expr, mapping) {
        return await expr.apply(await this._evalAsyncArgs(expr.args, mapping));
    }
    async evalExistence(expr, mapping) {
        if (!this.context.exists) {
            throw new Err.NoExistenceHook();
        }
        return new E.BooleanLiteral(await this.context.exists(expr.expression, mapping));
    }
    // TODO: Remove?
    async evalAggregate(expr, _mapping) {
        if (!this.context.aggregate) {
            throw new Err.NoExistenceHook();
        }
        return this.termTransformer.transformRDFTermUnsafe(await this.context.aggregate(expr.expression));
    }
}
exports.AsyncRecursiveEvaluator = AsyncRecursiveEvaluator;
//# sourceMappingURL=AsyncRecursiveEvaluator.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/evaluators/evaluatorHelpers/BaseAggregateEvaluator.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseAggregateEvaluator = void 0;
const aggregators_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/aggregators/index.js");
const Err = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Errors.js");
class BaseAggregateEvaluator {
    constructor(expr, sharedContext, throwError) {
        this.throwError = false;
        this.expression = expr;
        this.aggregator = new aggregators_1.aggregators[expr.aggregator](expr, sharedContext);
        this.throwError = throwError || false;
    }
    /**
     * The spec says to throw an error when a set function is called on an empty
     * set (unless explicitly mentioned otherwise like COUNT).
     * However, aggregate error handling says to not bind the result in case of an
     * error. So to simplify logic in the caller, we return undefined by default.
     *
     * @param throwError whether this function should respect the spec and throw an error if no empty value is defined
     */
    static emptyValue(expr, throwError = false) {
        const val = aggregators_1.aggregators[expr.aggregator].emptyValue();
        if (val === undefined && throwError) {
            throw new Err.EmptyAggregateError();
        }
        return val;
    }
    result() {
        return this.aggregator.constructor.emptyValue();
    }
    /**
     * The actual result method. When the first binding has been given, and the state
     * of the evaluators initialised. The .result API function will be replaced with this
     * function, which implements the behaviour we want.
     *
     * @param bindings the bindings to pass to the expression
     */
    __result() {
        return this.aggregator.result(this.state);
    }
}
exports.BaseAggregateEvaluator = BaseAggregateEvaluator;
//# sourceMappingURL=BaseAggregateEvaluator.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/evaluators/evaluatorHelpers/BaseExpressionEvaluator.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseExpressionEvaluator = void 0;
const Helpers_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/Helpers.js");
const Err = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Errors.js");
class BaseExpressionEvaluator {
    constructor(termTransformer) {
        this.termTransformer = termTransformer;
    }
    term(expr, mapping) {
        return expr;
    }
    variable(expr, mapping) {
        const term = mapping.get((0, Helpers_1.expressionToVar)(expr));
        if (!term) {
            throw new Err.UnboundVariableError(expr.name, mapping);
        }
        return this.termTransformer.transformRDFTermUnsafe(term);
    }
}
exports.BaseExpressionEvaluator = BaseExpressionEvaluator;
//# sourceMappingURL=BaseExpressionEvaluator.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/evaluators/evaluatorHelpers/SyncRecursiveEvaluator.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyncRecursiveEvaluator = void 0;
const E = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/index.js");
const TermTransformer_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/transformers/TermTransformer.js");
const Err = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Errors.js");
const BaseExpressionEvaluator_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/evaluators/evaluatorHelpers/BaseExpressionEvaluator.js");
class SyncRecursiveEvaluator extends BaseExpressionEvaluator_1.BaseExpressionEvaluator {
    constructor(context, termTransformer) {
        super(termTransformer || new TermTransformer_1.TermTransformer(context.superTypeProvider, context.enableExtendedXsdTypes));
        this.context = context;
        this.subEvaluators = {
            // Shared
            [E.ExpressionType.Term]: this.term.bind(this),
            [E.ExpressionType.Variable]: this.variable.bind(this),
            // Sync
            [E.ExpressionType.Operator]: this.evalOperator.bind(this),
            [E.ExpressionType.SpecialOperator]: this.evalSpecialOperator.bind(this),
            [E.ExpressionType.Named]: this.evalNamed.bind(this),
            [E.ExpressionType.Existence]: this.evalExistence.bind(this),
            [E.ExpressionType.Aggregate]: this.evalAggregate.bind(this),
            [E.ExpressionType.SyncExtension]: this.evalSyncExtension.bind(this),
        };
    }
    evaluate(expr, mapping) {
        const evaluator = this.subEvaluators[expr.expressionType];
        if (!evaluator) {
            throw new Err.InvalidExpressionType(expr);
        }
        return evaluator.bind(this)(expr, mapping);
    }
    evalOperator(expr, mapping) {
        const args = expr.args.map(arg => this.evaluate(arg, mapping));
        return expr.apply(args);
    }
    evalSpecialOperator(expr, mapping) {
        const evaluate = this.evaluate.bind(this);
        const context = {
            args: expr.args,
            mapping,
            superTypeProvider: this.context.superTypeProvider,
            now: this.context.now,
            baseIRI: this.context.baseIRI,
            overloadCache: this.context.overloadCache,
            evaluate,
            bnode: this.context.bnode,
            enableExtendedXsdTypes: this.context.enableExtendedXsdTypes,
        };
        return expr.applySync(context);
    }
    evalNamed(expr, mapping) {
        const args = expr.args.map(arg => this.evaluate(arg, mapping));
        return expr.apply(args);
    }
    evalSyncExtension(expr, mapping) {
        const args = expr.args.map(arg => this.evaluate(arg, mapping));
        return expr.apply(args);
    }
    evalExistence(expr, mapping) {
        if (!this.context.exists) {
            throw new Err.NoExistenceHook();
        }
        return new E.BooleanLiteral(this.context.exists(expr.expression, mapping));
    }
    evalAggregate(expr, mapping) {
        if (!this.context.aggregate) {
            throw new Err.NoAggregator();
        }
        return this.termTransformer.transformRDFTermUnsafe(this.context.aggregate(expr.expression));
    }
}
exports.SyncRecursiveEvaluator = SyncRecursiveEvaluator;
//# sourceMappingURL=SyncRecursiveEvaluator.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/expressions/Aggregate.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Aggregate = void 0;
const Expressions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/Expressions.js");
class Aggregate {
    constructor(name, expression) {
        this.name = name;
        this.expression = expression;
        this.expressionType = Expressions_1.ExpressionType.Aggregate;
    }
}
exports.Aggregate = Aggregate;
//# sourceMappingURL=Aggregate.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/expressions/AsyncExtension.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsyncExtension = void 0;
const Expressions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/Expressions.js");
class AsyncExtension {
    constructor(name, args, apply) {
        this.name = name;
        this.args = args;
        this.apply = apply;
        this.expressionType = Expressions_1.ExpressionType.AsyncExtension;
    }
}
exports.AsyncExtension = AsyncExtension;
//# sourceMappingURL=AsyncExtension.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/expressions/Existence.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Existence = void 0;
const Expressions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/Expressions.js");
class Existence {
    constructor(expression) {
        this.expression = expression;
        this.expressionType = Expressions_1.ExpressionType.Existence;
    }
}
exports.Existence = Existence;
//# sourceMappingURL=Existence.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/expressions/Expressions.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asTermType = exports.ExpressionType = void 0;
var ExpressionType;
(function (ExpressionType) {
    ExpressionType["Aggregate"] = "aggregate";
    ExpressionType["Existence"] = "existence";
    ExpressionType["Named"] = "named";
    ExpressionType["Operator"] = "operator";
    ExpressionType["SpecialOperator"] = "specialOperator";
    ExpressionType["Term"] = "term";
    ExpressionType["Variable"] = "variable";
    ExpressionType["AsyncExtension"] = "asyncExtension";
    ExpressionType["SyncExtension"] = "syncExtension";
})(ExpressionType = exports.ExpressionType || (exports.ExpressionType = {}));
// TODO: Create alias Term = TermExpression
function asTermType(type) {
    if (type === 'namedNode' || type === 'literal' || type === 'blankNode') {
        return type;
    }
    return undefined;
}
exports.asTermType = asTermType;
//# sourceMappingURL=Expressions.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/expressions/Named.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Named = void 0;
const Expressions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/Expressions.js");
class Named {
    constructor(name, args, apply) {
        this.name = name;
        this.args = args;
        this.apply = apply;
        this.expressionType = Expressions_1.ExpressionType.Named;
    }
}
exports.Named = Named;
//# sourceMappingURL=Named.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/expressions/Operator.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Operator = void 0;
const Expressions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/Expressions.js");
class Operator {
    constructor(args, apply) {
        this.args = args;
        this.apply = apply;
        this.expressionType = Expressions_1.ExpressionType.Operator;
    }
}
exports.Operator = Operator;
//# sourceMappingURL=Operator.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/expressions/SpecialOperator.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpecialOperator = void 0;
const Expressions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/Expressions.js");
class SpecialOperator {
    constructor(args, applyAsync, applySync) {
        this.args = args;
        this.applyAsync = applyAsync;
        this.applySync = applySync;
        this.expressionType = Expressions_1.ExpressionType.SpecialOperator;
    }
}
exports.SpecialOperator = SpecialOperator;
//# sourceMappingURL=SpecialOperator.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/expressions/SyncExtension.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyncExtension = void 0;
const Expressions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/Expressions.js");
class SyncExtension {
    constructor(name, args, apply) {
        this.name = name;
        this.args = args;
        this.apply = apply;
        this.expressionType = Expressions_1.ExpressionType.SyncExtension;
    }
}
exports.SyncExtension = SyncExtension;
//# sourceMappingURL=SyncExtension.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/expressions/Term.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isNonLexicalLiteral = exports.NonLexicalLiteral = exports.StringLiteral = exports.LangStringLiteral = exports.DateTimeLiteral = exports.BooleanLiteral = exports.DoubleLiteral = exports.FloatLiteral = exports.DecimalLiteral = exports.IntegerLiteral = exports.NumericLiteral = exports.Literal = exports.isLiteralTermExpression = exports.BlankNode = exports.NamedNode = exports.Term = void 0;
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const C = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Consts.js");
const Consts_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Consts.js");
const Err = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Errors.js");
const TypeHandling_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/TypeHandling.js");
const Expressions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/Expressions.js");
const DF = new rdf_data_factory_1.DataFactory();
class Term {
    constructor() {
        this.expressionType = Expressions_1.ExpressionType.Term;
    }
    str() {
        throw new Err.InvalidArgumentTypes([this], C.RegularOperator.STR);
    }
    coerceEBV() {
        throw new Err.EBVCoercionError(this);
    }
}
exports.Term = Term;
// NamedNodes -----------------------------------------------------------------
class NamedNode extends Term {
    constructor(value) {
        super();
        this.value = value;
        this.termType = 'namedNode';
    }
    toRDF() {
        return DF.namedNode(this.value);
    }
    str() {
        return this.value;
    }
}
exports.NamedNode = NamedNode;
// BlankNodes -----------------------------------------------------------------
class BlankNode extends Term {
    constructor(value) {
        super();
        this.termType = 'blankNode';
        this.value = typeof value === 'string' ? DF.blankNode(value) : value;
    }
    static nextID() {
        BlankNode._nextID += 1;
        return BlankNode.nextID.toString();
    }
    toRDF() {
        return this.value;
    }
}
exports.BlankNode = BlankNode;
BlankNode._nextID = 0;
// Literals-- -----------------------------------------------------------------
function isLiteralTermExpression(expr) {
    if (expr.termType === 'literal') {
        return expr;
    }
    return undefined;
}
exports.isLiteralTermExpression = isLiteralTermExpression;
class Literal extends Term {
    /**
     * @param typedValue internal representation of this literal's value
     * @param dataType a string representing the datatype. Can be of type @see LiteralTypes or any URI
     * @param strValue the string value of this literal. In other words, the string representing the RDF.literal value.
     * @param language the language, mainly for language enabled strings like RDF_LANG_STRING
     * @param mainSparqlType the type used by sparql's main functions
     */
    constructor(typedValue, dataType, strValue, language, mainSparqlType) {
        super();
        this.typedValue = typedValue;
        this.dataType = dataType;
        this.strValue = strValue;
        this.language = language;
        this.termType = 'literal';
        this.mainSparqlType = mainSparqlType || 'other';
    }
    toRDF() {
        return DF.literal(this.strValue || this.str(), this.language || DF.namedNode(this.dataType));
    }
    str() {
        return this.strValue || this.typedValue.toString();
    }
}
exports.Literal = Literal;
class NumericLiteral extends Literal {
    constructor(typedValue, dataType, strValue, language, mainSparqlType) {
        super(typedValue, dataType, strValue, language, mainSparqlType);
        this.typedValue = typedValue;
        this.strValue = strValue;
        this.language = language;
    }
    coerceEBV() {
        return !!this.typedValue;
    }
    toRDF() {
        const term = super.toRDF();
        if (!Number.isFinite(this.typedValue)) {
            term.value = term.value.replace('Infinity', 'INF');
        }
        return term;
    }
    str() {
        return this.strValue ||
            this.specificFormatter(this.typedValue);
    }
}
exports.NumericLiteral = NumericLiteral;
class IntegerLiteral extends NumericLiteral {
    constructor(typedValue, dataType, strValue, language) {
        super(typedValue, dataType || Consts_1.TypeURL.XSD_INTEGER, strValue, language, 'integer');
        this.typedValue = typedValue;
        this.strValue = strValue;
        this.language = language;
    }
    specificFormatter(val) {
        return val.toFixed(0);
    }
}
exports.IntegerLiteral = IntegerLiteral;
class DecimalLiteral extends NumericLiteral {
    constructor(typedValue, dataType, strValue, language) {
        super(typedValue, dataType || Consts_1.TypeURL.XSD_DECIMAL, strValue, language, 'decimal');
        this.typedValue = typedValue;
        this.strValue = strValue;
        this.language = language;
    }
    specificFormatter(val) {
        return val.toString();
    }
}
exports.DecimalLiteral = DecimalLiteral;
class FloatLiteral extends NumericLiteral {
    constructor(typedValue, dataType, strValue, language) {
        super(typedValue, dataType || Consts_1.TypeURL.XSD_FLOAT, strValue, language, 'float');
        this.typedValue = typedValue;
        this.strValue = strValue;
        this.language = language;
    }
    specificFormatter(val) {
        return val.toString();
    }
}
exports.FloatLiteral = FloatLiteral;
class DoubleLiteral extends NumericLiteral {
    constructor(typedValue, dataType, strValue, language) {
        super(typedValue, dataType || Consts_1.TypeURL.XSD_DOUBLE, strValue, language, 'double');
        this.typedValue = typedValue;
        this.strValue = strValue;
        this.language = language;
    }
    specificFormatter(val) {
        const jsExponential = val.toExponential();
        const [jsMantisse, jsExponent] = jsExponential.split('e');
        // Leading + must be removed for integer
        // https://www.w3.org/TR/xmlschema-2/#integer
        const exponent = jsExponent.replace(/\+/u, '');
        // SPARQL test suite prefers trailing zero's
        const mantisse = jsMantisse.includes('.') ?
            jsMantisse :
            `${jsMantisse}.0`;
        return `${mantisse}E${exponent}`;
    }
}
exports.DoubleLiteral = DoubleLiteral;
class BooleanLiteral extends Literal {
    constructor(typedValue, strValue, dataType) {
        super(typedValue, dataType || Consts_1.TypeURL.XSD_BOOLEAN, strValue, undefined, 'boolean');
        this.typedValue = typedValue;
        this.strValue = strValue;
    }
    coerceEBV() {
        return !!this.typedValue;
    }
}
exports.BooleanLiteral = BooleanLiteral;
class DateTimeLiteral extends Literal {
    // StrValue is mandatory here because toISOString will always add
    // milliseconds, even if they were not present.
    constructor(typedValue, strValue, dataType) {
        super(typedValue, dataType || Consts_1.TypeURL.XSD_DATE_TIME, strValue, undefined, 'dateTime');
        this.typedValue = typedValue;
        this.strValue = strValue;
    }
}
exports.DateTimeLiteral = DateTimeLiteral;
class LangStringLiteral extends Literal {
    constructor(typedValue, language, dataType) {
        super(typedValue, dataType || Consts_1.TypeURL.RDF_LANG_STRING, typedValue, language, 'langString');
        this.typedValue = typedValue;
        this.language = language;
    }
    coerceEBV() {
        return this.str().length > 0;
    }
}
exports.LangStringLiteral = LangStringLiteral;
// https://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-plain-literal
// https://www.w3.org/TR/sparql11-query/#defn_SimpleLiteral
// https://www.w3.org/TR/sparql11-query/#func-strings
// This does not include language tagged literals
class StringLiteral extends Literal {
    /**
     * @param typedValue
     * @param dataType Should be type that implements XSD_STRING
     */
    constructor(typedValue, dataType) {
        super(typedValue, dataType || Consts_1.TypeURL.XSD_STRING, typedValue, undefined, 'string');
        this.typedValue = typedValue;
    }
    coerceEBV() {
        return this.str().length > 0;
    }
}
exports.StringLiteral = StringLiteral;
/**
 * This class is used when a literal is parsed, and it's value is
 * an invalid lexical form for it's datatype. The spec defines value with
 * invalid lexical form are still valid terms, and as such we can not error
 * immediately. This class makes sure that the typedValue will remain undefined,
 * and the category 'nonlexical'. This way, only when operators apply to the
 * 'nonlexical' category, they will keep working, otherwise they will throw a
 * type error.
 * This seems to match the spec, except maybe for functions that accept
 * non-lexical values for their datatype.
 *
 * See:
 *  - https://www.w3.org/TR/xquery/#dt-type-error
 *  - https://www.w3.org/TR/rdf-concepts/#section-Literal-Value
 *  - https://www.w3.org/TR/xquery/#dt-ebv
 *  - ... some other more precise thing i can't find...
 */
class NonLexicalLiteral extends Literal {
    constructor(typedValue, typeURL, openWorldType, strValue, language) {
        super({ toString: () => 'undefined' }, typeURL, strValue, language, 'nonlexical');
        this.typeURL = typeURL;
        this.openWorldType = openWorldType;
        this.typedValue = { toString: () => 'undefined' };
        this.dataType = Consts_1.TypeAlias.SPARQL_NON_LEXICAL;
    }
    coerceEBV() {
        const isNumericOrBool = (0, TypeHandling_1.isSubTypeOf)(this.typeURL, Consts_1.TypeURL.XSD_BOOLEAN, this.openWorldType) ||
            (0, TypeHandling_1.isSubTypeOf)(this.typeURL, Consts_1.TypeAlias.SPARQL_NUMERIC, this.openWorldType);
        if (isNumericOrBool) {
            return false;
        }
        throw new Err.EBVCoercionError(this);
    }
    toRDF() {
        return DF.literal(this.str(), this.language || DF.namedNode(this.typeURL));
    }
    str() {
        return this.strValue || '';
    }
}
exports.NonLexicalLiteral = NonLexicalLiteral;
function isNonLexicalLiteral(lit) {
    if (lit.dataType === Consts_1.TypeAlias.SPARQL_NON_LEXICAL) {
        return lit;
    }
    return undefined;
}
exports.isNonLexicalLiteral = isNonLexicalLiteral;
//# sourceMappingURL=Term.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/expressions/Variable.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Variable = void 0;
const Expressions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/Expressions.js");
class Variable {
    constructor(name) {
        this.expressionType = Expressions_1.ExpressionType.Variable;
        this.name = name;
    }
}
exports.Variable = Variable;
//# sourceMappingURL=Variable.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/expressions/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/Expressions.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/Variable.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/Term.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/Operator.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/SpecialOperator.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/Named.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/Aggregate.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/Existence.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/AsyncExtension.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/SyncExtension.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/functions/Core.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpecialFunction = exports.NamedFunction = exports.RegularFunction = exports.BaseFunction = void 0;
const Err = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Errors.js");
class BaseFunction {
    constructor(operator, definition) {
        this.operator = operator;
        /**
         * A function application works by monomorphing the function to a specific
         * instance depending on the runtime types. We then just apply this function
         * to the args.
         */
        this.apply = (args, context) => {
            const concreteFunction = this.monomorph(args, context.superTypeProvider, context.overloadCache, context.enableExtendedXsdTypes) ||
                this.handleInvalidTypes(args);
            return concreteFunction(context)(args);
        };
        this.arity = definition.arity;
        this.overloads = definition.overloads;
    }
    /**
     * We monomorph by checking the map of overloads for keys corresponding
     * to the runtime types. We start by checking for an implementation for the
     * most concrete types (integer, string, date, IRI), if we find none,
     * we consider their term types (literal, blank, IRI), and lastly we consider
     * all arguments as generic terms.
     *
     * Another option would be to populate the overloads with an implementation
     * for every concrete type when the function is generic over termtypes or
     * terms.
     */
    monomorph(args, superTypeProvider, overloadCache, experimental) {
        return experimental ?
            this.overloads.experimentalTree.search(args, superTypeProvider, overloadCache) :
            this.overloads.tree.search(args);
    }
}
exports.BaseFunction = BaseFunction;
// Regular Functions ----------------------------------------------------------
/**
 * Varying kinds of functions take arguments of different types on which the
 * specific behaviour is dependant. Although their behaviour is often varying,
 * it is always relatively simple, and better suited for synced behaviour.
 * The types of their arguments are always terms, but might differ in
 * their term-type (eg: iri, literal),
 * their specific literal type (eg: string, integer),
 * their arity (see BNODE),
 * or even their specific numeric type (eg: integer, float).
 *
 * Examples include:
 *  - Arithmetic operations such as: *, -, /, +
 *  - Bool operators such as: =, !=, <=, <, ...
 *  - Functions such as: str, IRI
 *
 * See also: https://www.w3.org/TR/sparql11-query/#func-rdfTerms
 * and https://www.w3.org/TR/sparql11-query/#OperatorMapping
 */
class RegularFunction extends BaseFunction {
    constructor(op, definition) {
        super(op, definition);
        this.functionClass = 'regular';
    }
    handleInvalidTypes(args) {
        throw new Err.InvalidArgumentTypes(args, this.operator);
    }
}
exports.RegularFunction = RegularFunction;
// Named Functions ------------------------------------------------------------
class NamedFunction extends BaseFunction {
    constructor(op, definition) {
        super(op, definition);
        this.functionClass = 'named';
    }
    handleInvalidTypes(args) {
        throw new Err.InvalidArgumentTypes(args, this.operator);
    }
}
exports.NamedFunction = NamedFunction;
// Special Functions ----------------------------------------------------------
/**
 * Special Functions are those that don't really fit in sensible categories and
 * have extremely heterogeneous signatures that make them impossible to abstract
 * over. They are small in number, and their behaviour is often complex and open
 * for multiple correct implementations with different trade-offs.
 *
 * Due to their varying nature, they need all available information present
 * during evaluation. This reflects in the signature of the apply() method.
 *
 * They need access to an evaluator to be able to even implement their logic.
 * Especially relevant for IF, and the logical connectives.
 *
 * They can have both sync and async implementations, and both would make sense
 * in some contexts.
 */
class SpecialFunction {
    constructor(operator, definition) {
        this.operator = operator;
        this.functionClass = 'special';
        this.arity = definition.arity;
        this.applySync = definition.applySync;
        this.applyAsync = definition.applyAsync;
        this.checkArity = definition.checkArity || defaultArityCheck(this.arity);
    }
}
exports.SpecialFunction = SpecialFunction;
function defaultArityCheck(arity) {
    return (args) => {
        // Infinity is used to represent var-args, so it's always correct.
        if (arity === Number.POSITIVE_INFINITY) {
            return true;
        }
        // If the function has overloaded arity, the actual arity needs to be present.
        if (Array.isArray(arity)) {
            return arity.includes(args.length);
        }
        return args.length === arity;
    };
}
//# sourceMappingURL=Core.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/functions/Helpers.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.expressionToVar = exports.dateTime = exports.langString = exports.string = exports.double = exports.float = exports.decimal = exports.integer = exports.bool = exports.Builder = exports.declare = void 0;
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const E = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/index.js");
const expressions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/index.js");
const C = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Consts.js");
const Consts_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Consts.js");
const Err = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Errors.js");
const TypeHandling_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/TypeHandling.js");
const LegacyTree_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/LegacyTree.js");
const OverloadTree_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/OverloadTree.js");
const DF = new rdf_data_factory_1.DataFactory();
function declare(identifier) {
    return new Builder(identifier);
}
exports.declare = declare;
class Builder {
    constructor(identifier) {
        this.overloadTree = new OverloadTree_1.OverloadTree(identifier);
        this.legacyTree = new LegacyTree_1.LegacyTree();
        this.collected = false;
    }
    collect() {
        if (this.collected) {
            // Only 1 time allowed because we can't copy a tree. (And we don't need this).
            throw new Error('Builders can only be collected once!');
        }
        this.collected = true;
        return { experimentalTree: this.overloadTree, tree: this.legacyTree };
    }
    set(argTypes, func) {
        this.overloadTree.addOverload(argTypes, func);
        this.legacyTree.addOverload(argTypes, func);
        return this;
    }
    /**
     * A legacy function should be set only after all other functions are set
     * @param argTypes
     * @param func
     */
    setLegacy(argTypes, func) {
        this.legacyTree.addLegacyOverload(argTypes, func);
        return this;
    }
    copy({ from, to }) {
        const impl = this.overloadTree.getImplementationExact(from);
        if (!impl) {
            throw new Err.UnexpectedError('Tried to copy implementation, but types not found', { from, to });
        }
        return this.set(to, impl);
    }
    onUnary(type, op) {
        return this.set([type], context => ([val]) => op(context)(val));
    }
    onUnaryTyped(type, op) {
        return this.set([type], context => ([val]) => op(context)(val.typedValue));
    }
    onBinary(types, op) {
        return this.set(types, context => ([left, right]) => op(context)(left, right));
    }
    onBinaryTyped(types, op) {
        return this.set(types, context => ([left, right]) => op(context)(left.typedValue, right.typedValue));
    }
    onTernaryTyped(types, op) {
        return this.set(types, context => ([a1, a2, a3]) => op(context)(a1.typedValue, a2.typedValue, a3.typedValue));
    }
    onTernary(types, op) {
        return this.set(types, context => ([a1, a2, a3]) => op(context)(a1, a2, a3));
    }
    onQuaternaryTyped(types, op) {
        return this.set(types, context => ([a1, a2, a3, a4]) => op(context)(a1.typedValue, a2.typedValue, a3.typedValue, a4.typedValue));
    }
    onTerm1(op) {
        return this.set(['term'], context => ([term]) => op(context)(term));
    }
    onLiteral1(op) {
        return this.set(['literal'], context => ([term]) => op(context)(term));
    }
    onBoolean1(op) {
        return this
            .set([C.TypeURL.XSD_BOOLEAN], context => ([lit]) => op(context)(lit));
    }
    onBoolean1Typed(op) {
        return this
            .set([C.TypeURL.XSD_BOOLEAN], context => ([lit]) => op(context)(lit.typedValue));
    }
    onString1(op) {
        return this
            .set([C.TypeURL.XSD_STRING], context => ([lit]) => op(context)(lit));
    }
    onString1Typed(op) {
        return this
            .set([C.TypeURL.XSD_STRING], context => ([lit]) => op(context)(lit.typedValue));
    }
    onLangString1(op) {
        return this
            .set([C.TypeURL.RDF_LANG_STRING], context => ([lit]) => op(context)(lit));
    }
    onStringly1(op) {
        return this
            .set([C.TypeAlias.SPARQL_STRINGLY], context => ([lit]) => op(context)(lit));
    }
    onStringly1Typed(op) {
        return this
            .set([C.TypeAlias.SPARQL_STRINGLY], context => ([lit]) => op(context)(lit.typedValue));
    }
    onNumeric1(op) {
        return this
            .set([C.TypeAlias.SPARQL_NUMERIC], context => ([val]) => op(context)(val))
            .invalidLexicalForm([C.TypeAlias.SPARQL_NON_LEXICAL], 1);
    }
    onDateTime1(op) {
        return this
            .set([C.TypeURL.XSD_DATE_TIME], context => ([val]) => op(context)(val))
            .invalidLexicalForm([C.TypeAlias.SPARQL_NON_LEXICAL], 1);
    }
    /**
     * We return the base types and not the provided types because we don't want to create invalid terms.
     * Providing negative number to a function unary - for example should not
     * return a term of type negative number having a positive value.
     * @param op the numeric operator performed
     */
    numericConverter(op) {
        const evalHelper = (context) => (arg) => op(context)(arg.typedValue);
        return this.onBinary([Consts_1.TypeURL.XSD_INTEGER], context => arg => integer(evalHelper(context)(arg)))
            .onBinary([Consts_1.TypeURL.XSD_DECIMAL], context => arg => decimal(evalHelper(context)(arg)))
            .onBinary([Consts_1.TypeURL.XSD_FLOAT], context => arg => float(evalHelper(context)(arg)))
            .onBinary([Consts_1.TypeURL.XSD_DOUBLE], context => arg => double(evalHelper(context)(arg)))
            .invalidLexicalForm([C.TypeAlias.SPARQL_NON_LEXICAL], 1);
    }
    /**
     * !!! Be aware when using this function, it will create different overloads with different return types !!!
     * Arithmetic operators take 2 numeric arguments, and return a single numerical
     * value. The type of the return value is heavily dependant on the types of the
     * input arguments. In JS everything is a double, but in SPARQL it is not.
     *
     * The different arguments are handled by type promotion and subtype substitution.
     * The way numeric function arguments work is described here:
     * https://www.w3.org/TR/xpath20/#mapping
     * Above url is referenced in the sparql spec: https://www.w3.org/TR/sparql11-query/#OperatorMapping
     */
    arithmetic(op) {
        const evalHelper = (context) => (left, right) => op(context)(left.typedValue, right.typedValue);
        return this.onBinary([Consts_1.TypeURL.XSD_INTEGER, Consts_1.TypeURL.XSD_INTEGER], context => (left, right) => integer(evalHelper(context)(left, right)))
            .onBinary([Consts_1.TypeURL.XSD_DECIMAL, Consts_1.TypeURL.XSD_DECIMAL], context => (left, right) => decimal(evalHelper(context)(left, right)))
            .onBinary([Consts_1.TypeURL.XSD_FLOAT, Consts_1.TypeURL.XSD_FLOAT], context => (left, right) => float(evalHelper(context)(left, right)))
            .onBinary([Consts_1.TypeURL.XSD_DOUBLE, Consts_1.TypeURL.XSD_DOUBLE], context => (left, right) => double(evalHelper(context)(left, right)))
            .setLegacy([Consts_1.TypeAlias.SPARQL_NUMERIC, Consts_1.TypeAlias.SPARQL_NUMERIC], (context) => ([left, right]) => Builder.legacyArithmeticPromotion[left.mainSparqlType][right.mainSparqlType](op(context)(left.typedValue, right.typedValue)));
    }
    numberTest(test) {
        return this.numeric(context => ([left, right]) => {
            const result = test(context)(left.typedValue, right.typedValue);
            return bool(result);
        });
    }
    stringTest(test) {
        return this
            .set([C.TypeURL.XSD_STRING, C.TypeURL.XSD_STRING], context => ([left, right]) => {
            const result = test(context)(left.typedValue, right.typedValue);
            return bool(result);
        })
            .invalidLexicalForm([C.TypeAlias.SPARQL_NON_LEXICAL, C.TypeURL.XSD_STRING], 1)
            .invalidLexicalForm([C.TypeURL.XSD_STRING, C.TypeAlias.SPARQL_NON_LEXICAL], 2);
    }
    booleanTest(test) {
        return this
            .set([C.TypeURL.XSD_BOOLEAN, C.TypeURL.XSD_BOOLEAN], context => ([left, right]) => {
            const result = test(context)(left.typedValue, right.typedValue);
            return bool(result);
        })
            .invalidLexicalForm([C.TypeAlias.SPARQL_NON_LEXICAL, C.TypeURL.XSD_BOOLEAN], 1)
            .invalidLexicalForm([C.TypeURL.XSD_BOOLEAN, C.TypeAlias.SPARQL_NON_LEXICAL], 2);
    }
    dateTimeTest(test) {
        return this
            .set([C.TypeURL.XSD_DATE_TIME, C.TypeURL.XSD_DATE_TIME], context => ([left, right]) => {
            const result = test(context)(left.typedValue, right.typedValue);
            return bool(result);
        })
            .invalidLexicalForm([C.TypeAlias.SPARQL_NON_LEXICAL, C.TypeURL.XSD_DATE_TIME], 1)
            .invalidLexicalForm([C.TypeURL.XSD_DATE_TIME, C.TypeAlias.SPARQL_NON_LEXICAL], 2);
    }
    numeric(op) {
        return this
            .set([C.TypeAlias.SPARQL_NUMERIC, C.TypeAlias.SPARQL_NUMERIC], op)
            .invalidLexicalForm([C.TypeAlias.SPARQL_NUMERIC, C.TypeAlias.SPARQL_NON_LEXICAL], 2)
            .invalidLexicalForm([C.TypeAlias.SPARQL_NON_LEXICAL, C.TypeAlias.SPARQL_NUMERIC], 1);
    }
    invalidLexicalForm(types, index) {
        return this.set(types, () => (args) => {
            throw new Err.InvalidLexicalForm(args[index - 1].toRDF());
        });
    }
}
exports.Builder = Builder;
Builder.legacyArithmeticPromotion = {
    integer: {
        integer: num => new expressions_1.IntegerLiteral(num),
        decimal: num => new expressions_1.DecimalLiteral(num),
        float: num => new expressions_1.FloatLiteral(num),
        double: num => new expressions_1.DoubleLiteral(num),
    },
    decimal: {
        integer: num => new expressions_1.DecimalLiteral(num),
        decimal: num => new expressions_1.DecimalLiteral(num),
        float: num => new expressions_1.FloatLiteral(num),
        double: num => new expressions_1.DoubleLiteral(num),
    },
    float: {
        integer: num => new expressions_1.FloatLiteral(num),
        decimal: num => new expressions_1.FloatLiteral(num),
        float: num => new expressions_1.FloatLiteral(num),
        double: num => new expressions_1.DoubleLiteral(num),
    },
    double: {
        integer: num => new expressions_1.DoubleLiteral(num),
        decimal: num => new expressions_1.DoubleLiteral(num),
        float: num => new expressions_1.DoubleLiteral(num),
        double: num => new expressions_1.DoubleLiteral(num),
    },
};
// ----------------------------------------------------------------------------
// Literal Construction helpers
// ----------------------------------------------------------------------------
function bool(val) {
    return new E.BooleanLiteral(val);
}
exports.bool = bool;
function integer(num, dt) {
    if (dt && !(0, TypeHandling_1.isInternalSubType)(dt, Consts_1.TypeURL.XSD_INTEGER)) {
        throw new Error('apple');
    }
    return new E.IntegerLiteral(num, dt);
}
exports.integer = integer;
function decimal(num, dt) {
    if (dt && !(0, TypeHandling_1.isInternalSubType)(dt, Consts_1.TypeURL.XSD_DECIMAL)) {
        throw new Error('apple');
    }
    return new E.DecimalLiteral(num, dt);
}
exports.decimal = decimal;
function float(num, dt) {
    if (dt && !(0, TypeHandling_1.isInternalSubType)(dt, Consts_1.TypeURL.XSD_FLOAT)) {
        throw new Error('apple');
    }
    return new E.FloatLiteral(num, dt);
}
exports.float = float;
function double(num, dt) {
    if (dt && !(0, TypeHandling_1.isInternalSubType)(dt, Consts_1.TypeURL.XSD_DOUBLE)) {
        throw new Error('apple');
    }
    return new E.DoubleLiteral(num, dt);
}
exports.double = double;
function string(str) {
    return new E.StringLiteral(str);
}
exports.string = string;
function langString(str, lang) {
    return new E.LangStringLiteral(str, lang);
}
exports.langString = langString;
function dateTime(date, str) {
    return new E.DateTimeLiteral(date, str);
}
exports.dateTime = dateTime;
function expressionToVar(variableExpression) {
    return DF.variable(variableExpression.name.slice(1));
}
exports.expressionToVar = expressionToVar;
//# sourceMappingURL=Helpers.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/functions/LegacyTree.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LegacyTree = void 0;
const expressions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/index.js");
const TypeHandling_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/TypeHandling.js");
/**
 * Maps argument types on their specific implementation in a tree like structure.
 * When adding any functionality to this class, make sure you add it to SpecialFunctions as well.
 */
class LegacyTree {
    constructor(legacyImportance) {
        this.implementation = undefined;
        this.subTrees = Object.create(null);
        this.legacyImportance = legacyImportance || 0;
    }
    /**
     * Searches in a depth first way for the best matching overload. considering this a the tree's root.
     * @param args
     */
    search(args) {
        // SearchStack is a stack of all node's that need to be checked for implementation.
        // It provides an easy way to keep order in our search.
        const searchStack = [];
        const startIndex = 0;
        if (args.length === 0) {
            return this.implementation;
        }
        // GetSubTreeWithArg return a SearchStack containing the node's that should be contacted next.
        // We also log the index since there is no other way to remember this index.
        // the provided stack should be pushed on top of our search stack since it also has it's order.
        searchStack.push(...this.getSubTreeWithArg(args[startIndex]).map(node => ({ node, index: startIndex + 1 })));
        while (searchStack.length > 0) {
            const { index, node } = searchStack.pop();
            if (index === args.length) {
                return node.implementation;
            }
            searchStack.push(...node.getSubTreeWithArg(args[index]).map(item => ({ node: item, index: index + 1 })));
        }
        return this.implementation;
    }
    /**
     * Adds an overload to the tree structure considering this as the tree's root.
     * @param argumentTypes a list of ArgumentTypes that would need to be provided in the same order to
     * get the implementation.
     * @param func the implementation for this overload.
     */
    addOverload(argumentTypes, func) {
        this._addOverload([...argumentTypes], func, false, 0);
    }
    addLegacyOverload(argumentTypes, func) {
        this._addOverload([...argumentTypes], func, true, 0);
    }
    _addOverload(argumentTypes, func, alwaysOverride, prevPrio) {
        const [argumentType, ..._argumentTypes] = argumentTypes;
        if (!argumentType) {
            if (alwaysOverride || this.legacyImportance <= prevPrio) {
                this.implementation = func;
            }
            return;
        }
        const holder = (0, TypeHandling_1.mainSparqlType)(argumentType);
        for (const mainType of holder.types) {
            if (alwaysOverride || !this.subTrees[mainType]) {
                this.subTrees[mainType] = new LegacyTree(holder.prio);
            }
            this.subTrees[mainType]._addOverload(_argumentTypes, func, alwaysOverride, holder.prio);
        }
    }
    /**
     * @param arg term to try and match to possible overloads of this node.
     * @returns SearchStack a stack with top element the next node that should be asked for implementation or overload.
     */
    getSubTreeWithArg(arg) {
        const literalExpression = (0, expressions_1.isLiteralTermExpression)(arg);
        const res = [];
        // These types refer to Type exported by lib/util/Consts.ts
        if (this.subTrees.term) {
            res.push(this.subTrees.term);
        }
        // TermTypes are defined in E.TermType.
        if (this.subTrees[arg.termType]) {
            res.push(this.subTrees[arg.termType]);
        }
        if (literalExpression && this.subTrees[literalExpression.mainSparqlType]) {
            res.push(this.subTrees[literalExpression.mainSparqlType]);
        }
        return res;
    }
}
exports.LegacyTree = LegacyTree;
//# sourceMappingURL=LegacyTree.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/functions/NamedFunctions.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.namedDefinitions = void 0;
const Consts_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Consts.js");
const Err = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Errors.js");
const Parsing_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Parsing.js");
const Helpers_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/Helpers.js");
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// Begin definitions.
// ----------------------------------------------------------------------------
// XPath Constructor functions
// https://www.w3.org/TR/sparql11-query/#
// https://www.w3.org/TR/xpath-functions/#casting-from-primitive-to-primitive
// ----------------------------------------------------------------------------
/**
 * https://www.w3.org/TR/xpath-functions/#casting-to-string
 */
const xsdToString = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(Consts_1.TypeURL.XSD_STRING)
        .onNumeric1(() => (val) => (0, Helpers_1.string)((0, Helpers_1.float)(val.typedValue).str()))
        .onBoolean1Typed(() => val => (0, Helpers_1.string)((0, Helpers_1.bool)(val).str()))
        .onTerm1(() => (val) => (0, Helpers_1.string)(val.str()))
        .collect(),
};
const xsdToFloat = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(Consts_1.TypeURL.XSD_FLOAT)
        .onNumeric1(() => (val) => (0, Helpers_1.float)(val.typedValue))
        .onBoolean1Typed(() => val => (0, Helpers_1.float)(val ? 1 : 0))
        .onUnary(Consts_1.TypeURL.XSD_STRING, () => (val) => {
        const result = (0, Parsing_1.parseXSDFloat)(val.str());
        if (result === undefined) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_FLOAT);
        }
        return (0, Helpers_1.float)(result);
    })
        .copy({ from: [Consts_1.TypeURL.XSD_STRING], to: [Consts_1.TypeAlias.SPARQL_NON_LEXICAL] })
        .collect(),
};
const xsdToDouble = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(Consts_1.TypeURL.XSD_DOUBLE)
        .onNumeric1(() => (val) => (0, Helpers_1.double)(val.typedValue))
        .onBoolean1Typed(() => val => (0, Helpers_1.double)(val ? 1 : 0))
        .onUnary(Consts_1.TypeURL.XSD_STRING, () => (val) => {
        const result = (0, Parsing_1.parseXSDFloat)(val.str());
        if (result === undefined) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_DOUBLE);
        }
        return (0, Helpers_1.double)(result);
    })
        .copy({ from: [Consts_1.TypeURL.XSD_STRING], to: [Consts_1.TypeAlias.SPARQL_NON_LEXICAL] })
        .collect(),
};
const xsdToDecimal = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(Consts_1.TypeURL.XSD_DECIMAL)
        .onNumeric1(() => (val) => {
        const result = (0, Parsing_1.parseXSDDecimal)(val.str());
        if (result === undefined) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_DECIMAL);
        }
        return (0, Helpers_1.decimal)(result);
    })
        .onString1(() => (val) => {
        const str = val.str();
        const result = /^([+-])?(\d+(\.\d+)?)$/u.test(str) ? (0, Parsing_1.parseXSDDecimal)(str) : undefined;
        if (result === undefined) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_DECIMAL);
        }
        return (0, Helpers_1.decimal)(result);
    })
        .copy({ from: [Consts_1.TypeURL.XSD_STRING], to: [Consts_1.TypeAlias.SPARQL_NON_LEXICAL] })
        .onBoolean1Typed(() => val => (0, Helpers_1.decimal)(val ? 1 : 0))
        .collect(),
};
const xsdToInteger = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(Consts_1.TypeURL.XSD_INTEGER)
        .onBoolean1Typed(() => val => (0, Helpers_1.integer)(val ? 1 : 0))
        .onNumeric1(() => (val) => {
        const result = (0, Parsing_1.parseXSDInteger)(val.str());
        if (result === undefined) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_INTEGER);
        }
        return (0, Helpers_1.integer)(result);
    })
        .onString1(() => (val) => {
        const str = val.str();
        const result = /^\d+$/u.test(str) ? (0, Parsing_1.parseXSDInteger)(str) : undefined;
        if (result === undefined) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_INTEGER);
        }
        return (0, Helpers_1.integer)(result);
    })
        .copy({ from: [Consts_1.TypeAlias.SPARQL_NUMERIC], to: [Consts_1.TypeAlias.SPARQL_NON_LEXICAL] })
        .collect(),
};
const xsdToDatetime = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(Consts_1.TypeURL.XSD_DATE_TIME)
        .onUnary(Consts_1.TypeURL.XSD_DATE_TIME, () => (val) => val)
        .onUnary(Consts_1.TypeURL.XSD_STRING, () => (val) => {
        const date = new Date(val.str());
        if (Number.isNaN(date.getTime())) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_DATE_TIME);
        }
        return (0, Helpers_1.dateTime)(date, val.str());
    })
        .copy({ from: [Consts_1.TypeURL.XSD_STRING], to: [Consts_1.TypeAlias.SPARQL_NON_LEXICAL] })
        .collect(),
};
const xsdToBoolean = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(Consts_1.TypeURL.XSD_BOOLEAN)
        .onNumeric1(() => (val) => (0, Helpers_1.bool)(val.coerceEBV()))
        .onUnary(Consts_1.TypeURL.XSD_BOOLEAN, () => (val) => (0, Helpers_1.bool)(val.coerceEBV()))
        .onUnary(Consts_1.TypeURL.XSD_STRING, () => (val) => {
        switch (val.str()) {
            case 'true':
                return (0, Helpers_1.bool)(true);
            case 'false':
                return (0, Helpers_1.bool)(false);
            case '1':
                return (0, Helpers_1.bool)(true);
            case '0':
                return (0, Helpers_1.bool)(false);
            default:
                throw new Err.CastError(val, Consts_1.TypeURL.XSD_BOOLEAN);
        }
    })
        .copy({ from: [Consts_1.TypeURL.XSD_STRING], to: [Consts_1.TypeAlias.SPARQL_NON_LEXICAL] })
        .collect(),
};
// End definitions.
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
exports.namedDefinitions = {
    // --------------------------------------------------------------------------
    // XPath Constructor functions
    // https://www.w3.org/TR/sparql11-query/#FunctionMapping
    // --------------------------------------------------------------------------
    [Consts_1.TypeURL.XSD_STRING]: xsdToString,
    [Consts_1.TypeURL.XSD_FLOAT]: xsdToFloat,
    [Consts_1.TypeURL.XSD_DOUBLE]: xsdToDouble,
    [Consts_1.TypeURL.XSD_DECIMAL]: xsdToDecimal,
    [Consts_1.TypeURL.XSD_INTEGER]: xsdToInteger,
    [Consts_1.TypeURL.XSD_DATE_TIME]: xsdToDatetime,
    [Consts_1.TypeURL.XSD_DATE]: xsdToDatetime,
    [Consts_1.TypeURL.XSD_BOOLEAN]: xsdToBoolean,
};
//# sourceMappingURL=NamedFunctions.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/functions/OverloadTree.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OverloadTree = void 0;
const expressions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/index.js");
const Consts_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Consts.js");
const TypeHandling_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/TypeHandling.js");
const Helpers_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/Helpers.js");
/**
 * Maps argument types on their specific implementation in a tree like structure.
 * When adding any functionality to this class, make sure you add it to SpecialFunctions as well.
 */
class OverloadTree {
    constructor(identifier, depth) {
        this.identifier = identifier;
        this.implementation = undefined;
        this.generalOverloads = Object.create(null);
        this.literalOverLoads = [];
        this.depth = depth || 0;
        this.promotionCount = undefined;
    }
    getSubtree(overrideType) {
        const generalType = (0, TypeHandling_1.asGeneralType)(overrideType);
        if (generalType) {
            return this.generalOverloads[generalType];
        }
        for (const [type, overloadTree] of this.literalOverLoads) {
            if (overrideType === type) {
                return overloadTree;
            }
        }
        return undefined;
    }
    /**
     * Get the implementation for the types that exactly match @param args .
     */
    getImplementationExact(args) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this
        let node = this;
        for (const expression of args) {
            node = node.getSubtree(expression);
            if (!node) {
                return undefined;
            }
        }
        return node.implementation;
    }
    getOverloadCacheIdentifier(args) {
        return this.identifier + args.map(term => {
            const literalExpression = (0, expressions_1.isLiteralTermExpression)(term);
            return literalExpression ? literalExpression.dataType : term.termType;
        }).join('');
    }
    /**
     * Searches in a depth first way for the best matching overload. considering this a the tree's root.
     * @param args:
     * @param overloadCache
     * @param superTypeProvider
     */
    search(args, superTypeProvider, overloadCache) {
        const identifier = this.getOverloadCacheIdentifier(args);
        if (overloadCache.has(identifier)) {
            return overloadCache.get(identifier);
        }
        // SearchStack is a stack of all node's that need to be checked for implementation.
        // It provides an easy way to keep order in our search.
        const searchStack = [];
        const startIndex = 0;
        if (args.length === 0) {
            return this.implementation;
        }
        // GetSubTreeWithArg return a SearchStack containing the node's that should be contacted next.
        // We also log the index since there is no other way to remember this index.
        // the provided stack should be pushed on top of our search stack since it also has it's order.
        searchStack.push(...this.getSubTreeWithArg(args[startIndex], superTypeProvider).map(node => ({ node, index: startIndex + 1 })));
        while (searchStack.length > 0) {
            const { index, node } = searchStack.pop();
            // We check the implementation because it would be possible a path is created but not implemented.
            // ex: f(double, double, double) and f(term, term). and calling f(double, double).
            if (index === args.length && node.implementation) {
                overloadCache.set(identifier, node.implementation);
                return node.implementation;
            }
            searchStack.push(...node.getSubTreeWithArg(args[index], superTypeProvider).map(item => ({ node: item, index: index + 1 })));
        }
        // Calling a function with one argument but finding no implementation should return no implementation.
        // Not even the one with no arguments.
        overloadCache.set(identifier, undefined);
        return undefined;
    }
    /**
     * Adds an overload to the tree structure considering this as the tree's root.
     * @param ExperimentalArgumentTypes a list of ExperimentalArgumentTypes that would need to be provided in
     * the same order to get the implementation.
     * @param func the implementation for this overload.
     */
    addOverload(ExperimentalArgumentTypes, func) {
        this._addOverload([...ExperimentalArgumentTypes], func, 0);
    }
    _addOverload(ExperimentalArgumentTypes, func, promotionCount) {
        const [experimentalArgumentType, ..._experimentalArgumentTypes] = ExperimentalArgumentTypes;
        if (!experimentalArgumentType) {
            if (this.promotionCount === undefined || promotionCount <= this.promotionCount) {
                this.promotionCount = promotionCount;
                this.implementation = func;
            }
            return;
        }
        let nextTree = this.getSubtree(experimentalArgumentType);
        if (!nextTree) {
            const newNode = new OverloadTree(this.identifier, this.depth + 1);
            const generalType = (0, TypeHandling_1.asGeneralType)(experimentalArgumentType);
            if (generalType) {
                this.generalOverloads[generalType] = newNode;
            }
            const overrideType = (0, TypeHandling_1.asOverrideType)(experimentalArgumentType);
            if (overrideType) {
                this.literalOverLoads.push([overrideType, newNode]);
            }
            nextTree = newNode;
        }
        nextTree._addOverload(_experimentalArgumentTypes, func, promotionCount);
        // Defined by https://www.w3.org/TR/xpath-31/#promotion .
        // e.g. When a function takes a string, it can also accept a XSD_ANY_URI if it's cast first.
        // TODO: When promoting decimal type a cast needs to be preformed.
        if (experimentalArgumentType === Consts_1.TypeURL.XSD_STRING) {
            this.addPromotedOverload(Consts_1.TypeURL.XSD_ANY_URI, func, arg => (0, Helpers_1.string)(arg.str()), _experimentalArgumentTypes, promotionCount);
        }
        // TODO: in case of decimal a round needs to happen.
        if (experimentalArgumentType === Consts_1.TypeURL.XSD_DOUBLE) {
            this.addPromotedOverload(Consts_1.TypeURL.XSD_FLOAT, func, arg => (0, Helpers_1.double)(arg.typedValue), _experimentalArgumentTypes, promotionCount);
            this.addPromotedOverload(Consts_1.TypeURL.XSD_DECIMAL, func, arg => (0, Helpers_1.double)(arg.typedValue), _experimentalArgumentTypes, promotionCount);
        }
        if (experimentalArgumentType === Consts_1.TypeURL.XSD_FLOAT) {
            this.addPromotedOverload(Consts_1.TypeURL.XSD_DECIMAL, func, arg => (0, Helpers_1.float)(arg.typedValue), _experimentalArgumentTypes, promotionCount);
        }
    }
    addPromotedOverload(typeToPromote, func, conversionFunction, ExperimentalArgumentTypes, promotionCount) {
        let nextTree = this.getSubtree(typeToPromote);
        if (!nextTree) {
            const newNode = new OverloadTree(this.identifier, this.depth + 1);
            this.literalOverLoads.push([typeToPromote, newNode]);
            nextTree = newNode;
        }
        nextTree._addOverload(ExperimentalArgumentTypes, funcConf => args => func(funcConf)([
            ...args.slice(0, this.depth),
            conversionFunction(args[this.depth]),
            ...args.slice(this.depth + 1, args.length),
        ]), promotionCount + 1);
    }
    /**
     * @param arg term to try and match to possible overloads of this node.
     * @returns SearchStack a stack with top element the next node that should be asked for implementation or overload.
     */
    getSubTreeWithArg(arg, openWorldType) {
        const res = [];
        const literalExpression = (0, expressions_1.isLiteralTermExpression)(arg);
        // These types refer to Type exported by lib/util/Consts.ts
        if (this.generalOverloads.term) {
            res.push(this.generalOverloads.term);
        }
        // TermTypes are defined in E.TermType.
        if (this.generalOverloads[arg.termType]) {
            res.push(this.generalOverloads[arg.termType]);
        }
        if (literalExpression) {
            // Defending implementation. Mainly the scary sort.
            // This function has cost O(n) + O(m * log(m)) with n = amount of overloads and m = amount of matched overloads
            // We map over each of the overloads, filter only the once that can be used (this is normally 1 or 2).
            // The sort function on an array with 1 or 2 arguments will be negligible.
            const concreteType = (0, TypeHandling_1.asKnownLiteralType)(literalExpression.dataType);
            let subExtensionTable;
            if (concreteType) {
                // Concrete dataType is known by sparqlee.
                subExtensionTable = TypeHandling_1.superTypeDictTable[concreteType];
            }
            else {
                // Datatype is a custom datatype
                subExtensionTable = (0, TypeHandling_1.getSuperTypes)(literalExpression.dataType, openWorldType);
            }
            const matches = this.literalOverLoads.filter(([matchType, _]) => matchType in subExtensionTable)
                .map(([matchType, tree]) => [subExtensionTable[matchType], tree]);
            matches.sort(([prioA, matchTypeA], [prioB, matchTypeB]) => prioA - prioB);
            res.push(...matches.map(([_, sortedType]) => sortedType));
        }
        return res;
    }
}
exports.OverloadTree = OverloadTree;
//# sourceMappingURL=OverloadTree.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/functions/RegularFunctions.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.definitions = void 0;
const bignumber_js_1 = __quadstore_comunica_require__("../node_modules/bignumber.js/bignumber.js");
const hash_js_1 = __quadstore_comunica_require__("../node_modules/hash.js/lib/hash.js");
const rdf_data_factory_1 = __quadstore_comunica_require__("../node_modules/rdf-data-factory/index.js");
const relative_to_absolute_iri_1 = __quadstore_comunica_require__("../node_modules/relative-to-absolute-iri/index.js");
const spark_md5_1 = __quadstore_comunica_require__("../node_modules/spark-md5/spark-md5.js");
const uuid = __quadstore_comunica_require__("../packages/uuid/dist/index.js");
const E = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/index.js");
const TermTransformer_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/transformers/TermTransformer.js");
const C = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Consts.js");
const Consts_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Consts.js");
const Err = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Errors.js");
const P = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Parsing.js");
const Helpers_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/Helpers.js");
const X = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/XPathFunctions.js");
const DF = new rdf_data_factory_1.DataFactory();
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// Begin definitions
// ----------------------------------------------------------------------------
// Operator Mapping
// https://www.w3.org/TR/sparql11-query/#OperatorMapping
// ----------------------------------------------------------------------------
const not = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.NOT)
        .onTerm1(() => val => (0, Helpers_1.bool)(!val.coerceEBV()))
        .collect(),
};
const unaryPlus = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.UPLUS)
        .numericConverter(() => val => val)
        .collect(),
};
const unaryMinus = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.UMINUS)
        .numericConverter(() => val => -val)
        .collect(),
};
const multiplication = {
    arity: 2,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.MULTIPLICATION)
        .arithmetic(() => (left, right) => new bignumber_js_1.BigNumber(left).times(right).toNumber())
        .collect(),
};
const division = {
    arity: 2,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.DIVISION)
        .arithmetic(() => (left, right) => new bignumber_js_1.BigNumber(left).div(right).toNumber())
        .onBinaryTyped([Consts_1.TypeURL.XSD_INTEGER, Consts_1.TypeURL.XSD_INTEGER], () => (left, right) => {
        if (right === 0) {
            throw new Err.ExpressionError('Integer division by 0');
        }
        return (0, Helpers_1.decimal)(new bignumber_js_1.BigNumber(left).div(right).toNumber());
    })
        .collect(),
};
const addition = {
    arity: 2,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.ADDITION)
        .arithmetic(() => (left, right) => new bignumber_js_1.BigNumber(left).plus(right).toNumber())
        .collect(),
};
const subtraction = {
    arity: 2,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.SUBTRACTION)
        .arithmetic(() => (left, right) => new bignumber_js_1.BigNumber(left).minus(right).toNumber())
        .collect(),
};
// https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal
const equality = {
    arity: 2,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.EQUAL)
        .numberTest(() => (left, right) => left === right)
        .stringTest(() => (left, right) => left.localeCompare(right) === 0)
        .booleanTest(() => (left, right) => left === right)
        .dateTimeTest(() => (left, right) => left.getTime() === right.getTime())
        .set(['term', 'term'], () => ([left, right]) => (0, Helpers_1.bool)(RDFTermEqual(left, right)))
        .collect(),
};
function RDFTermEqual(_left, _right) {
    const left = _left.toRDF();
    const right = _right.toRDF();
    const val = left.equals(right);
    if ((left.termType === 'Literal') && (right.termType === 'Literal')) {
        throw new Err.RDFEqualTypeError([_left, _right]);
    }
    return val;
}
const inequality = {
    arity: 2,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.NOT_EQUAL)
        .numberTest(() => (left, right) => left !== right)
        .stringTest(() => (left, right) => left.localeCompare(right) !== 0)
        .booleanTest(() => (left, right) => left !== right)
        .dateTimeTest(() => (left, right) => left.getTime() !== right.getTime())
        .set(['term', 'term'], () => ([left, right]) => (0, Helpers_1.bool)(!RDFTermEqual(left, right)))
        .collect(),
};
const lesserThan = {
    arity: 2,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.LT)
        .numberTest(() => (left, right) => left < right)
        .stringTest(() => (left, right) => left.localeCompare(right) === -1)
        .booleanTest(() => (left, right) => left < right)
        .dateTimeTest(() => (left, right) => left.getTime() < right.getTime())
        .collect(),
};
const greaterThan = {
    arity: 2,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.GT)
        .numberTest(() => (left, right) => left > right)
        .stringTest(() => (left, right) => left.localeCompare(right) === 1)
        .booleanTest(() => (left, right) => left > right)
        .dateTimeTest(() => (left, right) => left.getTime() > right.getTime())
        .collect(),
};
const lesserThanEqual = {
    arity: 2,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.LTE)
        .numberTest(() => (left, right) => left <= right)
        .stringTest(() => (left, right) => left.localeCompare(right) !== 1)
        .booleanTest(() => (left, right) => left <= right)
        .dateTimeTest(() => (left, right) => left.getTime() <= right.getTime())
        .collect(),
};
const greaterThanEqual = {
    arity: 2,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.GTE)
        .numberTest(() => (left, right) => left >= right)
        .stringTest(() => (left, right) => left.localeCompare(right) !== -1)
        .booleanTest(() => (left, right) => left >= right)
        .dateTimeTest(() => (left, right) => left.getTime() >= right.getTime())
        .collect(),
};
// ----------------------------------------------------------------------------
// Functions on RDF Terms
// https://www.w3.org/TR/sparql11-query/#func-rdfTerms
// ----------------------------------------------------------------------------
/**
 * https://www.w3.org/TR/sparql11-query/#func-isIRI
 */
const isIRI = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.IS_IRI)
        .onTerm1(() => term => (0, Helpers_1.bool)(term.termType === 'namedNode'))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-isBlank
 */
const isBlank = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.IS_BLANK)
        .onTerm1(() => term => (0, Helpers_1.bool)(term.termType === 'blankNode'))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-isLiteral
 */
const isLiteral = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.IS_LITERAL)
        .onTerm1(() => term => (0, Helpers_1.bool)(term.termType === 'literal'))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-isNumeric
 */
const isNumeric = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.IS_NUMERIC)
        .onNumeric1(() => term => (0, Helpers_1.bool)(true))
        .onTerm1(() => term => (0, Helpers_1.bool)(false))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-str
 */
const STR = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.STR)
        .onTerm1(() => term => (0, Helpers_1.string)(term.str()))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-lang
 */
const lang = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.LANG)
        .onLiteral1(() => lit => (0, Helpers_1.string)(lit.language || ''))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-datatype
 */
const datatype = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.DATATYPE)
        .onLiteral1(() => lit => new E.NamedNode(lit.dataType))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-iri
 */
const IRI = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.IRI)
        .set(['namedNode'], context => args => {
        const lit = args[0];
        const iri = (0, relative_to_absolute_iri_1.resolve)(lit.str(), context.baseIRI || '');
        return new E.NamedNode(iri);
    })
        .onString1(context => lit => {
        const iri = (0, relative_to_absolute_iri_1.resolve)(lit.str(), context.baseIRI || '');
        return new E.NamedNode(iri);
    })
        .collect(),
};
// See special functions
// const BNODE = {};
/**
 * https://www.w3.org/TR/sparql11-query/#func-strdt
 */
const STRDT = {
    arity: 2,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.STRDT).set([Consts_1.TypeURL.XSD_STRING, 'namedNode'], ({ superTypeProvider, enableExtendedXsdTypes }) => ([str, iri]) => {
        const lit = DF.literal(str.typedValue, DF.namedNode(iri.value));
        return new TermTransformer_1.TermTransformer(superTypeProvider, enableExtendedXsdTypes).transformLiteral(lit);
    }).collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-strlang
 */
const STRLANG = {
    arity: 2,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.STRLANG)
        .onBinaryTyped([Consts_1.TypeURL.XSD_STRING, Consts_1.TypeURL.XSD_STRING], () => (val, language) => new E.LangStringLiteral(val, language.toLowerCase()))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-uuid
 */
const UUID = {
    arity: 0,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.UUID)
        .set([], () => () => new E.NamedNode(`urn:uuid:${uuid.v4()}`))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-struuid
 */
const STRUUID = {
    arity: 0,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.STRUUID)
        .set([], () => () => (0, Helpers_1.string)(uuid.v4()))
        .collect(),
};
// ----------------------------------------------------------------------------
// Functions on strings
// https://www.w3.org/TR/sparql11-query/#func-forms
// ----------------------------------------------------------------------------
/**
 * https://www.w3.org/TR/sparql11-query/#func-strlen
 */
const STRLEN = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.STRLEN)
        .onStringly1(() => str => (0, Helpers_1.integer)([...str.typedValue].length))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-substr
 */
const SUBSTR = {
    arity: [2, 3],
    overloads: (0, Helpers_1.declare)(C.RegularOperator.SUBSTR)
        .onBinaryTyped([Consts_1.TypeURL.XSD_STRING, Consts_1.TypeURL.XSD_INTEGER], () => (source, startingLoc) => (0, Helpers_1.string)([...source].slice(startingLoc - 1).join('')))
        .onBinary([Consts_1.TypeURL.RDF_LANG_STRING, Consts_1.TypeURL.XSD_INTEGER], () => (source, startingLoc) => {
        const sub = [...source.typedValue].slice(startingLoc.typedValue - 1).join('');
        return (0, Helpers_1.langString)(sub, source.language);
    })
        .onTernaryTyped([Consts_1.TypeURL.XSD_STRING, Consts_1.TypeURL.XSD_INTEGER, Consts_1.TypeURL.XSD_INTEGER], () => (source, startingLoc, length) => (0, Helpers_1.string)([...source].slice(startingLoc - 1, length + startingLoc - 1).join('')))
        .onTernary([Consts_1.TypeURL.RDF_LANG_STRING, Consts_1.TypeURL.XSD_INTEGER, Consts_1.TypeURL.XSD_INTEGER], () => (source, startingLoc, length) => {
        const sub = [...source.typedValue].slice(startingLoc.typedValue - 1, length.typedValue + startingLoc.typedValue - 1).join('');
        return (0, Helpers_1.langString)(sub, source.language);
    })
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-ucase
 */
const UCASE = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.UCASE)
        .onString1Typed(() => lit => (0, Helpers_1.string)(lit.toUpperCase()))
        .onLangString1(() => lit => (0, Helpers_1.langString)(lit.typedValue.toUpperCase(), lit.language))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-lcase
 */
const LCASE = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.LCASE)
        .onString1Typed(() => lit => (0, Helpers_1.string)(lit.toLowerCase()))
        .onLangString1(() => lit => (0, Helpers_1.langString)(lit.typedValue.toLowerCase(), lit.language))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-strstarts
 * for this and the following functions you'll see (string, langstring) is not allowed. This behaviour is defined in:
 * https://www.w3.org/TR/sparql11-query/#func-arg-compatibility
 */
const STRSTARTS = {
    arity: 2,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.STRSTARTS)
        .onBinaryTyped([Consts_1.TypeAlias.SPARQL_STRINGLY, Consts_1.TypeURL.XSD_STRING], () => (arg1, arg2) => (0, Helpers_1.bool)(arg1.startsWith(arg2)))
        .onBinary([Consts_1.TypeURL.RDF_LANG_STRING, Consts_1.TypeURL.RDF_LANG_STRING], () => (arg1, arg2) => {
        if (arg1.language !== arg2.language) {
            throw new Err.IncompatibleLanguageOperation(arg1, arg2);
        }
        return (0, Helpers_1.bool)(arg1.typedValue.startsWith(arg2.typedValue));
    })
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-strends
 */
const STRENDS = {
    arity: 2,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.STRENDS)
        .onBinaryTyped([Consts_1.TypeAlias.SPARQL_STRINGLY, Consts_1.TypeURL.XSD_STRING], () => (arg1, arg2) => (0, Helpers_1.bool)(arg1.endsWith(arg2)))
        .onBinary([Consts_1.TypeURL.RDF_LANG_STRING, Consts_1.TypeURL.RDF_LANG_STRING], () => (arg1, arg2) => {
        if (arg1.language !== arg2.language) {
            throw new Err.IncompatibleLanguageOperation(arg1, arg2);
        }
        return (0, Helpers_1.bool)(arg1.typedValue.endsWith(arg2.typedValue));
    })
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-contains
 */
const CONTAINS = {
    arity: 2,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.CONTAINS)
        .onBinaryTyped([Consts_1.TypeAlias.SPARQL_STRINGLY, Consts_1.TypeURL.XSD_STRING], () => (arg1, arg2) => (0, Helpers_1.bool)(arg1.includes(arg2)))
        .onBinary([Consts_1.TypeURL.RDF_LANG_STRING, Consts_1.TypeURL.RDF_LANG_STRING], () => (arg1, arg2) => {
        if (arg1.language !== arg2.language) {
            throw new Err.IncompatibleLanguageOperation(arg1, arg2);
        }
        return (0, Helpers_1.bool)(arg1.typedValue.includes(arg2.typedValue));
    })
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-strbefore
 */
const STRBEFORE = {
    arity: 2,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.STRBEFORE)
        .onBinaryTyped([Consts_1.TypeURL.XSD_STRING, Consts_1.TypeURL.XSD_STRING], () => (arg1, arg2) => (0, Helpers_1.string)(arg1.slice(0, Math.max(0, arg1.indexOf(arg2)))))
        .onBinary([Consts_1.TypeURL.RDF_LANG_STRING, Consts_1.TypeURL.XSD_STRING], () => (arg1, arg2) => {
        const [a1, a2] = [arg1.typedValue, arg2.typedValue];
        const sub = arg1.typedValue.slice(0, Math.max(0, a1.indexOf(a2)));
        return sub || !a2 ? (0, Helpers_1.langString)(sub, arg1.language) : (0, Helpers_1.string)(sub);
    })
        .onBinary([Consts_1.TypeURL.RDF_LANG_STRING, Consts_1.TypeURL.RDF_LANG_STRING], () => (arg1, arg2) => {
        if (arg1.language !== arg2.language) {
            throw new Err.IncompatibleLanguageOperation(arg1, arg2);
        }
        const [a1, a2] = [arg1.typedValue, arg2.typedValue];
        const sub = arg1.typedValue.slice(0, Math.max(0, a1.indexOf(a2)));
        return sub || !a2 ? (0, Helpers_1.langString)(sub, arg1.language) : (0, Helpers_1.string)(sub);
    })
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-strafter
 */
const STRAFTER = {
    arity: 2,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.STRAFTER)
        .onBinaryTyped([Consts_1.TypeURL.XSD_STRING, Consts_1.TypeURL.XSD_STRING], () => (arg1, arg2) => (0, Helpers_1.string)(arg1.slice(arg1.indexOf(arg2)).slice(arg2.length)))
        .onBinary([Consts_1.TypeURL.RDF_LANG_STRING, Consts_1.TypeURL.XSD_STRING], () => (arg1, arg2) => {
        const [a1, a2] = [arg1.typedValue, arg2.typedValue];
        const sub = a1.slice(a1.indexOf(a2)).slice(a2.length);
        return sub || !a2 ? (0, Helpers_1.langString)(sub, arg1.language) : (0, Helpers_1.string)(sub);
    })
        .onBinary([Consts_1.TypeURL.RDF_LANG_STRING, Consts_1.TypeURL.RDF_LANG_STRING], () => (arg1, arg2) => {
        if (arg1.language !== arg2.language) {
            throw new Err.IncompatibleLanguageOperation(arg1, arg2);
        }
        const [a1, a2] = [arg1.typedValue, arg2.typedValue];
        const sub = a1.slice(a1.indexOf(a2)).slice(a2.length);
        return sub || !a2 ? (0, Helpers_1.langString)(sub, arg1.language) : (0, Helpers_1.string)(sub);
    })
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-encode
 */
const ENCODE_FOR_URI = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.ENCODE_FOR_URI)
        .onStringly1Typed(() => val => (0, Helpers_1.string)(encodeURI(val))).collect(),
};
// See special operators
// const CONCAT = {}
/**
 * https://www.w3.org/TR/sparql11-query/#func-langMatches
 */
const langmatches = {
    arity: 2,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.LANG_MATCHES)
        .onBinaryTyped([Consts_1.TypeURL.XSD_STRING, Consts_1.TypeURL.XSD_STRING], () => (tag, range) => (0, Helpers_1.bool)(X.langMatches(tag, range))).collect(),
};
const regex2 = () => (text, pattern) => (0, Helpers_1.bool)(X.matches(text, pattern));
const regex3 = () => (text, pattern, flags) => (0, Helpers_1.bool)(X.matches(text, pattern, flags));
/**
 * https://www.w3.org/TR/sparql11-query/#func-regex
 */
const REGEX = {
    arity: [2, 3],
    overloads: (0, Helpers_1.declare)(C.RegularOperator.REGEX)
        .onBinaryTyped([Consts_1.TypeAlias.SPARQL_STRINGLY, Consts_1.TypeURL.XSD_STRING], regex2)
        .onTernaryTyped([Consts_1.TypeAlias.SPARQL_STRINGLY, Consts_1.TypeURL.XSD_STRING, Consts_1.TypeURL.XSD_STRING], regex3)
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-replace
 */
const REPLACE = {
    arity: [3, 4],
    overloads: (0, Helpers_1.declare)(C.RegularOperator.REPLACE)
        .onTernaryTyped([Consts_1.TypeURL.XSD_STRING, Consts_1.TypeURL.XSD_STRING, Consts_1.TypeURL.XSD_STRING], () => (arg, pattern, replacement) => (0, Helpers_1.string)(X.replace(arg, pattern, replacement)))
        .set([Consts_1.TypeURL.RDF_LANG_STRING, Consts_1.TypeURL.XSD_STRING, Consts_1.TypeURL.XSD_STRING], () => ([arg, pattern, replacement]) => {
        const result = X.replace(arg.typedValue, pattern.typedValue, replacement.typedValue);
        return (0, Helpers_1.langString)(result, arg.language);
    })
        .onQuaternaryTyped([Consts_1.TypeURL.XSD_STRING, Consts_1.TypeURL.XSD_STRING, Consts_1.TypeURL.XSD_STRING, Consts_1.TypeURL.XSD_STRING], () => (arg, pattern, replacement, flags) => (0, Helpers_1.string)(X.replace(arg, pattern, replacement, flags)))
        .set([Consts_1.TypeURL.RDF_LANG_STRING, Consts_1.TypeURL.XSD_STRING, Consts_1.TypeURL.XSD_STRING, Consts_1.TypeURL.XSD_STRING], () => ([arg, pattern, replacement, flags]) => {
        const result = X.replace(arg.typedValue, pattern.typedValue, replacement.typedValue, flags.typedValue);
        return (0, Helpers_1.langString)(result, arg.language);
    })
        .collect(),
};
// ----------------------------------------------------------------------------
// Functions on numerics
// https://www.w3.org/TR/sparql11-query/#func-numerics
// ----------------------------------------------------------------------------
/**
 * https://www.w3.org/TR/sparql11-query/#func-abs
 */
const abs = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.ABS)
        .numericConverter(() => num => Math.abs(num))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-round
 */
const round = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.ROUND)
        .numericConverter(() => num => Math.round(num))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-ceil
 */
const ceil = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.CEIL)
        .numericConverter(() => num => Math.ceil(num))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-floor
 */
const floor = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.FLOOR)
        .numericConverter(() => num => Math.floor(num))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#idp2130040
 */
const rand = {
    arity: 0,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.RAND)
        .set([], () => () => (0, Helpers_1.double)(Math.random()))
        .collect(),
};
// ----------------------------------------------------------------------------
// Functions on Dates and Times
// https://www.w3.org/TR/sparql11-query/#func-date-time
// ----------------------------------------------------------------------------
function parseDate(dateLit) {
    return P.parseXSDDateTime(dateLit.str());
}
/**
 * https://www.w3.org/TR/sparql11-query/#func-now
 */
const now = {
    arity: 0,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.NOW).set([], (sharedContext) => () => new E.DateTimeLiteral(sharedContext.now, sharedContext.now.toISOString())).collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-year
 */
const year = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.YEAR)
        .onDateTime1(() => date => (0, Helpers_1.integer)(Number(parseDate(date).year)))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-month
 */
const month = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.MONTH)
        .onDateTime1(() => date => (0, Helpers_1.integer)(Number(parseDate(date).month)))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-day
 */
const day = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.DAY)
        .onDateTime1(() => date => (0, Helpers_1.integer)(Number(parseDate(date).day)))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-hours
 */
const hours = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.HOURS)
        .onDateTime1(() => date => (0, Helpers_1.integer)(Number(parseDate(date).hours)))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-minutes
 */
const minutes = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.MINUTES)
        .onDateTime1(() => date => (0, Helpers_1.integer)(Number(parseDate(date).minutes)))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-seconds
 */
const seconds = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.SECONDS)
        .onDateTime1(() => date => (0, Helpers_1.decimal)(Number(parseDate(date).seconds)))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-timezone
 */
const timezone = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.TIMEZONE)
        .onDateTime1(() => date => {
        const duration = X.formatDayTimeDuration(parseDate(date).timezone);
        if (!duration) {
            throw new Err.InvalidTimezoneCall(date.strValue);
        }
        return new E.Literal(duration, Consts_1.TypeURL.XSD_DAYTIME_DURATION, duration);
    })
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-tz
 */
const tz = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.TZ)
        .onDateTime1(() => date => (0, Helpers_1.string)(parseDate(date).timezone))
        .collect(),
};
// ----------------------------------------------------------------------------
// Hash functions
// https://www.w3.org/TR/sparql11-query/#func-hash
// ----------------------------------------------------------------------------
/**
 * https://www.w3.org/TR/sparql11-query/#func-md5
 */
const MD5 = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.MD5)
        .onString1Typed(() => str => (0, Helpers_1.string)((0, spark_md5_1.hash)(str)))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-sha1
 */
const SHA1 = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.SHA1)
        .onString1Typed(() => str => (0, Helpers_1.string)((0, hash_js_1.sha1)().update(str).digest('hex')))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-sha256
 */
const SHA256 = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.SHA256)
        .onString1Typed(() => str => (0, Helpers_1.string)((0, hash_js_1.sha256)().update(str).digest('hex')))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-sha384
 */
const SHA384 = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.SHA384)
        .onString1Typed(() => str => (0, Helpers_1.string)((0, hash_js_1.sha384)().update(str).digest('hex')))
        .collect(),
};
/**
 * https://www.w3.org/TR/sparql11-query/#func-sha512
 */
const SHA512 = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(C.RegularOperator.SHA512)
        .onString1Typed(() => str => (0, Helpers_1.string)((0, hash_js_1.sha512)().update(str).digest('hex')))
        .collect(),
};
// End definitions.
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
/**
 * Collect all the definitions from above into an object
 */
exports.definitions = {
    // --------------------------------------------------------------------------
    // Operator Mapping
    // https://www.w3.org/TR/sparql11-query/#OperatorMapping
    // --------------------------------------------------------------------------
    '!': not,
    UPLUS: unaryPlus,
    UMINUS: unaryMinus,
    '*': multiplication,
    '/': division,
    '+': addition,
    '-': subtraction,
    '=': equality,
    '!=': inequality,
    '<': lesserThan,
    '>': greaterThan,
    '<=': lesserThanEqual,
    '>=': greaterThanEqual,
    // --------------------------------------------------------------------------
    // Functions on RDF Terms
    // https://www.w3.org/TR/sparql11-query/#func-rdfTerms
    // --------------------------------------------------------------------------
    isiri: isIRI,
    isblank: isBlank,
    isliteral: isLiteral,
    isnumeric: isNumeric,
    str: STR,
    lang,
    datatype,
    iri: IRI,
    uri: IRI,
    // 'BNODE': BNODE (see special operators),
    strdt: STRDT,
    strlang: STRLANG,
    uuid: UUID,
    struuid: STRUUID,
    // --------------------------------------------------------------------------
    // Functions on strings
    // https://www.w3.org/TR/sparql11-query/#func-forms
    // --------------------------------------------------------------------------
    strlen: STRLEN,
    substr: SUBSTR,
    ucase: UCASE,
    lcase: LCASE,
    strstarts: STRSTARTS,
    strends: STRENDS,
    contains: CONTAINS,
    strbefore: STRBEFORE,
    strafter: STRAFTER,
    encode_for_uri: ENCODE_FOR_URI,
    // 'concat': CONCAT (see special operators)
    langmatches,
    regex: REGEX,
    replace: REPLACE,
    // --------------------------------------------------------------------------
    // Functions on numerics
    // https://www.w3.org/TR/sparql11-query/#func-numerics
    // --------------------------------------------------------------------------
    abs,
    round,
    ceil,
    floor,
    rand,
    // --------------------------------------------------------------------------
    // Functions on Dates and Times
    // https://www.w3.org/TR/sparql11-query/#func-date-time
    // --------------------------------------------------------------------------
    now,
    year,
    month,
    day,
    hours,
    minutes,
    seconds,
    timezone,
    tz,
    // --------------------------------------------------------------------------
    // Hash functions
    // https://www.w3.org/TR/sparql11-query/#func-hash
    // --------------------------------------------------------------------------
    md5: MD5,
    sha1: SHA1,
    sha256: SHA256,
    sha384: SHA384,
    sha512: SHA512,
};
//# sourceMappingURL=RegularFunctions.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/functions/SpecialFunctions.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.specialDefinitions = void 0;
const uuid = __quadstore_comunica_require__("../packages/uuid/dist/index.js");
const E = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/index.js");
const C = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Consts.js");
const Err = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Errors.js");
const Helpers_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/Helpers.js");
const _1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/index.js");
// ----------------------------------------------------------------------------
// Functional forms
// ----------------------------------------------------------------------------
// BOUND ----------------------------------------------------------------------
/**
 * https://www.w3.org/TR/sparql11-query/#func-bound
 * This function doesn't require type promotion or subtype-substitution, everything works on TermExpression
 */
const bound = {
    arity: 1,
    async applyAsync({ args, mapping }) {
        return bound_({ args, mapping });
    },
    applySync({ args, mapping }) {
        return bound_({ args, mapping });
    },
};
function bound_({ args, mapping }) {
    const variable = args[0];
    if (variable.expressionType !== E.ExpressionType.Variable) {
        throw new Err.InvalidArgumentTypes(args, C.SpecialOperator.BOUND);
    }
    const val = mapping.has((0, Helpers_1.expressionToVar)(variable));
    return (0, Helpers_1.bool)(val);
}
// IF -------------------------------------------------------------------------
/**
 * https://www.w3.org/TR/sparql11-query/#func-if
 * This function doesn't require type promotion or subtype-substitution, everything works on TermExpression
 */
const ifSPARQL = {
    arity: 3,
    async applyAsync({ args, mapping, evaluate }) {
        const valFirst = await evaluate(args[0], mapping);
        const ebv = valFirst.coerceEBV();
        return ebv ?
            evaluate(args[1], mapping) :
            evaluate(args[2], mapping);
    },
    applySync({ args, mapping, evaluate }) {
        const valFirst = evaluate(args[0], mapping);
        const ebv = valFirst.coerceEBV();
        return ebv ?
            evaluate(args[1], mapping) :
            evaluate(args[2], mapping);
    },
};
// COALESCE -------------------------------------------------------------------
/**
 * https://www.w3.org/TR/sparql11-query/#func-coalesce
 * This function doesn't require type promotion or subtype-substitution, everything works on TermExpression
 */
const coalesce = {
    arity: Number.POSITIVE_INFINITY,
    async applyAsync({ args, mapping, evaluate }) {
        const errors = [];
        for (const expr of args) {
            try {
                return await evaluate(expr, mapping);
            }
            catch (error) {
                errors.push(error);
            }
        }
        throw new Err.CoalesceError(errors);
    },
    applySync({ args, mapping, evaluate }) {
        const errors = [];
        for (const expr of args) {
            try {
                return evaluate(expr, mapping);
            }
            catch (error) {
                errors.push(error);
            }
        }
        throw new Err.CoalesceError(errors);
    },
};
// Logical-or (||) ------------------------------------------------------------
/**
 * https://www.w3.org/TR/sparql11-query/#func-logical-or
 * This function doesn't require type promotion or subtype-substitution, everything works on TermExpression
 */
const logicalOr = {
    arity: 2,
    async applyAsync({ args, mapping, evaluate }) {
        const [leftExpr, rightExpr] = args;
        try {
            const leftTerm = await evaluate(leftExpr, mapping);
            const left = leftTerm.coerceEBV();
            if (left) {
                return (0, Helpers_1.bool)(true);
            }
            const rightTerm = await evaluate(rightExpr, mapping);
            const right = rightTerm.coerceEBV();
            return (0, Helpers_1.bool)(right);
        }
        catch (error) {
            const rightErrorTerm = await evaluate(rightExpr, mapping);
            const rightError = rightErrorTerm.coerceEBV();
            if (!rightError) {
                throw error;
            }
            return (0, Helpers_1.bool)(true);
        }
    },
    applySync({ args, mapping, evaluate }) {
        const [leftExpr, rightExpr] = args;
        try {
            const leftTerm = evaluate(leftExpr, mapping);
            const left = leftTerm.coerceEBV();
            if (left) {
                return (0, Helpers_1.bool)(true);
            }
            const rightTerm = evaluate(rightExpr, mapping);
            const right = rightTerm.coerceEBV();
            return (0, Helpers_1.bool)(right);
        }
        catch (error) {
            const rightErrorTerm = evaluate(rightExpr, mapping);
            const rightError = rightErrorTerm.coerceEBV();
            if (!rightError) {
                throw error;
            }
            return (0, Helpers_1.bool)(true);
        }
    },
};
// Logical-and (&&) -----------------------------------------------------------
/**
 * https://www.w3.org/TR/sparql11-query/#func-logical-and
 * This function doesn't require type promotion or subtype-substitution, everything works on TermExpression
 */
const logicalAnd = {
    arity: 2,
    async applyAsync({ args, mapping, evaluate }) {
        const [leftExpr, rightExpr] = args;
        try {
            const leftTerm = await evaluate(leftExpr, mapping);
            const left = leftTerm.coerceEBV();
            if (!left) {
                return (0, Helpers_1.bool)(false);
            }
            const rightTerm = await evaluate(rightExpr, mapping);
            const right = rightTerm.coerceEBV();
            return (0, Helpers_1.bool)(right);
        }
        catch (error) {
            const rightErrorTerm = await evaluate(rightExpr, mapping);
            const rightError = rightErrorTerm.coerceEBV();
            if (rightError) {
                throw error;
            }
            return (0, Helpers_1.bool)(false);
        }
    },
    applySync({ args, mapping, evaluate }) {
        const [leftExpr, rightExpr] = args;
        try {
            const leftTerm = evaluate(leftExpr, mapping);
            const left = leftTerm.coerceEBV();
            if (!left) {
                return (0, Helpers_1.bool)(false);
            }
            const rightTerm = evaluate(rightExpr, mapping);
            const right = rightTerm.coerceEBV();
            return (0, Helpers_1.bool)(right);
        }
        catch (error) {
            const rightErrorTerm = evaluate(rightExpr, mapping);
            const rightError = rightErrorTerm.coerceEBV();
            if (rightError) {
                throw error;
            }
            return (0, Helpers_1.bool)(false);
        }
    },
};
// SameTerm -------------------------------------------------------------------
/**
 * https://www.w3.org/TR/sparql11-query/#func-sameTerm
 * This function doesn't require type promotion or subtype-substitution, everything works on TermExpression
 */
const sameTerm = {
    arity: 2,
    async applyAsync({ args, mapping, evaluate }) {
        const [leftExpr, rightExpr] = args.map(arg => evaluate(arg, mapping));
        const [left, right] = await Promise.all([leftExpr, rightExpr]);
        return (0, Helpers_1.bool)(left.toRDF().equals(right.toRDF()));
    },
    applySync({ args, mapping, evaluate }) {
        const [left, right] = args.map(arg => evaluate(arg, mapping));
        return (0, Helpers_1.bool)(left.toRDF().equals(right.toRDF()));
    },
};
// IN -------------------------------------------------------------------------
/**
 * https://www.w3.org/TR/sparql11-query/#func-in
 * This function doesn't require type promotion or subtype-substitution, everything works on TermExpression
 */
const inSPARQL = {
    arity: Number.POSITIVE_INFINITY,
    checkArity(args) {
        return args.length > 0;
    },
    async applyAsync(context) {
        const { args, mapping, evaluate } = context;
        const [leftExpr, ...remaining] = args;
        const left = await evaluate(leftExpr, mapping);
        return inRecursiveAsync(left, Object.assign(Object.assign({}, context), { args: remaining }), []);
    },
    applySync(context) {
        const { args, mapping, evaluate } = context;
        const [leftExpr, ...remaining] = args;
        const left = evaluate(leftExpr, mapping);
        return inRecursiveSync(left, Object.assign(Object.assign({}, context), { args: remaining }), []);
    },
};
async function inRecursiveAsync(needle, context, results) {
    const { args, mapping, evaluate, overloadCache } = context;
    if (args.length === 0) {
        const noErrors = results.every(val => !val);
        return noErrors ? (0, Helpers_1.bool)(false) : Promise.reject(new Err.InError(results));
    }
    try {
        const nextExpression = args.shift();
        // We know this will not be undefined because we check args.length === 0
        const next = await evaluate(nextExpression, mapping);
        const isEqual = _1.regularFunctions[C.RegularOperator.EQUAL];
        if (isEqual.apply([needle, next], context).typedValue) {
            return (0, Helpers_1.bool)(true);
        }
        return inRecursiveAsync(needle, context, [...results, false]);
    }
    catch (error) {
        return inRecursiveAsync(needle, context, [...results, error]);
    }
}
function inRecursiveSync(needle, context, results) {
    const { args, mapping, evaluate, overloadCache } = context;
    if (args.length === 0) {
        const noErrors = results.every(val => !val);
        if (noErrors) {
            return (0, Helpers_1.bool)(false);
        }
        throw new Err.InError(results);
    }
    try {
        const nextExpression = args.shift();
        // We know this will not be undefined because we check args.length === 0
        const next = evaluate(nextExpression, mapping);
        const isEqual = _1.regularFunctions[C.RegularOperator.EQUAL];
        if (isEqual.apply([needle, next], context).typedValue) {
            return (0, Helpers_1.bool)(true);
        }
        return inRecursiveSync(needle, context, [...results, false]);
    }
    catch (error) {
        return inRecursiveSync(needle, context, [...results, error]);
    }
}
// NOT IN ---------------------------------------------------------------------
/**
 * https://www.w3.org/TR/sparql11-query/#func-not-in
 * This function doesn't require type promotion or subtype-substitution, everything works on TermExpression
 */
const notInSPARQL = {
    arity: Number.POSITIVE_INFINITY,
    checkArity(args) {
        return args.length > 0;
    },
    async applyAsync(context) {
        const _in = _1.specialFunctions[C.SpecialOperator.IN];
        const isIn = await _in.applyAsync(context);
        return (0, Helpers_1.bool)(!isIn.typedValue);
    },
    applySync(context) {
        const _in = _1.specialFunctions[C.SpecialOperator.IN];
        const isIn = _in.applySync(context);
        return (0, Helpers_1.bool)(!isIn.typedValue);
    },
};
// ----------------------------------------------------------------------------
// Annoying functions
// ----------------------------------------------------------------------------
// CONCAT ---------------------------------------------------------------------
/**
 * This OverloadTree with the constant function will handle both type promotion and subtype-substitution
 */
const concatTree = (0, Helpers_1.declare)(C.SpecialOperator.CONCAT).onStringly1(() => expr => expr)
    .collect().experimentalTree;
/**
 * https://www.w3.org/TR/sparql11-query/#func-concat
 */
const concat = {
    arity: Number.POSITIVE_INFINITY,
    async applyAsync(context) {
        const { args, mapping, evaluate, overloadCache, superTypeProvider } = context;
        const pLits = args
            .map(async (expr) => evaluate(expr, mapping))
            .map(async (pTerm) => {
            const operation = concatTree.search([await pTerm], superTypeProvider, overloadCache);
            if (!operation) {
                throw new Err.InvalidArgumentTypes(args, C.SpecialOperator.CONCAT);
            }
            return operation(context)([await pTerm]);
        });
        const lits = await Promise.all(pLits);
        const strings = lits.map(lit => lit.typedValue);
        const joined = strings.join('');
        const lang = langAllEqual(lits) ? lits[0].language : undefined;
        return lang ? (0, Helpers_1.langString)(joined, lang) : (0, Helpers_1.string)(joined);
    },
    applySync(context) {
        const { args, mapping, evaluate, superTypeProvider, overloadCache } = context;
        const lits = args
            .map(expr => evaluate(expr, mapping))
            .map(pTerm => {
            const operation = concatTree.search([pTerm], superTypeProvider, overloadCache);
            if (!operation) {
                throw new Err.InvalidArgumentTypes(args, C.SpecialOperator.CONCAT);
            }
            return operation(context)([pTerm]);
        });
        const strings = lits.map(lit => lit.typedValue);
        const joined = strings.join('');
        const lang = langAllEqual(lits) ? lits[0].language : undefined;
        return lang ? (0, Helpers_1.langString)(joined, lang) : (0, Helpers_1.string)(joined);
    },
};
function langAllEqual(lits) {
    return lits.length > 0 && lits.every(lit => lit.language === lits[0].language);
}
// ----------------------------------------------------------------------------
// Context dependant functions
// ----------------------------------------------------------------------------
// BNODE ---------------------------------------------------------------------
/**
 * This OverloadTree with the constant function will handle both type promotion and subtype-substitution
 */
const bnodeTree = (0, Helpers_1.declare)(C.SpecialOperator.BNODE).onString1(() => arg => arg).collect().experimentalTree;
/**
 * https://www.w3.org/TR/sparql11-query/#func-bnode
 * id has to be distinct over all id's in dataset
 */
const BNODE = {
    arity: Number.POSITIVE_INFINITY,
    checkArity(args) {
        return args.length === 0 || args.length === 1;
    },
    async applyAsync(context) {
        const { args, mapping, evaluate, superTypeProvider, overloadCache } = context;
        const input = args.length === 1 ?
            await evaluate(args[0], mapping) :
            undefined;
        let strInput;
        if (input) {
            const operation = bnodeTree.search([input], superTypeProvider, overloadCache);
            if (!operation) {
                throw new Err.InvalidArgumentTypes(args, C.SpecialOperator.BNODE);
            }
            strInput = operation(context)([input]).str();
        }
        // eslint-disable-next-line unicorn/consistent-destructuring
        if (context.bnode) {
            const bnode = await context.bnode(strInput);
            return new E.BlankNode(bnode);
        }
        return BNODE_(strInput);
    },
    applySync(context) {
        const { args, mapping, evaluate, superTypeProvider, overloadCache } = context;
        const input = args.length === 1 ?
            evaluate(args[0], mapping) :
            undefined;
        let strInput;
        if (input) {
            const operation = bnodeTree.search([input], superTypeProvider, overloadCache);
            if (!operation) {
                throw new Err.InvalidArgumentTypes(args, C.SpecialOperator.BNODE);
            }
            strInput = operation(context)([input]).str();
        }
        // eslint-disable-next-line unicorn/consistent-destructuring
        if (context.bnode) {
            const bnode = context.bnode(strInput);
            return new E.BlankNode(bnode);
        }
        return BNODE_(strInput);
    },
};
function BNODE_(input) {
    return new E.BlankNode(input || uuid.v4());
}
exports.specialDefinitions = {
    // --------------------------------------------------------------------------
    // Functional Forms
    // https://www.w3.org/TR/sparql11-query/#func-forms
    // --------------------------------------------------------------------------
    bound,
    if: ifSPARQL,
    coalesce,
    '&&': logicalAnd,
    '||': logicalOr,
    sameterm: sameTerm,
    in: inSPARQL,
    notin: notInSPARQL,
    // Annoying functions
    concat,
    // Context dependent functions
    BNODE,
};
//# sourceMappingURL=SpecialFunctions.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/functions/XPathFunctions.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatDayTimeDuration = exports.langMatches = exports.replace = exports.matches = void 0;
// https://www.w3.org/TR/xpath-functions/#func-matches
// https://www.w3.org/TR/xpath-functions/#flags
function matches(text, pattern, flags) {
    // TODO: Only flags 'i' and 'm' match between XPath and JS.
    // 's', 'x', 'q', would need proper implementation.
    const reg = new RegExp(pattern, flags);
    return reg.test(text);
}
exports.matches = matches;
// TODO: Fix flags
// https://www.w3.org/TR/xpath-functions/#func-replace
function replace(arg, pattern, replacement, flags) {
    let reg = new RegExp(pattern, flags);
    if (!reg.global) {
        const flags_ = flags || '';
        reg = new RegExp(pattern, `${flags_}g`);
    }
    return arg.replace(reg, replacement);
}
exports.replace = replace;
// TODO: Not an XPath function
// TODO: Publish as package
// https://www.ietf.org/rfc/rfc4647.txt
// https://www.w3.org/TR/sparql11-query/#func-langMatches
function langMatches(tag, range) {
    const langTags = tag.split('-');
    const rangeTags = range.split('-');
    if (!_matchLangTag(rangeTags[0], langTags[0]) &&
        !_isWildCard(langTags[0])) {
        return false;
    }
    let lI = 1;
    let rI = 1;
    while (rI < rangeTags.length) {
        if (_isWildCard(rangeTags[rI])) {
            rI++;
            continue;
        }
        if (lI === langTags.length) {
            return false;
        }
        if (_matchLangTag(rangeTags[rI], langTags[lI])) {
            lI++;
            rI++;
            continue;
        }
        if (langTags[lI].length === 1) {
            return false;
        }
        lI++;
    }
    return true;
}
exports.langMatches = langMatches;
function _isWildCard(tag) {
    return tag === '*';
}
function _matchLangTag(left, right) {
    const matchInitial = new RegExp(`/${left}/`, 'iu');
    return matchInitial.test(`/${right}/`);
}
/**
 * Formats a timezone string into a XML DayTimeDuration
 *
 * TODO: Test
 * Used in fn:timezone
 * http://www.datypic.com/sc/xsd/t-xsd_dayTimeDuration.html
 */
function formatDayTimeDuration(timezone) {
    if (!timezone) {
        return;
    }
    if (timezone.startsWith('Z')) {
        return 'PT0S';
    }
    // Split string
    const [sign, h1Raw, h2Raw, _, m1Raw, m2Raw] = timezone;
    // Cut of leading zero, set to empty string if 0, and append H;
    const h1 = h1Raw !== '0' ? h1Raw : '';
    const h2 = h1 || h2Raw !== '0' ? h2Raw : '';
    const hours = h1 + h2 ? `${h1 + h2}H` : '';
    // Same as in hours
    const m1 = m1Raw !== '0' ? m1Raw : '';
    const m2 = m1 || m2Raw !== '0' ? m2Raw : '';
    const minutes = m1 + m2 ? `${m1 + m2}M` : '';
    // Concat sign and time and mandatory separators
    const time = `${hours}${minutes}`;
    const signNoPlus = sign === '-' ? '-' : '';
    return `${signNoPlus}PT${time}`;
}
exports.formatDayTimeDuration = formatDayTimeDuration;
//# sourceMappingURL=XPathFunctions.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/functions/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OverloadTree = exports.namedFunctions = exports.specialFunctions = exports.regularFunctions = void 0;
const Core_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/Core.js");
const NamedFunctions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/NamedFunctions.js");
const RegularFunctions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/RegularFunctions.js");
const SpecialFunctions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/SpecialFunctions.js");
__exportStar(__quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/Core.js"), exports);
exports.regularFunctions = Object.fromEntries(Object.entries(RegularFunctions_1.definitions).map(([key, val]) => [key, new Core_1.RegularFunction(key, val)]));
exports.specialFunctions = Object.fromEntries(Object.entries(SpecialFunctions_1.specialDefinitions).map(([key, val]) => [key, new Core_1.SpecialFunction(key, val)]));
exports.namedFunctions = Object.fromEntries(Object.entries(NamedFunctions_1.namedDefinitions).map(([key, val]) => [key, new Core_1.NamedFunction(key, val)]));
var OverloadTree_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/OverloadTree.js");
Object.defineProperty(exports, "OverloadTree", ({ enumerable: true, get: function () { return OverloadTree_1.OverloadTree; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/transformers/AlgebraTransformer.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlgebraTransformer = void 0;
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
const E = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/index.js");
const functions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/functions/index.js");
const C = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Consts.js");
const Err = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Errors.js");
const Errors_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Errors.js");
const TermTransformer_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/transformers/TermTransformer.js");
class AlgebraTransformer extends TermTransformer_1.TermTransformer {
    constructor(algebraConfig) {
        super(algebraConfig.superTypeProvider, algebraConfig.enableExtendedXsdTypes);
        this.algebraConfig = algebraConfig;
        this.creatorConfig = { type: algebraConfig.type, creator: algebraConfig.creator };
    }
    transformAlgebra(expr) {
        if (!expr) {
            throw new Err.InvalidExpression(expr);
        }
        const types = sparqlalgebrajs_1.Algebra.expressionTypes;
        switch (expr.expressionType) {
            case types.TERM:
                return this.transformTerm(expr);
            case types.OPERATOR:
                return this.transformOperator(expr);
            case types.NAMED:
                return this.transformNamed(expr);
            case types.EXISTENCE:
                return AlgebraTransformer.transformExistence(expr);
            case types.AGGREGATE:
                return AlgebraTransformer.transformAggregate(expr);
            case types.WILDCARD:
                return AlgebraTransformer.transformWildcard(expr);
            default:
                throw new Err.InvalidExpressionType(expr);
        }
    }
    static transformWildcard(term) {
        if (!term.wildcard) {
            throw new Err.InvalidExpression(term);
        }
        return new E.NamedNode(term.wildcard.value);
    }
    transformOperator(expr) {
        if (C.SpecialOperators.has(expr.operator)) {
            const specialOp = expr.operator;
            const specialArgs = expr.args.map(arg => this.transformAlgebra(arg));
            const specialFunc = functions_1.specialFunctions[specialOp];
            if (!specialFunc.checkArity(specialArgs)) {
                throw new Err.InvalidArity(specialArgs, specialOp);
            }
            return new E.SpecialOperator(specialArgs, specialFunc.applyAsync, specialFunc.applySync);
        }
        if (!C.Operators.has(expr.operator)) {
            throw new Err.UnknownOperator(expr.operator);
        }
        const regularOp = expr.operator;
        const regularArgs = expr.args.map(arg => this.transformAlgebra(arg));
        const regularFunc = functions_1.regularFunctions[regularOp];
        if (!AlgebraTransformer.hasCorrectArity(regularArgs, regularFunc.arity)) {
            throw new Err.InvalidArity(regularArgs, regularOp);
        }
        return new E.Operator(regularArgs, args => regularFunc.apply(args, this.algebraConfig));
    }
    wrapSyncFunction(func, name) {
        return args => {
            try {
                const res = func(args.map(arg => arg.toRDF()));
                return this.transformRDFTermUnsafe(res);
            }
            catch (error) {
                throw new Errors_1.ExtensionFunctionError(name, error);
            }
        };
    }
    wrapAsyncFunction(func, name) {
        return async (args) => {
            try {
                const res = await func(args.map(arg => arg.toRDF()));
                return this.transformRDFTermUnsafe(res);
            }
            catch (error) {
                throw new Errors_1.ExtensionFunctionError(name, error);
            }
        };
    }
    // TODO: Support passing functions to override default behaviour;
    transformNamed(expr) {
        const funcName = expr.name.value;
        const namedArgs = expr.args.map(arg => this.transformAlgebra(arg));
        if (C.NamedOperators.has(funcName)) {
            // Return a basic named expression
            const op = expr.name.value;
            const namedFunc = functions_1.namedFunctions[op];
            return new E.Named(expr.name, namedArgs, args => namedFunc.apply(args, this.algebraConfig));
        }
        if (this.creatorConfig.type === 'sync') {
            // Expression might be extension function, check this for the sync
            const syncExtensionFunc = this.creatorConfig.creator(expr.name);
            if (syncExtensionFunc) {
                const simpleAppl = this.wrapSyncFunction(syncExtensionFunc, expr.name.value);
                return new E.SyncExtension(expr.name, namedArgs, simpleAppl);
            }
        }
        else {
            // The expression might be an extension function, check this for the async case
            const asyncExtensionFunc = this.creatorConfig.creator(expr.name);
            if (asyncExtensionFunc) {
                const asyncAppl = this.wrapAsyncFunction(asyncExtensionFunc, expr.name.value);
                return new E.AsyncExtension(expr.name, namedArgs, asyncAppl);
            }
        }
        throw new Err.UnknownNamedOperator(expr.name.value);
    }
    static hasCorrectArity(args, arity) {
        // Infinity is used to represent var-args, so it's always correct.
        if (arity === Number.POSITIVE_INFINITY) {
            return true;
        }
        // If the function has overloaded arity, the actual arity needs to be present.
        if (Array.isArray(arity)) {
            return arity.includes(args.length);
        }
        return args.length === arity;
    }
    static transformAggregate(expr) {
        const name = expr.aggregator;
        return new E.Aggregate(name, expr);
    }
    static transformExistence(expr) {
        return new E.Existence(expr);
    }
}
exports.AlgebraTransformer = AlgebraTransformer;
//# sourceMappingURL=AlgebraTransformer.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/transformers/TermTransformer.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TermTransformer = void 0;
const RDFString = __quadstore_comunica_require__("../node_modules/rdf-string/index.js");
const sparqlalgebrajs_1 = __quadstore_comunica_require__("sparqlalgebrajs");
const E = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/index.js");
const Consts_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Consts.js");
const Err = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Errors.js");
const P = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Parsing.js");
const TypeHandling_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/TypeHandling.js");
class TermTransformer {
    constructor(superTypeProvider, enableExtendedXSDTypes) {
        this.superTypeProvider = superTypeProvider;
        this.enableExtendedXSDTypes = enableExtendedXSDTypes;
    }
    /**
     * Transforms an RDF term to the internal representation of a term,
     * assuming it is not a variable, which would be an expression (internally).
     *
     * @param term RDF term to transform into internal representation of a term
     */
    transformRDFTermUnsafe(term) {
        return this.transformTerm({
            term,
            type: sparqlalgebrajs_1.Algebra.types.EXPRESSION,
            expressionType: sparqlalgebrajs_1.Algebra.expressionTypes.TERM,
        });
    }
    transformTerm(term) {
        if (!term.term) {
            throw new Err.InvalidExpression(term);
        }
        switch (term.term.termType) {
            case 'Variable':
                return new E.Variable(RDFString.termToString(term.term));
            case 'Literal':
                return this.transformLiteral(term.term);
            case 'NamedNode':
                return new E.NamedNode(term.term.value);
            case 'BlankNode':
                return new E.BlankNode(term.term.value);
            default:
                throw new Err.InvalidTermType(term);
        }
    }
    legacyTransformLiteral(lit) {
        // We transform to StringLiteral when we detect a simple literal being used.
        // Original issue regarding this behaviour: https://github.com/w3c/sparql-12/issues/112
        if (!lit.datatype) {
            return lit.language ?
                new E.LangStringLiteral(lit.value, lit.language) :
                new E.StringLiteral(lit.value);
        }
        const dataType = lit.datatype.value;
        switch (dataType) {
            case null:
            case undefined:
            case '': {
                return lit.language ?
                    new E.LangStringLiteral(lit.value, lit.language) :
                    new E.StringLiteral(lit.value);
            }
            case Consts_1.TypeURL.XSD_ANY_URI:
            case Consts_1.TypeURL.XSD_NORMALIZED_STRING:
            case Consts_1.TypeURL.XSD_TOKEN:
            case Consts_1.TypeURL.XSD_LANGUAGE:
            case Consts_1.TypeURL.XSD_NM_TOKEN:
            case Consts_1.TypeURL.XSD_NAME:
            case Consts_1.TypeURL.XSD_ENTITY:
            case Consts_1.TypeURL.XSD_ID:
            case Consts_1.TypeURL.XSD_ID_REF:
            case Consts_1.TypeURL.XSD_STRING: return new E.StringLiteral(lit.value, dataType);
            case Consts_1.TypeURL.RDF_LANG_STRING: return new E.LangStringLiteral(lit.value, lit.language);
            case Consts_1.TypeURL.XSD_DATE_TIME_STAMP:
            case Consts_1.TypeURL.XSD_DATE_TIME: {
                const dateVal = new Date(lit.value);
                if (Number.isNaN(dateVal.getTime())) {
                    return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
                }
                return new E.DateTimeLiteral(new Date(lit.value), lit.value, dataType);
            }
            case Consts_1.TypeURL.XSD_BOOLEAN: {
                if (lit.value !== 'true' && lit.value !== 'false' && lit.value !== '1' && lit.value !== '0') {
                    return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
                }
                return new E.BooleanLiteral(lit.value === 'true' || lit.value === '1', lit.value, dataType);
            }
            case Consts_1.TypeURL.XSD_DECIMAL: {
                const decimalVal = P.parseXSDDecimal(lit.value);
                if (decimalVal === undefined) {
                    return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
                }
                return new E.DecimalLiteral(decimalVal, dataType, lit.value);
            }
            case Consts_1.TypeURL.XSD_FLOAT: {
                const floatVal = P.parseXSDFloat(lit.value);
                if (floatVal === undefined) {
                    return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
                }
                return new E.FloatLiteral(floatVal, dataType, lit.value);
            }
            case Consts_1.TypeURL.XSD_DOUBLE: {
                const doubleVal = P.parseXSDFloat(lit.value);
                if (doubleVal === undefined) {
                    return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
                }
                return new E.DoubleLiteral(doubleVal, dataType, lit.value);
            }
            case Consts_1.TypeURL.XSD_NON_POSITIVE_INTEGER:
            case Consts_1.TypeURL.XSD_NEGATIVE_INTEGER:
            case Consts_1.TypeURL.XSD_LONG:
            case Consts_1.TypeURL.XSD_INT:
            case Consts_1.TypeURL.XSD_SHORT:
            case Consts_1.TypeURL.XSD_BYTE:
            case Consts_1.TypeURL.XSD_NON_NEGATIVE_INTEGER:
            case Consts_1.TypeURL.XSD_POSITIVE_INTEGER:
            case Consts_1.TypeURL.XSD_UNSIGNED_LONG:
            case Consts_1.TypeURL.XSD_UNSIGNED_INT:
            case Consts_1.TypeURL.XSD_UNSIGNED_SHORT:
            case Consts_1.TypeURL.XSD_UNSIGNED_BYTE:
            case Consts_1.TypeURL.XSD_INTEGER: {
                const intVal = P.parseXSDDecimal(lit.value);
                if (intVal === undefined) {
                    return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
                }
                return new E.IntegerLiteral(intVal, dataType, lit.value);
            }
            default: return new E.Literal(lit.value, dataType, lit.value);
        }
    }
    transformLiteral(lit) {
        return this.enableExtendedXSDTypes ? this.experimentalTransformLiteral(lit) : this.legacyTransformLiteral(lit);
    }
    /**
     * @param lit the rdf literal we want to transform to an internal Literal expression.
     */
    experimentalTransformLiteral(lit) {
        // Both here and within the switch we transform to LangStringLiteral or StringLiteral.
        // We do this when we detect a simple literal being used.
        // Original issue regarding this behaviour: https://github.com/w3c/sparql-12/issues/112
        if (!lit.datatype || [null, undefined, ''].includes(lit.datatype.value)) {
            return lit.language ?
                new E.LangStringLiteral(lit.value, lit.language) :
                new E.StringLiteral(lit.value);
        }
        const dataType = lit.datatype.value;
        const superTypeDict = (0, TypeHandling_1.getSuperTypeDict)(dataType, this.superTypeProvider);
        if (Consts_1.TypeURL.XSD_STRING in superTypeDict) {
            return new E.StringLiteral(lit.value, dataType);
        }
        if (Consts_1.TypeURL.RDF_LANG_STRING in superTypeDict) {
            return new E.LangStringLiteral(lit.value, lit.language);
        }
        if (Consts_1.TypeURL.XSD_DATE_TIME in superTypeDict) {
            // It should be noted how we don't care if its a XSD_DATE_TIME_STAMP or not.
            // This is because sparql functions don't care about the timezone.
            // It's also doesn't break the specs because we keep the string representation stored,
            // that way we can always give it back. There are also no sparql functions that alter a date.
            // (So the initial representation always stays valid)
            // https://github.com/comunica/sparqlee/pull/103#discussion_r688462368
            const dateVal = new Date(lit.value);
            if (Number.isNaN(dateVal.getTime())) {
                return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
            }
            return new E.DateTimeLiteral(new Date(lit.value), lit.value, dataType);
        }
        if (Consts_1.TypeURL.XSD_BOOLEAN in superTypeDict) {
            if (lit.value !== 'true' && lit.value !== 'false' && lit.value !== '1' && lit.value !== '0') {
                return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
            }
            return new E.BooleanLiteral(lit.value === 'true' || lit.value === '1', lit.value);
        }
        if (Consts_1.TypeURL.XSD_DECIMAL in superTypeDict) {
            const intVal = P.parseXSDDecimal(lit.value);
            if (intVal === undefined) {
                return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
            }
            if (Consts_1.TypeURL.XSD_INTEGER in superTypeDict) {
                return new E.IntegerLiteral(intVal, dataType, lit.value);
            }
            // If type is not an integer it's just a decimal.
            return new E.DecimalLiteral(intVal, dataType, lit.value);
        }
        const isFloat = Consts_1.TypeURL.XSD_FLOAT in superTypeDict;
        const isDouble = Consts_1.TypeURL.XSD_DOUBLE in superTypeDict;
        if (isFloat || isDouble) {
            const doubleVal = P.parseXSDFloat(lit.value);
            if (doubleVal === undefined) {
                return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
            }
            if (isFloat) {
                return new E.FloatLiteral(doubleVal, dataType, lit.value);
            }
            return new E.DoubleLiteral(doubleVal, dataType, lit.value);
        }
        return new E.Literal(lit.value, dataType, lit.value);
    }
}
exports.TermTransformer = TermTransformer;
//# sourceMappingURL=TermTransformer.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/util/Consts.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NamedOperators = exports.SetFunctions = exports.SetFunction = exports.Operators = exports.SpecialOperators = exports.RegularOperators = exports.SpecialOperator = exports.RegularOperator = exports.TypeURL = exports.TypeAlias = void 0;
var TypeAlias;
(function (TypeAlias) {
    // Numeric is everything defined in https://www.w3.org/TR/sparql11-query/#operandDataTypes
    TypeAlias["SPARQL_NUMERIC"] = "SPARQL_NUMERIC";
    /**
     * Stringly is everything defined in https://www.w3.org/TR/sparql11-query/#func-strings
     * In other words it is a simple literal, a plain literal with language tag, or a literal with datatype xsd:string
     * In other words, since sparqlee transforms a simple literal to xsd_string. It is RDF_LANG_STRING or XSD_STRING.
     * Reasons for this are mentioned here: w3c/sparql-12#112
     */
    TypeAlias["SPARQL_STRINGLY"] = "SPARQL_STRINGLY";
    TypeAlias["SPARQL_NON_LEXICAL"] = "SPARQL_NON_LEXICAL";
})(TypeAlias = exports.TypeAlias || (exports.TypeAlias = {}));
var TypeURL;
(function (TypeURL) {
    TypeURL["XSD_ANY_URI"] = "http://www.w3.org/2001/XMLSchema#anyURI";
    TypeURL["XSD_STRING"] = "http://www.w3.org/2001/XMLSchema#string";
    TypeURL["RDF_LANG_STRING"] = "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString";
    TypeURL["XSD_BOOLEAN"] = "http://www.w3.org/2001/XMLSchema#boolean";
    TypeURL["XSD_DATE_TIME"] = "http://www.w3.org/2001/XMLSchema#dateTime";
    TypeURL["XSD_DATE_TIME_STAMP"] = "http://www.w3.org/2001/XMLSchema#dateTimeStamp";
    TypeURL["XSD_DATE"] = "http://www.w3.org/2001/XMLSchema#date";
    // Numeric types
    TypeURL["XSD_DECIMAL"] = "http://www.w3.org/2001/XMLSchema#decimal";
    TypeURL["XSD_FLOAT"] = "http://www.w3.org/2001/XMLSchema#float";
    TypeURL["XSD_DOUBLE"] = "http://www.w3.org/2001/XMLSchema#double";
    // Derived numeric types
    TypeURL["XSD_INTEGER"] = "http://www.w3.org/2001/XMLSchema#integer";
    TypeURL["XSD_NON_POSITIVE_INTEGER"] = "http://www.w3.org/2001/XMLSchema#nonPositiveInteger";
    TypeURL["XSD_NEGATIVE_INTEGER"] = "http://www.w3.org/2001/XMLSchema#negativeInteger";
    TypeURL["XSD_LONG"] = "http://www.w3.org/2001/XMLSchema#long";
    TypeURL["XSD_INT"] = "http://www.w3.org/2001/XMLSchema#int";
    TypeURL["XSD_SHORT"] = "http://www.w3.org/2001/XMLSchema#short";
    TypeURL["XSD_BYTE"] = "http://www.w3.org/2001/XMLSchema#byte";
    TypeURL["XSD_NON_NEGATIVE_INTEGER"] = "http://www.w3.org/2001/XMLSchema#nonNegativeInteger";
    TypeURL["XSD_POSITIVE_INTEGER"] = "http://www.w3.org/2001/XMLSchema#positiveInteger";
    TypeURL["XSD_UNSIGNED_LONG"] = "http://www.w3.org/2001/XMLSchema#unsignedLong";
    TypeURL["XSD_UNSIGNED_INT"] = "http://www.w3.org/2001/XMLSchema#unsignedInt";
    TypeURL["XSD_UNSIGNED_SHORT"] = "http://www.w3.org/2001/XMLSchema#unsignedShort";
    TypeURL["XSD_UNSIGNED_BYTE"] = "http://www.w3.org/2001/XMLSchema#unsignedByte";
    // Derived String Type
    TypeURL["XSD_NORMALIZED_STRING"] = "http://www.w3.org/2001/XMLSchema#normalizedString";
    TypeURL["XSD_TOKEN"] = "http://www.w3.org/2001/XMLSchema#token";
    TypeURL["XSD_LANGUAGE"] = "http://www.w3.org/2001/XMLSchema#language";
    TypeURL["XSD_NM_TOKEN"] = "http://www.w3.org/2001/XMLSchema#NMTOKEN";
    TypeURL["XSD_NAME"] = "http://www.w3.org/2001/XMLSchema#name";
    TypeURL["XSD_NC_NAME"] = "http://www.w3.org/2001/XMLSchema#NCName";
    TypeURL["XSD_ENTITY"] = "http://www.w3.org/2001/XMLSchema#ENTITY";
    TypeURL["XSD_ID"] = "http://www.w3.org/2001/XMLSchema#ID";
    TypeURL["XSD_ID_REF"] = "http://www.w3.org/2001/XMLSchema#IDREF";
    // Other types
    TypeURL["XSD_DURATION"] = "http://www.w3.org/2001/XMLSchema#duration";
    TypeURL["XSD_YEAR_MONTH_DURATION"] = "http://www.w3.org/2001/XMLSchema#yearMonthDuration";
    TypeURL["XSD_DAYTIME_DURATION"] = "http://www.w3.org/2001/XMLSchema#dayTimeDuration";
})(TypeURL = exports.TypeURL || (exports.TypeURL = {}));
// TODO: Remove unneeded double typing
var RegularOperator;
(function (RegularOperator) {
    // Operator mapping
    // https://www.w3.org/TR/sparql11-query/#OperatorMapping
    RegularOperator["NOT"] = "!";
    RegularOperator["UMINUS"] = "UMINUS";
    RegularOperator["UPLUS"] = "UPLUS";
    // LOGICAL_AND // See SpecialOperators
    // LOGICAL_OR  // See SpecialOperators
    RegularOperator["EQUAL"] = "=";
    RegularOperator["NOT_EQUAL"] = "!=";
    RegularOperator["LT"] = "<";
    RegularOperator["GT"] = ">";
    RegularOperator["LTE"] = "<=";
    RegularOperator["GTE"] = ">=";
    RegularOperator["MULTIPLICATION"] = "*";
    RegularOperator["DIVISION"] = "/";
    RegularOperator["ADDITION"] = "+";
    RegularOperator["SUBTRACTION"] = "-";
    // Functional Forms
    // https://www.w3.org/TR/sparql11-query/#func-forms
    // See SpecialOperators
    // Functions on RDF Terms
    // https://www.w3.org/TR/sparql11-query/#func-rdfTerms
    RegularOperator["IS_IRI"] = "isiri";
    RegularOperator["IS_BLANK"] = "isblank";
    RegularOperator["IS_LITERAL"] = "isliteral";
    RegularOperator["IS_NUMERIC"] = "isnumeric";
    RegularOperator["STR"] = "str";
    RegularOperator["LANG"] = "lang";
    RegularOperator["DATATYPE"] = "datatype";
    RegularOperator["IRI"] = "iri";
    RegularOperator["URI"] = "uri";
    // BNODE = 'BNODE', (see special operators)
    RegularOperator["STRDT"] = "strdt";
    RegularOperator["STRLANG"] = "strlang";
    RegularOperator["UUID"] = "uuid";
    RegularOperator["STRUUID"] = "struuid";
    // Functions on strings
    // https://www.w3.org/TR/sparql11-query/#func-strings
    RegularOperator["STRLEN"] = "strlen";
    RegularOperator["SUBSTR"] = "substr";
    RegularOperator["UCASE"] = "ucase";
    RegularOperator["LCASE"] = "lcase";
    RegularOperator["STRSTARTS"] = "strstarts";
    RegularOperator["STRENDS"] = "strends";
    RegularOperator["CONTAINS"] = "contains";
    RegularOperator["STRBEFORE"] = "strbefore";
    RegularOperator["STRAFTER"] = "strafter";
    RegularOperator["ENCODE_FOR_URI"] = "encode_for_uri";
    // CONCAT = 'concat' (see special operators)
    RegularOperator["LANG_MATCHES"] = "langmatches";
    RegularOperator["REGEX"] = "regex";
    RegularOperator["REPLACE"] = "replace";
    // Functions on numerics
    // https://www.w3.org/TR/sparql11-query/#func-numerics
    RegularOperator["ABS"] = "abs";
    RegularOperator["ROUND"] = "round";
    RegularOperator["CEIL"] = "ceil";
    RegularOperator["FLOOR"] = "floor";
    RegularOperator["RAND"] = "rand";
    // Functions on Dates and Times
    // https://www.w3.org/TR/sparql11-query/#func-date-time
    RegularOperator["NOW"] = "now";
    RegularOperator["YEAR"] = "year";
    RegularOperator["MONTH"] = "month";
    RegularOperator["DAY"] = "day";
    RegularOperator["HOURS"] = "hours";
    RegularOperator["MINUTES"] = "minutes";
    RegularOperator["SECONDS"] = "seconds";
    RegularOperator["TIMEZONE"] = "timezone";
    RegularOperator["TZ"] = "tz";
    // Hash functions
    // https://www.w3.org/TR/sparql11-query/#func-hash
    RegularOperator["MD5"] = "md5";
    RegularOperator["SHA1"] = "sha1";
    RegularOperator["SHA256"] = "sha256";
    RegularOperator["SHA384"] = "sha384";
    RegularOperator["SHA512"] = "sha512";
    // XPath Constructor functions
    // https://www.w3.org/TR/sparql11-query/#FunctionMapping
    // See Named Operators
})(RegularOperator = exports.RegularOperator || (exports.RegularOperator = {}));
var SpecialOperator;
(function (SpecialOperator) {
    // Functional Forms
    // https://www.w3.org/TR/sparql11-query/#func-forms
    SpecialOperator["BOUND"] = "bound";
    SpecialOperator["IF"] = "if";
    SpecialOperator["COALESCE"] = "coalesce";
    // EXISTENCE = 'existence',
    SpecialOperator["LOGICAL_OR"] = "||";
    SpecialOperator["LOGICAL_AND"] = "&&";
    // EQUAL = '=', // See RegularOperators
    SpecialOperator["SAME_TERM"] = "sameterm";
    SpecialOperator["IN"] = "in";
    SpecialOperator["NOT_IN"] = "notin";
    // Annoying functions - Has variable arity
    SpecialOperator["CONCAT"] = "concat";
    // Context dependant functions
    SpecialOperator["BNODE"] = "BNODE";
})(SpecialOperator = exports.SpecialOperator || (exports.SpecialOperator = {}));
exports.RegularOperators = new Set(Object.values(RegularOperator));
exports.SpecialOperators = new Set(Object.values(SpecialOperator));
exports.Operators = new Set([...exports.RegularOperators, ...exports.SpecialOperators]);
var SetFunction;
(function (SetFunction) {
    SetFunction["COUNT"] = "count";
    SetFunction["SUM"] = "sum";
    SetFunction["MIN"] = "min";
    SetFunction["MAX"] = "max";
    SetFunction["AVG"] = "avg";
    SetFunction["GROUP_CONCAT"] = "group_concat";
    SetFunction["SAMPLE"] = "sample";
})(SetFunction = exports.SetFunction || (exports.SetFunction = {}));
exports.SetFunctions = new Set(Object.values(SetFunction));
exports.NamedOperators = new Set([
    TypeURL.XSD_STRING,
    TypeURL.XSD_FLOAT,
    TypeURL.XSD_DOUBLE,
    TypeURL.XSD_DECIMAL,
    TypeURL.XSD_INTEGER,
    TypeURL.XSD_DATE_TIME,
    TypeURL.XSD_DATE,
    TypeURL.XSD_BOOLEAN,
]);
//# sourceMappingURL=Consts.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/util/Errors.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoExistenceHook = exports.NoAggregator = exports.ExtensionFunctionError = exports.UnknownNamedOperator = exports.UnknownOperator = exports.InvalidTermType = exports.InvalidExpressionType = exports.InvalidExpression = exports.InvalidArity = exports.UnimplementedError = exports.UnexpectedError = exports.EmptyAggregateError = exports.IncompatibleLanguageOperation = exports.InvalidTimezoneCall = exports.CastError = exports.InvalidArgumentTypes = exports.InError = exports.CoalesceError = exports.RDFEqualTypeError = exports.EBVCoercionError = exports.UnboundVariableError = exports.InvalidLexicalForm = exports.isExpressionError = exports.ExpressionError = void 0;
/**
 * This class of error will be thrown when an expression errors.
 * Various reasons this could happen are:
 *   - invalid types for the given operator
 *   - unbound variables
 *   - invalid lexical forms
 *   - ...
 *
 * The distinction is made so that one can catch this specific type
 * and handle it accordingly to the SPARQL spec (relevant for e.g. FILTER, EXTEND),
 * while others (programming errors) can be re-thrown.
 *
 * @see isExpressionError
 */
class ExpressionError extends Error {
}
exports.ExpressionError = ExpressionError;
/**
 * Checks whether a given error is an {@link ExpressionError}.
 * Also useful for mocking in tests for covering all branches.
 *
 * @see ExpressionError
 */
function isExpressionError(error) {
    return error instanceof ExpressionError;
}
exports.isExpressionError = isExpressionError;
/**
 * A literal has an invalid lexical form for the datatype it is accompanied by.
 * This error is only thrown when the term is as function argument that requires
 * a valid lexical form.
 */
class InvalidLexicalForm extends ExpressionError {
    constructor(arg) {
        super(`Invalid lexical form '${pp(arg)}'`);
        this.arg = arg;
    }
}
exports.InvalidLexicalForm = InvalidLexicalForm;
/**
 * A variable in the expression was not bound.
 */
class UnboundVariableError extends ExpressionError {
    constructor(variable, bindings) {
        super(`Unbound variable '${pp(variable)}'`);
        this.variable = variable;
        this.bindings = bindings;
    }
}
exports.UnboundVariableError = UnboundVariableError;
/**
 * An invalid term was being coerced to an Effective Boolean Value.
 *
 * See the {@link https://www.w3.org/TR/sparql11-query/#ebv | SPARQL docs}
 * on EBVs.
 */
class EBVCoercionError extends ExpressionError {
    constructor(arg) {
        super(`Cannot coerce term to EBV '${pp(arg)}'`);
        this.arg = arg;
    }
}
exports.EBVCoercionError = EBVCoercionError;
/**
 * An equality test was done on literals with unsupported datatypes.
 *
 * See {@link https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal | term equality spec}.
 */
class RDFEqualTypeError extends ExpressionError {
    constructor(args) {
        super('Equality test for literals with unsupported datatypes');
        this.args = args;
    }
}
exports.RDFEqualTypeError = RDFEqualTypeError;
/**
 * All the expressions in a COALESCE call threw errors.
 */
class CoalesceError extends ExpressionError {
    constructor(errors) {
        super('All COALESCE arguments threw errors');
        this.errors = errors;
    }
}
exports.CoalesceError = CoalesceError;
/**
 * No arguments to an IN call where equal, and at least one threw an error.
 */
class InError extends ExpressionError {
    constructor(errors) {
        super(`Some argument to IN errorred and none where equal. ${
        // eslint-disable-next-line @typescript-eslint/no-base-to-string
        errors.map(err => `(${err.toString()}) `).join('and ')}`);
        this.errors = errors;
    }
}
exports.InError = InError;
/**
 * Literals were passed to an operator that doesn't support their datatypes.
 */
class InvalidArgumentTypes extends ExpressionError {
    constructor(args, op) {
        super(`Argument types not valid for operator: '${pp(op)}' with '${pp(args)}`);
        this.args = args;
        this.op = op;
    }
}
exports.InvalidArgumentTypes = InvalidArgumentTypes;
/**
 * An invalid typecast happened.
 */
class CastError extends ExpressionError {
    constructor(arg, cast) {
        super(`Invalid cast: '${pp(arg)}' to '${pp(cast)}'`);
        this.arg = arg;
    }
}
exports.CastError = CastError;
class InvalidTimezoneCall extends ExpressionError {
    constructor(dateString) {
        super(`TIMEZONE call on ${dateString} which has no timezone`);
        this.dateString = dateString;
    }
}
exports.InvalidTimezoneCall = InvalidTimezoneCall;
class IncompatibleLanguageOperation extends ExpressionError {
    constructor(arg1, arg2) {
        super(`Operation on incompatible language literals '${pp(arg1)}' and '${pp(arg2)}'`);
        this.arg1 = arg1;
        this.arg2 = arg2;
    }
}
exports.IncompatibleLanguageOperation = IncompatibleLanguageOperation;
class EmptyAggregateError extends ExpressionError {
    constructor() {
        super('Empty aggregate expression');
    }
}
exports.EmptyAggregateError = EmptyAggregateError;
// Non Expression Errors ------------------------------------------------------
/**
 * An error that arises when we detect a 'should-be-impossible' state.
 * Given that this error is thrown, it clearly wasn't impossible, and some
 * mistake has been made.
 */
class UnexpectedError extends Error {
    constructor(message, payload) {
        super(`Programmer Error '${message}'`);
        this.payload = payload;
    }
}
exports.UnexpectedError = UnexpectedError;
/**
 * An Error that signals a feature or function is yet unimplemented.
 */
class UnimplementedError extends Error {
    constructor(feature) {
        super(`Unimplemented feature '${feature}!'`);
    }
}
exports.UnimplementedError = UnimplementedError;
class InvalidArity extends Error {
    constructor(args, op) {
        super(`The number of args does not match the arity of the operator '${pp(op)}'.`);
        this.args = args;
        this.op = op;
    }
}
exports.InvalidArity = InvalidArity;
class InvalidExpression extends Error {
    constructor(expr) {
        super(`Invalid SPARQL Expression '${pp(expr)}'`);
    }
}
exports.InvalidExpression = InvalidExpression;
class InvalidExpressionType extends Error {
    constructor(expr) {
        super(`Invalid expression type for SPARQL Expression '${pp(expr)}'`);
        this.expr = expr;
    }
}
exports.InvalidExpressionType = InvalidExpressionType;
class InvalidTermType extends Error {
    constructor(term) {
        super(`Invalid term type for term '${pp(term)}'`);
        this.term = term;
    }
}
exports.InvalidTermType = InvalidTermType;
class UnknownOperator extends Error {
    constructor(name) {
        super(`Unknown operator: '${pp(name)}`);
    }
}
exports.UnknownOperator = UnknownOperator;
class UnknownNamedOperator extends Error {
    constructor(name) {
        super(`Unknown named operator: '${pp(name)}'`);
    }
}
exports.UnknownNamedOperator = UnknownNamedOperator;
class ExtensionFunctionError extends Error {
    constructor(name, functionError) {
        if (functionError instanceof Error) {
            super(`Error thrown in ${name}: ${functionError.message}${functionError.stack ? `\n${functionError.stack}` : ''}`);
        }
        else {
            super(`Error thrown in ${name}`);
        }
    }
}
exports.ExtensionFunctionError = ExtensionFunctionError;
class NoAggregator extends Error {
    constructor(name) {
        super(`Aggregate expression ${pp(name)} found, but no aggregate hook provided.`);
    }
}
exports.NoAggregator = NoAggregator;
class NoExistenceHook extends Error {
    constructor() {
        super('EXISTS found, but no existence hook provided.');
    }
}
exports.NoExistenceHook = NoExistenceHook;
function pp(object) {
    return JSON.stringify(object);
}
//# sourceMappingURL=Errors.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/util/Ordering.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.orderTypes = void 0;
const LRUCache = __quadstore_comunica_require__("../node_modules/lru-cache/index.js");
const TermTransformer_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/transformers/TermTransformer.js");
// Determine the relative numerical order of the two given terms.
function orderTypes(termA, termB, isAscending, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes) {
    if (termA === termB) {
        return 0;
    }
    // We handle undefined that is lower than everything else.
    if (termA === undefined) {
        return isAscending ? -1 : 1;
    }
    if (termB === undefined) {
        return isAscending ? 1 : -1;
    }
    // We handle terms
    if (termA.equals(termB)) {
        return 0;
    }
    return isTermLowerThan(termA, termB, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes) === isAscending ?
        -1 :
        1;
}
exports.orderTypes = orderTypes;
function isTermLowerThan(termA, termB, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes) {
    if (termA.termType !== termB.termType) {
        return _TERM_ORDERING_PRIORITY[termA.termType] < _TERM_ORDERING_PRIORITY[termB.termType];
    }
    return termA.termType === 'Literal' ?
        isLiteralLowerThan(termA, termB, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes) :
        termA.value < termB.value;
}
function isLiteralLowerThan(litA, litB, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes) {
    const openWorldType = {
        discoverer: typeDiscoveryCallback || (() => 'term'),
        cache: typeCache || new LRUCache(),
    };
    const termTransformer = new TermTransformer_1.TermTransformer(openWorldType, enableExtendedXSDTypes || false);
    const myLitA = termTransformer.transformLiteral(litA);
    const myLitB = termTransformer.transformLiteral(litB);
    const typeA = _SPARQL_TYPE_NORMALIZATION[myLitA.mainSparqlType];
    const typeB = _SPARQL_TYPE_NORMALIZATION[myLitB.mainSparqlType];
    if (typeA !== typeB) {
        return typeA < typeB;
    }
    switch (typeA) {
        case 'boolean':
        case 'dateTime':
        case 'decimal':
        case 'integer':
        case 'float':
        case 'double':
        case 'string':
            return myLitA.typedValue < myLitB.typedValue;
        case 'langString':
            return myLitA.typedValue < myLitB.typedValue ||
                (myLitA.typedValue === myLitB.typedValue && (myLitA.language || '') < (myLitB.language || ''));
        case 'other':
        case 'nonlexical':
            return myLitA.dataType < myLitB.dataType ||
                (myLitA.dataType === myLitB.dataType && myLitA.str() < myLitB.str());
    }
}
// SPARQL specifies that blankNode < namedNode < literal.
const _TERM_ORDERING_PRIORITY = {
    Variable: 0,
    BlankNode: 1,
    NamedNode: 2,
    Literal: 3,
    Quad: 4,
    DefaultGraph: 5,
};
const _SPARQL_TYPE_NORMALIZATION = {
    string: 'string',
    langString: 'langString',
    dateTime: 'dateTime',
    boolean: 'boolean',
    integer: 'decimal',
    decimal: 'decimal',
    float: 'decimal',
    double: 'decimal',
    other: 'other',
    nonlexical: 'other',
};
//# sourceMappingURL=Ordering.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/util/Parsing.js":
/***/ ((__unused_webpack_module, exports) => {


// TODO: Find a library for this
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseXSDDateTime = exports.parseXSDInteger = exports.parseXSDDecimal = exports.parseXSDFloat = void 0;
/**
 * TODO: Fix decently
 * Parses float datatypes (double, float).
 *
 * All invalid lexical values return undefined.
 *
 * @param value the string to interpret as a number
 */
function parseXSDFloat(value) {
    const numb = Number(value);
    if (Number.isNaN(numb)) {
        if (value === 'NaN') {
            return Number.NaN;
        }
        if (value === 'INF') {
            return Number.POSITIVE_INFINITY;
        }
        if (value === '-INF') {
            return Number.NEGATIVE_INFINITY;
        }
        return undefined;
    }
    return numb;
}
exports.parseXSDFloat = parseXSDFloat;
/**
 * Parses decimal datatypes (decimal, int, byte, nonPositiveInteger, etc...).
 *
 * All other values, including NaN, INF, and floating point numbers all
 * return undefined;
 *
 * @param value the string to interpret as a number
 */
function parseXSDDecimal(value) {
    const numb = Number(value);
    return Number.isNaN(numb) ? undefined : numb;
}
exports.parseXSDDecimal = parseXSDDecimal;
/**
 * Parses integer datatypes (decimal, int, byte, nonPositiveInteger, etc...).
 *
 * All other values, including NaN, INF, and floating point numbers all
 * return undefined;
 *
 * @param value the string to interpret as a number
 */
function parseXSDInteger(value) {
    const numb = Number.parseInt(value, 10);
    return Number.isNaN(numb) ? undefined : numb;
}
exports.parseXSDInteger = parseXSDInteger;
/**
 * Parses ISO date or date time strings into it's parts.
 * I found no lib providing this functionality online, but it's needed heavily
 * by the spec (functions on dates), using any form of JS DateTime will lose the
 * original timezone notation.
 *
 * Example strings:
 *  - "2011-01-10T14:45:13.815-05:00"
 *  - "2011-01-10T14:45:13.815Z"
 *  - "2011-01-10T14:45:13Z"
 *  - "2011-01-10"
 * @param value the ISO date time string
 */
function parseXSDDateTime(value) {
    const posT = value.indexOf('T');
    const date = posT >= 0 ? value.slice(0, Math.max(0, posT)) : value;
    const [year, month, day] = date.split('-');
    let hours = '';
    let minutes = '';
    let seconds = '';
    let timezone = '';
    if (posT >= 0) {
        const timeAndTimeZone = value.slice(posT + 1);
        const [time, _timeZoneChopped] = timeAndTimeZone.split(/[+Z-]/u);
        [hours, minutes, seconds] = time.split(':');
        const timezoneOrNull = /([+Z-].*)/u.exec(timeAndTimeZone);
        timezone = timezoneOrNull ? timezoneOrNull[0] : '';
    }
    else {
        hours = '00';
        minutes = '00';
        seconds = '00';
        timezone = '';
    }
    return { year, month, day, hours, minutes, seconds, timezone };
}
exports.parseXSDDateTime = parseXSDDateTime;
//# sourceMappingURL=Parsing.js.map

/***/ }),

/***/ "../node_modules/sparqlee/dist/lib/util/TypeHandling.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSubTypeOf = exports.getSuperTypeDict = exports.isInternalSubType = exports.asGeneralType = exports.asOverrideType = exports.asKnownLiteralType = exports.asTypeAlias = exports.typeAliasCheck = exports.extensionTableInit = exports.getSuperTypes = exports.superTypeDictTable = exports.extensionTableInput = exports.mainSparqlType = void 0;
const expressions_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/expressions/index.js");
const Consts_1 = __quadstore_comunica_require__("../node_modules/sparqlee/dist/lib/util/Consts.js");
/**
 * This function return a list of ArgumentTypes and the priority this list has.
 * This priority can be matched with other values returned by this function.
 * This function needs to be in line with the @see extensionTableInput.
 * @param typeURL This will most likely be a @see ExperimentalArgumentType
 */
function mainSparqlType(typeURL) {
    // We transform to StringLiteral when we detect a simple literal being used.
    // Original issue regarding this behaviour: https://github.com/w3c/sparql-12/issues/112
    switch (typeURL) {
        case 'term': return { types: ['term'], prio: 0 };
        case 'namedNode': return { types: ['namedNode'], prio: 1 };
        case 'literal': return { types: ['literal'], prio: 1 };
        case 'blankNode': return { types: ['blankNode'], prio: 1 };
        case Consts_1.TypeAlias.SPARQL_NON_LEXICAL: return { types: ['nonlexical'], prio: 2 };
        case null:
        case undefined:
        case '':
        case Consts_1.TypeURL.XSD_ANY_URI:
        case Consts_1.TypeURL.XSD_NORMALIZED_STRING:
        case Consts_1.TypeURL.XSD_TOKEN:
        case Consts_1.TypeURL.XSD_LANGUAGE:
        case Consts_1.TypeURL.XSD_NM_TOKEN:
        case Consts_1.TypeURL.XSD_NAME:
        case Consts_1.TypeURL.XSD_ENTITY:
        case Consts_1.TypeURL.XSD_ID:
        case Consts_1.TypeURL.XSD_ID_REF:
        case Consts_1.TypeURL.XSD_STRING: return { types: ['string'], prio: exports.superTypeDictTable[Consts_1.TypeURL.XSD_STRING].__depth + 2 };
        case Consts_1.TypeURL.RDF_LANG_STRING: return {
            types: ['langString'],
            prio: exports.superTypeDictTable[Consts_1.TypeURL.RDF_LANG_STRING].__depth + 2,
        };
        case Consts_1.TypeURL.XSD_DATE_TIME_STAMP:
        case Consts_1.TypeURL.XSD_DATE_TIME: return {
            types: ['dateTime'],
            prio: exports.superTypeDictTable[Consts_1.TypeURL.XSD_DATE_TIME].__depth + 2,
        };
        case Consts_1.TypeURL.XSD_BOOLEAN: return {
            types: ['boolean'],
            prio: exports.superTypeDictTable[Consts_1.TypeURL.XSD_BOOLEAN].__depth + 2,
        };
        case Consts_1.TypeURL.XSD_DECIMAL: return {
            types: ['decimal', 'integer'],
            prio: exports.superTypeDictTable[Consts_1.TypeURL.XSD_DECIMAL].__depth + 2,
        };
        case Consts_1.TypeURL.XSD_FLOAT: return { types: ['float'], prio: exports.superTypeDictTable[Consts_1.TypeURL.XSD_FLOAT].__depth + 2 };
        case Consts_1.TypeURL.XSD_DOUBLE: return { types: ['double'], prio: exports.superTypeDictTable[Consts_1.TypeURL.XSD_DOUBLE].__depth + 2 };
        case Consts_1.TypeURL.XSD_NON_POSITIVE_INTEGER:
        case Consts_1.TypeURL.XSD_NEGATIVE_INTEGER:
        case Consts_1.TypeURL.XSD_LONG:
        case Consts_1.TypeURL.XSD_INT:
        case Consts_1.TypeURL.XSD_SHORT:
        case Consts_1.TypeURL.XSD_BYTE:
        case Consts_1.TypeURL.XSD_NON_NEGATIVE_INTEGER:
        case Consts_1.TypeURL.XSD_POSITIVE_INTEGER:
        case Consts_1.TypeURL.XSD_UNSIGNED_LONG:
        case Consts_1.TypeURL.XSD_UNSIGNED_INT:
        case Consts_1.TypeURL.XSD_UNSIGNED_SHORT:
        case Consts_1.TypeURL.XSD_UNSIGNED_BYTE:
        case Consts_1.TypeURL.XSD_INTEGER: return {
            types: ['integer'],
            prio: exports.superTypeDictTable[Consts_1.TypeURL.XSD_INTEGER].__depth + 2,
        };
        case Consts_1.TypeAlias.SPARQL_STRINGLY: return {
            types: ['string', 'langString'],
            prio: exports.superTypeDictTable[Consts_1.TypeAlias.SPARQL_STRINGLY].__depth + 2,
        };
        case Consts_1.TypeAlias.SPARQL_NUMERIC: return {
            types: ['decimal', 'float', 'integer', 'double'],
            prio: exports.superTypeDictTable[Consts_1.TypeAlias.SPARQL_NUMERIC].__depth + 2,
        };
        default: return { types: ['other'], prio: 2 };
    }
}
exports.mainSparqlType = mainSparqlType;
/**
 * Types that are not mentioned just map to 'term'.
 * When editing this, make sure type promotion and substituion don't start interfering.
 * e.g. when saying something like string -> stringly -> anyUri -> term.
 * This would make substitution on types that promote to each other possible. We and the specs don't want that!
 * A DAG will be created based on this. Make sure it doesn't have any cycles!
 *
 * This needs to be in line with the @see mainSparqlType function.
 */
exports.extensionTableInput = {
    // Datetime types
    [Consts_1.TypeURL.XSD_DATE_TIME_STAMP]: Consts_1.TypeURL.XSD_DATE_TIME,
    // Duration types
    [Consts_1.TypeURL.XSD_DAYTIME_DURATION]: Consts_1.TypeURL.XSD_DURATION,
    [Consts_1.TypeURL.XSD_YEAR_MONTH_DURATION]: Consts_1.TypeURL.XSD_DURATION,
    // Stringly types
    [Consts_1.TypeURL.RDF_LANG_STRING]: Consts_1.TypeAlias.SPARQL_STRINGLY,
    [Consts_1.TypeURL.XSD_STRING]: Consts_1.TypeAlias.SPARQL_STRINGLY,
    // String types
    [Consts_1.TypeURL.XSD_NORMALIZED_STRING]: Consts_1.TypeURL.XSD_STRING,
    [Consts_1.TypeURL.XSD_TOKEN]: Consts_1.TypeURL.XSD_NORMALIZED_STRING,
    [Consts_1.TypeURL.XSD_LANGUAGE]: Consts_1.TypeURL.XSD_TOKEN,
    [Consts_1.TypeURL.XSD_NM_TOKEN]: Consts_1.TypeURL.XSD_TOKEN,
    [Consts_1.TypeURL.XSD_NAME]: Consts_1.TypeURL.XSD_TOKEN,
    [Consts_1.TypeURL.XSD_NC_NAME]: Consts_1.TypeURL.XSD_NAME,
    [Consts_1.TypeURL.XSD_ENTITY]: Consts_1.TypeURL.XSD_NC_NAME,
    [Consts_1.TypeURL.XSD_ID]: Consts_1.TypeURL.XSD_NC_NAME,
    [Consts_1.TypeURL.XSD_ID_REF]: Consts_1.TypeURL.XSD_NC_NAME,
    // Numeric types
    // https://www.w3.org/TR/sparql11-query/#operandDataTypes
    // > numeric denotes typed literals with datatypes xsd:integer, xsd:decimal, xsd:float, and xsd:double
    [Consts_1.TypeURL.XSD_DOUBLE]: Consts_1.TypeAlias.SPARQL_NUMERIC,
    [Consts_1.TypeURL.XSD_FLOAT]: Consts_1.TypeAlias.SPARQL_NUMERIC,
    [Consts_1.TypeURL.XSD_DECIMAL]: Consts_1.TypeAlias.SPARQL_NUMERIC,
    // Decimal types
    [Consts_1.TypeURL.XSD_INTEGER]: Consts_1.TypeURL.XSD_DECIMAL,
    [Consts_1.TypeURL.XSD_NON_POSITIVE_INTEGER]: Consts_1.TypeURL.XSD_INTEGER,
    [Consts_1.TypeURL.XSD_NEGATIVE_INTEGER]: Consts_1.TypeURL.XSD_NON_POSITIVE_INTEGER,
    [Consts_1.TypeURL.XSD_LONG]: Consts_1.TypeURL.XSD_INTEGER,
    [Consts_1.TypeURL.XSD_INT]: Consts_1.TypeURL.XSD_LONG,
    [Consts_1.TypeURL.XSD_SHORT]: Consts_1.TypeURL.XSD_INT,
    [Consts_1.TypeURL.XSD_BYTE]: Consts_1.TypeURL.XSD_SHORT,
    [Consts_1.TypeURL.XSD_NON_NEGATIVE_INTEGER]: Consts_1.TypeURL.XSD_INTEGER,
    [Consts_1.TypeURL.XSD_POSITIVE_INTEGER]: Consts_1.TypeURL.XSD_NON_NEGATIVE_INTEGER,
    [Consts_1.TypeURL.XSD_UNSIGNED_LONG]: Consts_1.TypeURL.XSD_NON_NEGATIVE_INTEGER,
    [Consts_1.TypeURL.XSD_UNSIGNED_INT]: Consts_1.TypeURL.XSD_UNSIGNED_LONG,
    [Consts_1.TypeURL.XSD_UNSIGNED_SHORT]: Consts_1.TypeURL.XSD_UNSIGNED_INT,
    [Consts_1.TypeURL.XSD_UNSIGNED_BYTE]: Consts_1.TypeURL.XSD_UNSIGNED_SHORT,
    [Consts_1.TypeURL.XSD_DATE_TIME]: 'term',
    [Consts_1.TypeURL.XSD_BOOLEAN]: 'term',
    [Consts_1.TypeURL.XSD_DATE]: 'term',
    [Consts_1.TypeURL.XSD_DURATION]: 'term',
    [Consts_1.TypeAlias.SPARQL_NUMERIC]: 'term',
    [Consts_1.TypeAlias.SPARQL_STRINGLY]: 'term',
    [Consts_1.TypeAlias.SPARQL_NON_LEXICAL]: 'term',
    [Consts_1.TypeURL.XSD_ANY_URI]: 'term',
};
/**
 * This will return the super types of a type and cache them.
 * @param type IRI we will decide the super types of.
 * @param openWorldType the enabler that provides a way to find super types.
 */
function getSuperTypes(type, openWorldType) {
    const cached = openWorldType.cache.get(type);
    if (cached) {
        return cached;
    }
    const value = openWorldType.discoverer(type);
    if (value === 'term') {
        const res = Object.create(null);
        res.__depth = 0;
        res[type] = 0;
        openWorldType.cache.set(type, res);
        return res;
    }
    let subExtension;
    const knownValue = asKnownLiteralType(value);
    if (knownValue) {
        subExtension = Object.assign({}, exports.superTypeDictTable[knownValue]);
    }
    else {
        subExtension = Object.assign({}, getSuperTypes(value, openWorldType));
    }
    subExtension.__depth++;
    subExtension[type] = subExtension.__depth;
    openWorldType.cache.set(type, subExtension);
    return subExtension;
}
exports.getSuperTypes = getSuperTypes;
// No circular structure allowed! & No other keys allowed!
function extensionTableInit() {
    const res = Object.create(null);
    for (const [_key, value] of Object.entries(exports.extensionTableInput)) {
        const key = _key;
        if (res[key]) {
            continue;
        }
        extensionTableBuilderInitKey(key, value, res);
    }
    exports.superTypeDictTable = res;
}
exports.extensionTableInit = extensionTableInit;
extensionTableInit();
function extensionTableBuilderInitKey(key, value, res) {
    if (value === 'term' || value === undefined) {
        const baseRes = Object.create(null);
        baseRes.__depth = 0;
        baseRes[key] = 0;
        res[key] = baseRes;
        return;
    }
    if (!res[value]) {
        extensionTableBuilderInitKey(value, exports.extensionTableInput[value], res);
    }
    res[key] = Object.assign(Object.assign({}, res[value]), { [key]: res[value].__depth + 1, __depth: res[value].__depth + 1 });
}
function initTypeAliasCheck() {
    exports.typeAliasCheck = Object.create(null);
    for (const val of Object.values(Consts_1.TypeAlias)) {
        exports.typeAliasCheck[val] = true;
    }
}
initTypeAliasCheck();
function asTypeAlias(type) {
    if (type in exports.typeAliasCheck) {
        return type;
    }
    return undefined;
}
exports.asTypeAlias = asTypeAlias;
function asKnownLiteralType(type) {
    if (type in exports.superTypeDictTable) {
        return type;
    }
    return undefined;
}
exports.asKnownLiteralType = asKnownLiteralType;
function asOverrideType(type) {
    if (asKnownLiteralType(type) || type === 'term') {
        return type;
    }
    return undefined;
}
exports.asOverrideType = asOverrideType;
function asGeneralType(type) {
    if (type === 'term' || (0, expressions_1.asTermType)(type)) {
        return type;
    }
    return undefined;
}
exports.asGeneralType = asGeneralType;
/**
 * Internal type of @see isSubTypeOf This only takes knownTypes but doesn't need an enabler
 */
function isInternalSubType(baseType, argumentType) {
    return baseType !== 'term' &&
        (exports.superTypeDictTable[baseType] && exports.superTypeDictTable[baseType][argumentType] !== undefined);
}
exports.isInternalSubType = isInternalSubType;
/**
 * This function can be used to check the base type is a restriction on a type in the dict.
 * If we want to check if type x is a restriction on string we do this by calling:
 * 'http://www.w3.org/2001/XMLSchema#string' in getSuperTypeDict(X, superTypeProvider)
 * @param baseType
 * @param superTypeProvider
 */
function getSuperTypeDict(baseType, superTypeProvider) {
    const concreteType = asKnownLiteralType(baseType);
    if (concreteType) {
        // Concrete dataType is known by sparqlee.
        return exports.superTypeDictTable[concreteType];
    }
    // Datatype is a custom datatype
    return getSuperTypes(baseType, superTypeProvider);
}
exports.getSuperTypeDict = getSuperTypeDict;
/**
 * This function needs do be O(1)! The execution time of this function is vital!
 * We define typeA isSubtypeOf typeA as true.
 * If you find yourself using this function a lot (e.g. in a case) please use getSuperTypeDict instead.
 * @param baseType type you want to provide.
 * @param argumentType type you want to provide @param baseType to.
 * @param superTypeProvider the enabler to discover super types of unknown types.
 */
function isSubTypeOf(baseType, argumentType, superTypeProvider) {
    if (baseType === 'term') {
        return false;
    }
    return getSuperTypeDict(baseType, superTypeProvider)[argumentType] !== undefined;
}
exports.isSubTypeOf = isSubTypeOf;
//# sourceMappingURL=TypeHandling.js.map

/***/ }),

/***/ "../node_modules/stream-to-string/index.js":
/***/ ((module, __unused_webpack_exports, __quadstore_comunica_require__) => {

var Promise = __quadstore_comunica_require__("./require-empty.js")

module.exports = function (stream, enc, cb) {
    if (typeof enc === 'function') {
        cb = enc
        enc = null
    }
    cb = cb || function () {}

    var str = ''

    return new Promise (function (resolve, reject) {
        stream.on('data', function (data) {
            str += (typeof enc === 'string') ? data.toString(enc) : data.toString()
        })
        stream.on('end', function () {
            resolve(str)
            cb(null, str)
        })
        stream.on('error', function (err) {
            reject(err)
            cb(err)
        })
    })
}


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/empty.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.empty = void 0;
const nodes_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/index.js");
const EMPTY_MAP = { node: nodes_1.EMPTY, size: 0 };
function empty() {
    return EMPTY_MAP;
}
exports.empty = empty;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/entries.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.entries = void 0;
const primitives_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/index.js");
function entries(map) {
    return (0, primitives_1.iterator)((0, primitives_1.getNode)(map), nodeEntries);
}
exports.entries = entries;
function nodeEntries(node) {
    return [node.key, node.value];
}


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/filter.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.filter = void 0;
const empty_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/empty.js");
const reduce_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/reduce.js");
const set_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/set.js");
const filter = function filter(predicate, hashmap) {
    return (0, reduce_1.reduce)(function (newMap, value, key) {
        return predicate(value, key)
            ? (0, set_1.set)(key, value, newMap)
            : newMap;
    }, (0, empty_1.empty)(), hashmap);
};
exports.filter = filter;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/forEach.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.forEach = void 0;
const reduce_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/reduce.js");
const forEach = function forEach(f, map) {
    (0, reduce_1.reduce)((_, value, key) => f(value, key), null, map);
    return map;
};
exports.forEach = forEach;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/from.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromObject = exports.fromIterable = void 0;
const empty_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/empty.js");
const set_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/set.js");
function fromIterable(iterable) {
    let map = (0, empty_1.empty)();
    for (const [key, value] of iterable) {
        map = (0, set_1.set)(key, value, map);
    }
    return map;
}
exports.fromIterable = fromIterable;
function fromObject(object) {
    let map = (0, empty_1.empty)();
    for (let key in object) {
        if (object.hasOwnProperty(key)) {
            map = (0, set_1.set)(key, object[key], map);
        }
    }
    return map;
}
exports.fromObject = fromObject;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/get.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.get = void 0;
const primitives_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/index.js");
function get(key, map, keyEquals) {
    const hash = (0, primitives_1.findHash)(key);
    return (0, primitives_1.getHash)(undefined, hash, key, map, keyEquals);
}
exports.get = get;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/has.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.has = void 0;
const primitives_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/index.js");
const nodes_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/index.js");
function has(key, map, keyEquals) {
    const hash = (0, primitives_1.findHash)(key);
    return (0, primitives_1.getHash)(nodes_1.NOTHING, hash, key, map, keyEquals) !== nodes_1.NOTHING;
}
exports.has = has;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/keys.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.keys = void 0;
const primitives_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/index.js");
function keys(map) {
    return (0, primitives_1.iterator)((0, primitives_1.getNode)(map), nodeKeys);
}
exports.keys = keys;
function nodeKeys(node) {
    return node.key;
}


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/map.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.map = void 0;
const empty_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/empty.js");
const reduce_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/reduce.js");
const set_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/set.js");
const map = function map(f, hashmap) {
    return (0, reduce_1.reduce)(function (newMap, value, key) {
        return (0, set_1.set)(key, f(value, key), newMap);
    }, (0, empty_1.empty)(), hashmap);
};
exports.map = map;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/primitives/findHash.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findHash = void 0;
const common_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/common/index.js");
function findHash(key) {
    const hash = typeof key === 'number'
        ? key
        : typeof key === 'string'
            ? (0, common_1.stringHash)(key)
            : Math.abs((0, common_1.stringHash)(JSON.stringify(key)));
    return hash;
}
exports.findHash = findHash;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/primitives/fold.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fold = void 0;
const getNode_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/getNode.js");
function fold(f, seed, map) {
    const node = (0, getNode_1.getNode)(map);
    if (node.type === 0 /* EMPTY */)
        return seed;
    if (node.type === 1 /* LEAF */)
        return f(seed, node.value, node.key);
    const nodesToVisit = [node.children];
    let children;
    while (children = nodesToVisit.shift()) {
        for (let i = 0; i < children.length; ++i) {
            const child = children[i];
            if (!child)
                continue;
            if (child.type === 0 /* EMPTY */)
                continue;
            else if (child.type === 1 /* LEAF */)
                seed = f(seed, child.value, child.key);
            else
                nodesToVisit.push(child.children);
        }
    }
    return seed;
}
exports.fold = fold;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/primitives/getHash.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHash = void 0;
const common_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/common/index.js");
const getNode_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/getNode.js");
const keyEquals_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/keyEquals.js");
/**
 * Tries to find the value of a hash and key in a HashMap
 */
function getHash(defaultValue, hash, key, map, keyEquals = keyEquals_1.defaultKeyEquals) {
    let node = (0, getNode_1.getNode)(map);
    let shift = 0;
    while (true)
        switch (node.type) {
            case 1 /* LEAF */:
                return keyEquals(key, node.key)
                    ? node.value
                    : defaultValue;
            case 2 /* COLLISION */: {
                if (hash === node.hash) {
                    const children = node.children;
                    for (let i = 0; i < children.length; ++i) {
                        const child = children[i];
                        if (keyEquals(key, child.key))
                            return child.value;
                    }
                    return defaultValue;
                }
            }
            case 3 /* INDEX */: {
                const fragment = (0, common_1.hashFragment)(shift, hash);
                const bit = (0, common_1.toBitmap)(fragment);
                if (node.mask & bit) {
                    const i = (0, common_1.bitmapToIndex)(node.mask, bit);
                    node = node.children[i];
                    shift += common_1.SIZE;
                    break;
                }
                return defaultValue;
            }
            case 4 /* ARRAY */: {
                node = node.children[(0, common_1.hashFragment)(shift, hash)];
                if (node) {
                    shift += common_1.SIZE;
                    break;
                }
                return defaultValue;
            }
            default: return defaultValue;
        }
}
exports.getHash = getHash;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/primitives/getNode.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getNode = void 0;
function getNode(map) {
    return map.node;
}
exports.getNode = getNode;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/primitives/getSize.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSize = void 0;
function getSize(map) {
    return map.size;
}
exports.getSize = getSize;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/primitives/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/getHash.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/getNode.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/setTree.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/setKeyValue.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/findHash.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/iterateMap.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/fold.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/keyEquals.js"), exports);


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/primitives/iterateMap.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iterator = void 0;
function iterator(node, f) {
    return new HashMapIterator(lazyVisit(node, f, []));
}
exports.iterator = iterator;
class HashMapIterator {
    _iterate;
    constructor(_iterate) {
        this._iterate = _iterate;
    }
    next() {
        if (!this._iterate)
            return { done: true, value: null };
        const { value, rest } = this._iterate;
        this._iterate = continuation(rest);
        return { done: false, value };
    }
    [Symbol.iterator]() {
        return this;
    }
}
const continuation = (k) => k && lazyVisitChildren(k[0], k[1], k[2], k[3], k[4]);
function lazyVisit(node, f, k) {
    switch (node.type) {
        case 1 /* LEAF */:
            return { value: f(node), rest: k };
        case 2 /* COLLISION */:
        case 4 /* ARRAY */:
        case 3 /* INDEX */:
            const children = node.children;
            return lazyVisitChildren(children.length, children, 0, f, k);
        default:
            return continuation(k);
    }
}
;
function lazyVisitChildren(length, children, index, f, k) {
    while (index < length) {
        const child = children[index++];
        if (child && notEmptyNode(child))
            return lazyVisit(child, f, [length, children, index, f, k]);
    }
    return continuation(k);
}
;
function notEmptyNode(node) {
    return node && node.type !== 0 /* EMPTY */;
}


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/primitives/keyEquals.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultKeyEquals = void 0;
const defaultKeyEquals = (a, b) => a === b;
exports.defaultKeyEquals = defaultKeyEquals;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/primitives/setKeyValue.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setKeyValue = void 0;
const nodes_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/index.js");
const findHash_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/findHash.js");
const getNode_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/getNode.js");
const getSize_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/getSize.js");
const setTree_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/setTree.js");
const constant = (x) => () => x;
function setKeyValue(key, value, map) {
    const hash = (0, findHash_1.findHash)(key);
    const size = { value: (0, getSize_1.getSize)(map) };
    const newNode = (0, nodes_1.modify)((0, getNode_1.getNode)(map), 0, constant(value), hash, key, size);
    return (0, setTree_1.setTree)(newNode, size.value, map);
}
exports.setKeyValue = setKeyValue;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/primitives/setTree.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setTree = void 0;
const getNode_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/getNode.js");
/**
 * Creates a new HashMap with a given Node and size
 * Does not create a new HashMap if the new Node is the same (by reference)
 * to the current (private) root Node.
 */
function setTree(node, size, map) {
    // use type casting to keep node private on HashMap
    return node === (0, getNode_1.getNode)(map)
        ? map
        : { node, size };
}
exports.setTree = setTree;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/reduce.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reduce = void 0;
const primitives_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/index.js");
exports.reduce = primitives_1.fold;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/remove.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.remove = void 0;
const primitives_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/index.js");
const constants_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/constants.js");
function remove(key, map) {
    return (0, primitives_1.setKeyValue)(key, constants_1.NOTHING, map);
}
exports.remove = remove;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/set.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.set = void 0;
const primitives_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/index.js");
exports.set = primitives_1.setKeyValue;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/size.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.size = void 0;
const getSize_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/getSize.js");
function size(map) {
    return (0, getSize_1.getSize)(map);
}
exports.size = size;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/HashMap/values.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.values = void 0;
const primitives_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/primitives/index.js");
function values(map) {
    return (0, primitives_1.iterator)((0, primitives_1.getNode)(map), nodeValues);
}
exports.values = values;
function nodeValues(node) {
    return node.value;
}


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/common/array-operations.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.insert = exports.remove = exports.replace = void 0;
/**
 * Immutable replacement of a value at a given index
 */
function replace(index, value, array) {
    const length = array.length;
    const newArray = Array(length);
    for (let i = 0; i < length; ++i) {
        newArray[i] = array[i];
    }
    newArray[index] = value;
    return newArray;
}
exports.replace = replace;
/**
 * Immutable removal of a value at given index
 */
function remove(index, array) {
    const length = array.length;
    if (length === 0 || index >= length)
        return array;
    if (length === 1)
        return [];
    const newArray = Array(length - 1);
    let i = 0;
    for (; i < index; ++i)
        newArray[i] = array[i];
    for (i = i + 1; i < length; ++i)
        newArray[i - 1] = array[i];
    return newArray;
}
exports.remove = remove;
/**
 * Immutable insertion of a value at a given index
 */
function insert(index, value, array) {
    const length = array.length;
    const newArray = Array(length + 1);
    let i = 0;
    for (; i < index; ++i)
        newArray[i] = array[i];
    newArray[i++] = value;
    for (; i < length + 1; ++i)
        newArray[i] = array[i - 1];
    return newArray;
}
exports.insert = insert;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/common/bitwise-operations.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bitmapToIndex = exports.toBitmap = exports.hashFragment = exports.hammingWeight = void 0;
const constants_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/common/constants.js");
function hammingWeight(num) {
    num = num - ((num >> 1) & 0x55555555);
    num = (num & 0x33333333) + ((num >> 2) & 0x33333333);
    return ((num + (num >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;
}
exports.hammingWeight = hammingWeight;
function hashFragment(shift, hash) {
    return (hash >>> shift) & constants_1.MASK;
}
exports.hashFragment = hashFragment;
function toBitmap(num) {
    return 1 << num;
}
exports.toBitmap = toBitmap;
function bitmapToIndex(shift, bitmap) {
    return hammingWeight(shift & (bitmap - 1));
}
exports.bitmapToIndex = bitmapToIndex;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/common/constants.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MIN_ARRAY_NODE = exports.MAX_INDEX_NODE = exports.MASK = exports.BUCKET_SIZE = exports.SIZE = void 0;
exports.SIZE = 5;
exports.BUCKET_SIZE = Math.pow(2, exports.SIZE);
exports.MASK = exports.BUCKET_SIZE - 1;
exports.MAX_INDEX_NODE = exports.BUCKET_SIZE / 2;
exports.MIN_ARRAY_NODE = exports.BUCKET_SIZE / 4;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/common/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/common/array-operations.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/common/bitwise-operations.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/common/constants.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/common/stringHash.js"), exports);


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/common/stringHash.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringHash = void 0;
/**
 * Generator of 32 bit hashes of given string
 */
function stringHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; ++i)
        hash = (((hash << 5) - hash) + str.charCodeAt(i)) | 0;
    return hash;
}
exports.stringHash = stringHash;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/nodes/ArrayNode/ArrayNode.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.modifyListNode = void 0;
const EmptyNode_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/EmptyNode.js");
const modify_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/modify.js");
const common_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/common/index.js");
const toIndexNode_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/ArrayNode/toIndexNode.js");
function modifyListNode(node, shift, get, hash, key, size) {
    const { size: count, children } = node;
    const fragment = (0, common_1.hashFragment)(shift, hash);
    const child = children[fragment];
    const newChild = (0, modify_1.modify)(child || (0, EmptyNode_1.empty)(), shift + common_1.SIZE, get, hash, key, size);
    if (child === newChild)
        return node;
    if (isEmptyNode(child) && !isEmptyNode(newChild))
        return { type: 4 /* ARRAY */, size: count + 1, children: (0, common_1.replace)(fragment, newChild, children) };
    if (!isEmptyNode(child) && isEmptyNode(newChild))
        return count - 1 <= common_1.MIN_ARRAY_NODE
            ? (0, toIndexNode_1.toIndexNode)(count, fragment, children)
            : { type: 4 /* ARRAY */, size: count - 1, children: (0, common_1.replace)(fragment, (0, EmptyNode_1.empty)(), children) };
    return { type: 4 /* ARRAY */, size: count, children: (0, common_1.replace)(fragment, newChild, children) };
}
exports.modifyListNode = modifyListNode;
function isEmptyNode(node) {
    return node && node.type === 0 /* EMPTY */;
}


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/nodes/ArrayNode/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/ArrayNode/ArrayNode.js"), exports);


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/nodes/ArrayNode/toIndexNode.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toIndexNode = void 0;
function toIndexNode(count, index, children) {
    const newChildren = new Array(count - 1);
    let g = 0;
    let bitmap = 0;
    for (let i = 0; i < children.length; ++i) {
        if (i !== index) {
            const child = children[i];
            if (child && child.type > 0 /* EMPTY */) {
                newChildren[g++] = child;
                bitmap |= 1 << i;
            }
        }
    }
    return { type: 3 /* INDEX */, mask: bitmap, children: newChildren };
}
exports.toIndexNode = toIndexNode;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/nodes/CollisionNode/CollisionNode.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.modifyCollisionNode = void 0;
const constants_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/constants.js");
const LeafNode_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/LeafNode/index.js");
const newCollisionList_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/CollisionNode/newCollisionList.js");
function modifyCollisionNode(node, shift, get, hash, key, size) {
    if (hash === node.hash) {
        const list = (0, newCollisionList_1.newCollisionList)(node.hash, node.children, get, key, size);
        if (list === node.children)
            return node;
        return list.length > 1
            ? { type: 2 /* COLLISION */, hash: node.hash, children: list }
            : list[0];
    }
    const value = get();
    if (value === constants_1.NOTHING)
        return node;
    ++size.value;
    return (0, LeafNode_1.combineLeafNodes)(shift, node.hash, node, hash, { type: 1 /* LEAF */, hash, key, value });
}
exports.modifyCollisionNode = modifyCollisionNode;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/nodes/CollisionNode/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/CollisionNode/CollisionNode.js"), exports);


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/nodes/CollisionNode/newCollisionList.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.newCollisionList = void 0;
const constants_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/constants.js");
// import { LeafNode } from '../LeafNode';
const common_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/common/index.js");
function newCollisionList(hash, list, get, key, size) {
    const length = list.length;
    for (let i = 0; i < length; ++i) {
        const child = list[i];
        if (child.key === key) {
            const value = child.value;
            const newValue = get(value);
            if (newValue === value)
                return list;
            if (newValue === constants_1.NOTHING) {
                --size.value;
                return (0, common_1.remove)(i, list);
            }
            return (0, common_1.insert)(i, { type: 1 /* LEAF */, hash, key, value: newValue }, list);
        }
    }
    const newValue = get();
    if (newValue === constants_1.NOTHING)
        return list;
    ++size.value;
    return (0, common_1.insert)(length, { type: 1 /* LEAF */, hash, key, value: newValue }, list);
}
exports.newCollisionList = newCollisionList;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/nodes/EmptyNode.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.empty = exports.EMPTY = exports.modifyEmpty = void 0;
const constants_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/constants.js");
// import { LeafNode } from './LeafNode';
// export class EmptyNode<K, V> implements Empty<K, V> {
//   public type: NodeType.EMPTY = NodeType.EMPTY;
//
//   public modify(
//     shift: number,
//     get: (value?: any) => any,
//     hash: number,
//     key: K,
//     size: { value: number }): Node<K, V>
//   {
//     const value = get(void shift);
//     if (value === NOTHING)
//       return this;
//
//     ++size.value;
//
//     return { type: NodeType.LEAF, hash, key, value };
//   }
// }
function modifyEmpty(node, shift, get, hash, key, size) {
    const value = get(void shift);
    if (value === constants_1.NOTHING)
        return node;
    ++size.value;
    return { type: 1 /* LEAF */, hash, key, value };
}
exports.modifyEmpty = modifyEmpty;
exports.EMPTY = { type: 0 /* EMPTY */ };
function empty() {
    return exports.EMPTY;
}
exports.empty = empty;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/nodes/IndexedNode/IndexedNode.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.modifyIndexedNode = void 0;
const EmptyNode_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/EmptyNode.js");
const common_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/common/index.js");
const modify_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/modify.js");
const toArrayNode_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/IndexedNode/toArrayNode.js");
function modifyIndexedNode(node, shift, get, hash, key, size) {
    const { mask, children } = node;
    const fragment = (0, common_1.hashFragment)(shift, hash);
    const bit = (0, common_1.toBitmap)(fragment);
    const index = (0, common_1.bitmapToIndex)(mask, bit);
    const exists = Boolean(mask & bit);
    const current = exists ? children[index] : (0, EmptyNode_1.empty)();
    const child = (0, modify_1.modify)(current, shift + common_1.SIZE, get, hash, key, size);
    if (current === child)
        return node;
    if (exists && child.type === 0 /* EMPTY */) {
        const bitmap = mask & ~bit;
        if (!bitmap)
            return (0, EmptyNode_1.empty)();
        return children.length <= 2 && isLeaf(children[index ^ 1])
            ? children[index ^ 1]
            : { type: 3 /* INDEX */, mask: bitmap, children: (0, common_1.remove)(index, children) };
    }
    if (!exists && child.type !== 0 /* EMPTY */) {
        return children.length >= common_1.MAX_INDEX_NODE
            ? (0, toArrayNode_1.toArrayNode)(fragment, child, mask, children)
            : { type: 3 /* INDEX */, mask: mask | bit, children: (0, common_1.insert)(index, child, children) };
    }
    return { type: 3 /* INDEX */, mask, children: (0, common_1.replace)(index, child, children) };
}
exports.modifyIndexedNode = modifyIndexedNode;
function isLeaf(node) {
    const type = node.type;
    return type === 0 /* EMPTY */ ||
        type === 1 /* LEAF */ ||
        type === 2 /* COLLISION */;
}


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/nodes/IndexedNode/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/IndexedNode/IndexedNode.js"), exports);


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/nodes/IndexedNode/toArrayNode.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toArrayNode = void 0;
function toArrayNode(fragment, child, bitmap, children) {
    const array = [];
    let bit = bitmap;
    let count = 0;
    for (let i = 0; bit; ++i) {
        if (bit & 1)
            array[i] = children[count++];
        bit >>>= 1;
    }
    array[fragment] = child;
    return { type: 4 /* ARRAY */, size: count + 1, children: array };
}
exports.toArrayNode = toArrayNode;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/nodes/LeafNode/LeafNode.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.modifyLeaf = void 0;
const constants_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/constants.js");
const EmptyNode_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/EmptyNode.js");
const combineLeafNodes_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/LeafNode/combineLeafNodes.js");
function modifyLeaf(node, shift, get, hash, key, size) {
    if (key === node.key) {
        const value = get(node.value);
        if (value === node.value)
            return node;
        if (value === constants_1.NOTHING) {
            --size.value;
            return (0, EmptyNode_1.empty)();
        }
        return { type: 1 /* LEAF */, hash, key, value };
    }
    const value = get();
    if (value === constants_1.NOTHING)
        return node;
    ++size.value;
    return (0, combineLeafNodes_1.combineLeafNodes)(shift, node.hash, node, hash, { type: 1 /* LEAF */, hash, key, value });
}
exports.modifyLeaf = modifyLeaf;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/nodes/LeafNode/combineLeafNodes.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.combineLeafNodes = void 0;
const common_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/common/index.js");
function combineLeafNodes(shift, hash1, leafNode1, hash2, leafNode2) {
    if (hash1 === hash2)
        return { type: 2 /* COLLISION */, hash: hash1, children: [leafNode2, leafNode1] };
    const fragment1 = (0, common_1.hashFragment)(shift, hash1);
    const fragment2 = (0, common_1.hashFragment)(shift, hash2);
    return {
        type: 3 /* INDEX */,
        mask: (0, common_1.toBitmap)(fragment1) | (0, common_1.toBitmap)(fragment2),
        children: (fragment1 === fragment2
            ? [combineLeafNodes(shift + common_1.SIZE, hash1, leafNode1, hash2, leafNode2)]
            : fragment1 < fragment2 ? [leafNode1, leafNode2] : [leafNode2, leafNode1]),
    };
}
exports.combineLeafNodes = combineLeafNodes;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/nodes/LeafNode/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/LeafNode/LeafNode.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/LeafNode/combineLeafNodes.js"), exports);


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/nodes/constants.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NOTHING = void 0;
exports.NOTHING = Object.create(null);


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/nodes/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/types.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/constants.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/EmptyNode.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/ArrayNode/index.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/CollisionNode/index.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/IndexedNode/index.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/LeafNode/index.js"), exports);
__exportStar(__quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/modify.js"), exports);


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/nodes/modify.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.modify = void 0;
const LeafNode_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/LeafNode/index.js");
const EmptyNode_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/EmptyNode.js");
const ArrayNode_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/ArrayNode/index.js");
const IndexedNode_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/IndexedNode/index.js");
const CollisionNode_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/nodes/CollisionNode/index.js");
function modify(node, shift, get, hash, key, size) {
    switch (node.type) {
        case 1 /* LEAF */:
            return (0, LeafNode_1.modifyLeaf)(node, shift, get, hash, key, size);
        case 0 /* EMPTY */:
            return (0, EmptyNode_1.modifyEmpty)(node, shift, get, hash, key, size);
        case 4 /* ARRAY */:
            return (0, ArrayNode_1.modifyListNode)(node, shift, get, hash, key, size);
        case 3 /* INDEX */:
            return (0, IndexedNode_1.modifyIndexedNode)(node, shift, get, hash, key, size);
        case 2 /* COLLISION */:
            return (0, CollisionNode_1.modifyCollisionNode)(node, shift, get, hash, key, size);
        default:
            throw new Error('never');
    }
}
exports.modify = modify;


/***/ }),

/***/ "../node_modules/typed-immutable-map/dist/nodes/types.js":
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../node_modules/uuid-random/index.js":
/***/ ((module, __unused_webpack_exports, __quadstore_comunica_require__) => {



(function(){

  var
    buf,
    bufIdx = 0,
    hexBytes = [],
    i
  ;

  // Pre-calculate toString(16) for speed
  for (i = 0; i < 256; i++) {
    hexBytes[i] = (i + 0x100).toString(16).substr(1);
  }

  // Buffer random numbers for speed
  // Reduce memory usage by decreasing this number (min 16)
  // or improve speed by increasing this number (try 16384)
  uuid.BUFFER_SIZE = 4096;

  // Binary uuids
  uuid.bin = uuidBin;

  // Clear buffer
  uuid.clearBuffer = function() {
    buf = null;
    bufIdx = 0;
  };

  // Test for uuid
  uuid.test = function(uuid) {
    if (typeof uuid === 'string') {
      return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(uuid);
    }
    return false;
  };

  // Node & Browser support
  var crypt0;
  if (typeof crypto !== 'undefined') {
    crypt0 = crypto;
  } else if( (typeof window !== 'undefined') && (typeof window.msCrypto !== 'undefined')) {
    crypt0 = window.msCrypto; // IE11
  }

  if (true) {
    crypt0 = crypt0 || __quadstore_comunica_require__("?699d");
    module.exports = uuid;
  } else {}

  // Use best available PRNG
  // Also expose this so you can override it.
  uuid.randomBytes = (function(){
    if (crypt0) {
      if (crypt0.randomBytes) {
        return crypt0.randomBytes;
      }
      if (crypt0.getRandomValues) {
        if (typeof Uint8Array.prototype.slice !== 'function') {
          return function(n) {
            var bytes = new Uint8Array(n);
            crypt0.getRandomValues(bytes);
            return Array.from(bytes);
          };
        }
        return function(n) {
          var bytes = new Uint8Array(n);
          crypt0.getRandomValues(bytes);
          return bytes;
        };
      }
    }
    return function(n) {
      var i, r = [];
      for (i = 0; i < n; i++) {
        r.push(Math.floor(Math.random() * 256));
      }
      return r;
    };
  })();

  // Buffer some random bytes for speed
  function randomBytesBuffered(n) {
    if (!buf || ((bufIdx + n) > uuid.BUFFER_SIZE)) {
      bufIdx = 0;
      buf = uuid.randomBytes(uuid.BUFFER_SIZE);
    }
    return buf.slice(bufIdx, bufIdx += n);
  }

  // uuid.bin
  function uuidBin() {
    var b = randomBytesBuffered(16);
    b[6] = (b[6] & 0x0f) | 0x40;
    b[8] = (b[8] & 0x3f) | 0x80;
    return b;
  }

  // String UUIDv4 (Random)
  function uuid() {
    var b = uuidBin();
    return hexBytes[b[0]] + hexBytes[b[1]] +
      hexBytes[b[2]] + hexBytes[b[3]] + '-' +
      hexBytes[b[4]] + hexBytes[b[5]] + '-' +
      hexBytes[b[6]] + hexBytes[b[7]] + '-' +
      hexBytes[b[8]] + hexBytes[b[9]] + '-' +
      hexBytes[b[10]] + hexBytes[b[11]] +
      hexBytes[b[12]] + hexBytes[b[13]] +
      hexBytes[b[14]] + hexBytes[b[15]]
    ;
  }

})();


/***/ }),

/***/ "../node_modules/yallist/iterator.js":
/***/ ((module) => {


module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value
    }
  }
}


/***/ }),

/***/ "../node_modules/yallist/yallist.js":
/***/ ((module, __unused_webpack_exports, __quadstore_comunica_require__) => {


module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null

  return next
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next
  }

  var ret = []
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value)
    walker = this.removeNode(walker)
  }
  if (walker === null) {
    walker = this.tail
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev
  }

  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i])
  }
  return ret;
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function insert (self, node, value) {
  var inserted = node === self.head ?
    new Node(value, null, node, self) :
    new Node(value, node, node.next, self)

  if (inserted.next === null) {
    self.tail = inserted
  }
  if (inserted.prev === null) {
    self.head = inserted
  }

  self.length++

  return inserted
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

try {
  // add if support for Symbol.iterator is present
  __quadstore_comunica_require__("../node_modules/yallist/iterator.js")(Yallist)
} catch (er) {}


/***/ }),

/***/ "../packages/immutable/dist/Map.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Map = void 0;
const has_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/has.js");
const get_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/get.js");
const set_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/set.js");
const forEach_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/forEach.js");
const map_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/map.js");
const filter_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/filter.js");
const remove_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/remove.js");
const entries_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/entries.js");
const values_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/values.js");
const keys_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/keys.js");
const size_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/size.js");
class Map {
    hashmap;
    constructor(entries) {
        this.hashmap = entries;
    }
    get size() {
        return (0, size_1.size)(this.hashmap);
    }
    set(key, value) {
        return new Map((0, set_1.set)(key, value, this.hashmap));
    }
    delete(key) {
        return new Map((0, remove_1.remove)(key, this.hashmap));
    }
    get(key) {
        return (0, get_1.get)(key, this.hashmap);
    }
    has(key) {
        return (0, has_1.has)(key, this.hashmap);
    }
    forEach(iterator) {
        (0, forEach_1.forEach)(iterator, this.hashmap);
    }
    map(iterator) {
        return new Map((0, map_1.map)(iterator, this.hashmap));
    }
    filter(iterator) {
        return new Map((0, filter_1.filter)(iterator, this.hashmap));
    }
    toJS() {
        return Object.fromEntries(this);
    }
    toJSON() {
        return this.toJS();
    }
    keys() {
        return (0, keys_1.keys)(this.hashmap);
    }
    values() {
        return (0, values_1.values)(this.hashmap);
    }
    entries() {
        return (0, entries_1.entries)(this.hashmap);
    }
    [Symbol.iterator]() {
        return this.entries();
    }
}
exports.Map = Map;


/***/ }),

/***/ "../packages/immutable/dist/index.js":
/***/ ((__unused_webpack_module, exports, __quadstore_comunica_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Map = void 0;
const empty_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/empty.js");
const from_1 = __quadstore_comunica_require__("../node_modules/typed-immutable-map/dist/HashMap/from.js");
const Map_1 = __quadstore_comunica_require__("../packages/immutable/dist/Map.js");
const isIterable = (item) => {
    return Symbol.iterator in item;
};
function Map(data) {
    if (data) {
        if (isIterable(data)) {
            return new Map_1.Map((0, from_1.fromIterable)(data));
        }
        else {
            return new Map_1.Map((0, from_1.fromObject)(data));
        }
    }
    else {
        return new Map_1.Map((0, empty_1.empty)());
    }
}
exports.Map = Map;


/***/ }),

/***/ "../packages/uuid/dist/index.js":
/***/ (function(__unused_webpack_module, exports, __quadstore_comunica_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.v4 = void 0;
const uuid_random_1 = __importDefault(__quadstore_comunica_require__("../node_modules/uuid-random/index.js"));
exports.v4 = uuid_random_1.default;


/***/ }),

/***/ "asynciterator":
/***/ ((module) => {

var x = y => { var x = {}; __quadstore_comunica_require__.d(x, y); return x; }
var y = x => () => x
module.exports = __QUADSTORE_COMUNICA_EXTERNAL_MODULE_asynciterator__;

/***/ }),

/***/ "sparqlalgebrajs":
/***/ ((module) => {

var x = y => { var x = {}; __quadstore_comunica_require__.d(x, y); return x; }
var y = x => () => x
module.exports = __QUADSTORE_COMUNICA_EXTERNAL_MODULE_sparqlalgebrajs__;

/***/ }),

/***/ "sparqljs":
/***/ ((module) => {

var x = y => { var x = {}; __quadstore_comunica_require__.d(x, y); return x; }
var y = x => () => x
module.exports = __QUADSTORE_COMUNICA_EXTERNAL_MODULE_sparqljs__;

/***/ }),

/***/ "?699d":
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./require-empty.js":
/***/ (() => {



/***/ }),

/***/ "./src/crypto-polyfill.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __quadstore_comunica_require__) => {


// The Webpack bundle of this package is built using the "target: browser"
// option (see webpack.config.js). This leads some packages to assume the
// availability of the Web Crypto API through the global "crypto" object.
// As we don't have that in Node.js but usage seems to be limited to the
// crypto.getRandomValues() method, we use Node.js' own crypto module to
// create a polyfill.

const isNode = typeof process !== 'undefined'
  && process.versions != null
  && process.versions.node != null;

const polyfillCrypto = ({ randomFillSync }) => {
  __quadstore_comunica_require__.g.crypto = {};
  __quadstore_comunica_require__.g.crypto.getRandomValues = (arr) => {
    randomFillSync(arr);
    return arr;
  };
};

if (isNode && typeof crypto === 'undefined') {

  if (eval('typeof require === \'function\'')) {

    // require() is wrapped into eval() so that it is ignored by webpack.
    polyfillCrypto(eval('require(\'crypto\');'));

  } else {

    // import() is wrapped into eval() so that it is ignored by webpack.
    eval('import(\'crypto\');').then(polyfillCrypto).catch((err) => {
      console.error(err);
      process.exit(1);
    });

  }

}


/***/ }),

/***/ "./src/engine.js":
/***/ ((module, __unused_webpack_exports, __quadstore_comunica_require__) => {

const df_357_1 = new ((__quadstore_comunica_require__("../node_modules/@comunica/logger-void/lib/index.js").LoggerVoid))();
const https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_init__2_0_0_components_ActorInit_jsonld_ActorInit_default_bus = new ((__quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js").Bus))({
  'name': 'https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-init/^2.0.0/components/ActorInit.jsonld#ActorInit_default_bus'
});
const https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_hash_bindings__2_0_0_components_ActorHashBindings_jsonld_ActorHashBindings_default_bus = new ((__quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js").Bus))({
  'name': 'https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-hash-bindings/^2.0.0/components/ActorHashBindings.jsonld#ActorHashBindings_default_bus'
});
const https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_context_preprocess__2_0_0_components_ActorContextPreprocess_jsonld_ActorContextPreprocess_default_bus = new ((__quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js").Bus))({
  'name': 'https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-context-preprocess/^2.0.0/components/ActorContextPreprocess.jsonld#ActorContextPreprocess_default_bus'
});
const https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_optimize_query_operation__2_0_0_components_ActorOptimizeQueryOperation_jsonld_ActorOptimizeQueryOperation_default_bus = new ((__quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js").Bus))({
  'name': 'https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-optimize-query-operation/^2.0.0/components/ActorOptimizeQueryOperation.jsonld#ActorOptimizeQueryOperation_default_bus'
});
const https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus = new ((__quadstore_comunica_require__("../node_modules/@comunica/bus-query-operation/lib/index.js").BusQueryOperation))({
  'name': 'https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-query-operation/^2.0.0/components/ActorQueryOperation.jsonld#ActorQueryOperation_default_bus'
});
const https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_parse__2_0_0_components_ActorQueryParse_jsonld_ActorQueryParse_default_bus = new ((__quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js").Bus))({
  'name': 'https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-query-parse/^2.0.0/components/ActorQueryParse.jsonld#ActorQueryParse_default_bus'
});
const https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_result_serialize__2_0_0_components_ActorQueryResultSerialize_jsonld_ActorQueryResultSerialize_default_bus = new ((__quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js").Bus))({
  'name': 'https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-query-result-serialize/^2.0.0/components/ActorQueryResultSerialize.jsonld#ActorQueryResultSerialize_default_bus'
});
const https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_http_invalidate__2_0_0_components_ActorHttpInvalidate_jsonld_ActorHttpInvalidate_default_bus = new ((__quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js").Bus))({
  'name': 'https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-http-invalidate/^2.0.0/components/ActorHttpInvalidate.jsonld#ActorHttpInvalidate_default_bus'
});
const https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join_selectivity__2_0_0_components_ActorRdfJoinSelectivity_jsonld_ActorRdfJoinSelectivity_default_bus = new ((__quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js").Bus))({
  'name': 'https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-join-selectivity/^2.0.0/components/ActorRdfJoinSelectivity.jsonld#ActorRdfJoinSelectivity_default_bus'
});
const https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join_entries_sort__2_0_0_components_ActorRdfJoinEntriesSort_jsonld_ActorRdfJoinEntriesSort_default_bus = new ((__quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js").Bus))({
  'name': 'https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-join-entries-sort/^2.0.0/components/ActorRdfJoinEntriesSort.jsonld#ActorRdfJoinEntriesSort_default_bus'
});
const https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_update_quads__2_0_0_components_ActorRdfUpdateQuads_jsonld_ActorRdfUpdateQuads_default_bus = new ((__quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js").Bus))({
  'name': 'https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-update-quads/^2.0.0/components/ActorRdfUpdateQuads.jsonld#ActorRdfUpdateQuads_default_bus'
});
const https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join__2_0_0_components_ActorRdfJoin_jsonld_ActorRdfJoin_default_bus = new ((__quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js").Bus))({
  'name': 'https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-join/^2.0.0/components/ActorRdfJoin.jsonld#ActorRdfJoin_default_bus'
});
const https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_resolve_quad_pattern__2_0_0_components_ActorRdfResolveQuadPattern_jsonld_ActorRdfResolveQuadPattern_default_bus = new ((__quadstore_comunica_require__("../node_modules/@comunica/core/lib/index.js").Bus))({
  'name': 'https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-resolve-quad-pattern/^2.0.0/components/ActorRdfResolveQuadPattern.jsonld#ActorRdfResolveQuadPattern_default_bus'
});
const urn_comunica_default_hash_bindings_actors_sha1 = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-hash-bindings-sha1/lib/index.js").ActorHashBindingsSha1))({
  'name': 'urn:comunica:default:hash-bindings/actors#sha1',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_hash_bindings__2_0_0_components_ActorHashBindings_jsonld_ActorHashBindings_default_bus
});
const urn_comunica_default_hash_bindings_mediators_main = new ((__quadstore_comunica_require__("../node_modules/@comunica/mediator-race/lib/index.js").MediatorRace))({
  'name': 'urn:comunica:default:hash-bindings/mediators#main',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_hash_bindings__2_0_0_components_ActorHashBindings_jsonld_ActorHashBindings_default_bus
});
const urn_comunica_default_context_preprocess_actors_source_to_destination = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-context-preprocess-source-to-destination/lib/index.js").ActorContextPreprocessSourceToDestination))({
  'name': 'urn:comunica:default:context-preprocess/actors#source-to-destination',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_context_preprocess__2_0_0_components_ActorContextPreprocess_jsonld_ActorContextPreprocess_default_bus
});
const urn_comunica_default_context_preprocess_mediators_main = new ((__quadstore_comunica_require__("../node_modules/@comunica/mediator-combine-pipeline/lib/index.js").MediatorCombinePipeline))({
  'name': 'urn:comunica:default:context-preprocess/mediators#main',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_context_preprocess__2_0_0_components_ActorContextPreprocess_jsonld_ActorContextPreprocess_default_bus
});
const urn_comunica_default_optimize_query_operation_actors_join_bgp = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-optimize-query-operation-join-bgp/lib/index.js").ActorOptimizeQueryOperationJoinBgp))({
  'name': 'urn:comunica:default:optimize-query-operation/actors#join-bgp',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_optimize_query_operation__2_0_0_components_ActorOptimizeQueryOperation_jsonld_ActorOptimizeQueryOperation_default_bus
});
const urn_comunica_default_optimize_query_operation_actors_bgp_to_join = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-optimize-query-operation-bgp-to-join/lib/index.js").ActorOptimizeQueryOperationBgpToJoin))({
  'name': 'urn:comunica:default:optimize-query-operation/actors#bgp-to-join',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_optimize_query_operation__2_0_0_components_ActorOptimizeQueryOperation_jsonld_ActorOptimizeQueryOperation_default_bus
});
const urn_comunica_default_optimize_query_operation_actors_join_connected = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-optimize-query-operation-join-connected/lib/index.js").ActorOptimizeQueryOperationJoinConnected))({
  'name': 'urn:comunica:default:optimize-query-operation/actors#join-connected',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_optimize_query_operation__2_0_0_components_ActorOptimizeQueryOperation_jsonld_ActorOptimizeQueryOperation_default_bus
});
const urn_comunica_default_optimize_query_operation_mediators_main = new ((__quadstore_comunica_require__("../node_modules/@comunica/mediator-combine-pipeline/lib/index.js").MediatorCombinePipeline))({
  'name': 'urn:comunica:default:optimize-query-operation/mediators#main',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_optimize_query_operation__2_0_0_components_ActorOptimizeQueryOperation_jsonld_ActorOptimizeQueryOperation_default_bus
});
const urn_comunica_default_query_operation_mediators_main = new ((__quadstore_comunica_require__("../node_modules/@comunica/mediator-number/lib/index.js").MediatorNumber))({
  'field': 'httpRequests',
  'type': 'min',
  'ignoreErrors': true,
  'name': 'urn:comunica:default:query-operation/mediators#main',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_values = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-values/lib/index.js").ActorQueryOperationValues))({
  'name': 'urn:comunica:default:query-operation/actors#values',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_parse_mediators_main = new ((__quadstore_comunica_require__("../node_modules/@comunica/mediator-race/lib/index.js").MediatorRace))({
  'name': 'urn:comunica:default:query-parse/mediators#main',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_parse__2_0_0_components_ActorQueryParse_jsonld_ActorQueryParse_default_bus
});
const urn_comunica_default_query_parse_actors_sparql = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-parse-sparql/lib/index.js").ActorQueryParseSparql))({
  'prefixes': {"dbpedia":"http://dbpedia.org/resource/","dbpedia-owl":"http://dbpedia.org/ontology/","dbpprop":"http://dbpedia.org/property/","dc":"http://purl.org/dc/terms/","dc11":"http://purl.org/dc/elements/1.1/","dcterms":"http://purl.org/dc/terms/","foaf":"http://xmlns.com/foaf/0.1/","geo":"http://www.w3.org/2003/01/geo/wgs84_pos#","owl":"http://www.w3.org/2002/07/owl#","rdf":"http://www.w3.org/1999/02/22-rdf-syntax-ns#","rdfs":"http://www.w3.org/2000/01/rdf-schema#","schema":"http://schema.org/","skos":"http://www.w3.org/2008/05/skos#","xsd":"http://www.w3.org/2001/XMLSchema#"},
  'name': 'urn:comunica:default:query-parse/actors#sparql',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_parse__2_0_0_components_ActorQueryParse_jsonld_ActorQueryParse_default_bus
});
const urn_comunica_default_query_result_serialize_mediators_serialize = new ((__quadstore_comunica_require__("../node_modules/@comunica/mediator-race/lib/index.js").MediatorRace))({
  'name': 'urn:comunica:default:query-result-serialize/mediators#serialize',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_result_serialize__2_0_0_components_ActorQueryResultSerialize_jsonld_ActorQueryResultSerialize_default_bus
});
const urn_comunica_default_query_result_serialize_mediators_mediaType = new ((__quadstore_comunica_require__("../node_modules/@comunica/mediator-combine-union/lib/index.js").MediatorCombineUnion))({
  'field': 'mediaTypes',
  'name': 'urn:comunica:default:query-result-serialize/mediators#mediaType',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_result_serialize__2_0_0_components_ActorQueryResultSerialize_jsonld_ActorQueryResultSerialize_default_bus
});
const urn_comunica_default_query_result_serialize_mediators_mediaTypeFormat = new ((__quadstore_comunica_require__("../node_modules/@comunica/mediator-combine-union/lib/index.js").MediatorCombineUnion))({
  'field': 'mediaTypeFormats',
  'name': 'urn:comunica:default:query-result-serialize/mediators#mediaTypeFormat',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_result_serialize__2_0_0_components_ActorQueryResultSerialize_jsonld_ActorQueryResultSerialize_default_bus
});
const urn_comunica_default_http_invalidate_mediators_main = new ((__quadstore_comunica_require__("../node_modules/@comunica/mediator-all/lib/index.js").MediatorAll))({
  'name': 'urn:comunica:default:http-invalidate/mediators#main',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_http_invalidate__2_0_0_components_ActorHttpInvalidate_jsonld_ActorHttpInvalidate_default_bus
});
const urn_comunica_default_rdf_join_selectivity_actors_variable_counting = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-selectivity-variable-counting/lib/index.js").ActorRdfJoinSelectivityVariableCounting))({
  'name': 'urn:comunica:default:rdf-join-selectivity/actors#variable-counting',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join_selectivity__2_0_0_components_ActorRdfJoinSelectivity_jsonld_ActorRdfJoinSelectivity_default_bus
});
const urn_comunica_default_rdf_join_selectivity_mediators_main = new ((__quadstore_comunica_require__("../node_modules/@comunica/mediator-number/lib/index.js").MediatorNumber))({
  'field': 'accuracy',
  'type': 'max',
  'ignoreErrors': true,
  'name': 'urn:comunica:default:rdf-join-selectivity/mediators#main',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join_selectivity__2_0_0_components_ActorRdfJoinSelectivity_jsonld_ActorRdfJoinSelectivity_default_bus
});
const urn_comunica_default_rdf_join_entries_sort_actors_cardinality = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-entries-sort-cardinality/lib/index.js").ActorRdfJoinEntriesSortCardinality))({
  'name': 'urn:comunica:default:rdf-join-entries-sort/actors#cardinality',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join_entries_sort__2_0_0_components_ActorRdfJoinEntriesSort_jsonld_ActorRdfJoinEntriesSort_default_bus
});
const urn_comunica_default_rdf_join_entries_sort_mediators_main = new ((__quadstore_comunica_require__("../node_modules/@comunica/mediator-race/lib/index.js").MediatorRace))({
  'name': 'urn:comunica:default:rdf-join-entries-sort/mediators#main',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join_entries_sort__2_0_0_components_ActorRdfJoinEntriesSort_jsonld_ActorRdfJoinEntriesSort_default_bus
});
const urn_comunica_default_rdf_update_quads_actors_rdfjs_store = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-update-quads-rdfjs-store/lib/index.js").ActorRdfUpdateQuadsRdfJsStore))({
  'name': 'urn:comunica:default:rdf-update-quads/actors#rdfjs-store',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_update_quads__2_0_0_components_ActorRdfUpdateQuads_jsonld_ActorRdfUpdateQuads_default_bus
});
const urn_comunica_default_rdf_update_quads_mediators_main = new ((__quadstore_comunica_require__("../node_modules/@comunica/mediator-race/lib/index.js").MediatorRace))({
  'name': 'urn:comunica:default:rdf-update-quads/mediators#main',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_update_quads__2_0_0_components_ActorRdfUpdateQuads_jsonld_ActorRdfUpdateQuads_default_bus
});
const urn_comunica_default_rdf_join_mediators_main = new ((__quadstore_comunica_require__("../node_modules/@comunica/mediator-join-coefficients-fixed/lib/index.js").MediatorJoinCoefficientsFixed))({
  'cpuWeight': 1,
  'memoryWeight': 1,
  'timeWeight': 10,
  'ioWeight': 100,
  'name': 'urn:comunica:default:rdf-join/mediators#main',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join__2_0_0_components_ActorRdfJoin_jsonld_ActorRdfJoin_default_bus
});
const urn_comunica_default_rdf_resolve_quad_pattern_mediators_main = new ((__quadstore_comunica_require__("../node_modules/@comunica/mediator-race/lib/index.js").MediatorRace))({
  'name': 'urn:comunica:default:rdf-resolve-quad-pattern/mediators#main',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_resolve_quad_pattern__2_0_0_components_ActorRdfResolveQuadPattern_jsonld_ActorRdfResolveQuadPattern_default_bus
});
const urn_comunica_default_rdf_resolve_quad_pattern_actors_rdfjs_source = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-resolve-quad-pattern-rdfjs-source/lib/index.js").ActorRdfResolveQuadPatternRdfJsSource))({
  'name': 'urn:comunica:default:rdf-resolve-quad-pattern/actors#rdfjs-source',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_resolve_quad_pattern__2_0_0_components_ActorRdfResolveQuadPattern_jsonld_ActorRdfResolveQuadPattern_default_bus
});
const urn_comunica_default_query_operation_actors_ask = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-ask/lib/index.js").ActorQueryOperationAsk))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#ask',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_distinct = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-distinct-hash/lib/index.js").ActorQueryOperationDistinctHash))({
  'mediatorHashBindings': urn_comunica_default_hash_bindings_mediators_main,
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#distinct',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_bgp = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-bgp-join/lib/index.js").ActorQueryOperationBgpJoin))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#bgp',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_construct = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-construct/lib/index.js").ActorQueryOperationConstruct))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#construct',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_describe = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-describe-subject/lib/index.js").ActorQueryOperationDescribeSubject))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#describe',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_extend = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-extend/lib/index.js").ActorQueryOperationExtend))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#extend',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_from = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-from-quad/lib/index.js").ActorQueryOperationFromQuad))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#from',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_filter = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-filter-sparqlee/lib/index.js").ActorQueryOperationFilterSparqlee))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#filter',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_group = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-group/lib/index.js").ActorQueryOperationGroup))({
  'mediatorHashBindings': urn_comunica_default_hash_bindings_mediators_main,
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#group',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_nop = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-nop/lib/index.js").ActorQueryOperationNop))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#nop',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_orderby = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-orderby-sparqlee/lib/index.js").ActorQueryOperationOrderBySparqlee))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#orderby',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_project = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-project/lib/index.js").ActorQueryOperationProject))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#project',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_service = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-service/lib/index.js").ActorQueryOperationService))({
  'forceSparqlEndpoint': false,
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#service',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_slice = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-slice/lib/index.js").ActorQueryOperationSlice))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#slice',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_reduced = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-reduced-hash/lib/index.js").ActorQueryOperationReducedHash))({
  'mediatorHashBindings': urn_comunica_default_hash_bindings_mediators_main,
  'cacheSize': 100,
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#reduced',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_union = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-union/lib/index.js").ActorQueryOperationUnion))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#union',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_path_inv = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-path-inv/lib/index.js").ActorQueryOperationPathInv))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#path-inv',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_path_alt = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-path-alt/lib/index.js").ActorQueryOperationPathAlt))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#path-alt',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_path_nps = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-path-nps/lib/index.js").ActorQueryOperationPathNps))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#path-nps',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_path_link = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-path-link/lib/index.js").ActorQueryOperationPathLink))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#path-link',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_path_one_or_more = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-path-one-or-more/lib/index.js").ActorQueryOperationPathOneOrMore))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#path-one-or-more',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_path_zero_or_more = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-path-zero-or-more/lib/index.js").ActorQueryOperationPathZeroOrMore))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#path-zero-or-more',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_update_add = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-update-add-rewrite/lib/index.js").ActorQueryOperationAddRewrite))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#update-add',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_path_zero_or_one = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-path-zero-or-one/lib/index.js").ActorQueryOperationPathZeroOrOne))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#path-zero-or-one',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_update_composite = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-update-compositeupdate/lib/index.js").ActorQueryOperationUpdateCompositeUpdate))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#update-composite',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_update_copy = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-update-copy-rewrite/lib/index.js").ActorQueryOperationCopyRewrite))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#update-copy',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_update_move = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-update-move-rewrite/lib/index.js").ActorQueryOperationMoveRewrite))({
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#update-move',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_init_actors_query = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-init-query/lib/index-browser.js").ActorInitQuery))({
  'mediatorOptimizeQueryOperation': urn_comunica_default_optimize_query_operation_mediators_main,
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'mediatorQueryParse': urn_comunica_default_query_parse_mediators_main,
  'mediatorQueryResultSerialize': urn_comunica_default_query_result_serialize_mediators_serialize,
  'mediatorQueryResultSerializeMediaTypeCombiner': urn_comunica_default_query_result_serialize_mediators_mediaType,
  'mediatorQueryResultSerializeMediaTypeFormatCombiner': urn_comunica_default_query_result_serialize_mediators_mediaTypeFormat,
  'mediatorContextPreprocess': urn_comunica_default_context_preprocess_mediators_main,
  'mediatorHttpInvalidate': urn_comunica_default_http_invalidate_mediators_main,
  'logger': df_357_1,
  'defaultQueryInputFormat': 'sparql',
  'contextKeyShortcuts': {"baseIRI":"@comunica/actor-init-query:baseIRI","datetime":"@comunica/actor-http-memento:datetime","destination":"@comunica/bus-rdf-update-quads:destination","explain":"@comunica/actor-init-query:explain","extensionFunctionCreator":"@comunica/actor-init-query:extensionFunctionCreator","extensionFunctions":"@comunica/actor-init-query:extensionFunctions","fetch":"@comunica/bus-http:fetch","httpAuth":"@comunica/bus-http:auth","httpBodyTimeout":"@comunica/bus-http:http-body-timeout","httpIncludeCredentials":"@comunica/bus-http:include-credentials","httpProxyHandler":"@comunica/actor-http-proxy:httpProxyHandler","httpTimeout":"@comunica/bus-http:http-timeout","initialBindings":"@comunica/actor-init-query:initialBindings","lenient":"@comunica/actor-init-query:lenient","log":"@comunica/core:log","queryFormat":"@comunica/actor-init-query:queryFormat","queryTimestamp":"@comunica/actor-init-query:queryTimestamp","readOnly":"@comunica/bus-query-operation:readOnly","source":"@comunica/bus-rdf-resolve-quad-pattern:source","sources":"@comunica/bus-rdf-resolve-quad-pattern:sources","unionDefaultGraph":"@comunica/bus-query-operation:unionDefaultGraph"},
  'name': 'urn:comunica:default:init/actors#query',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_init__2_0_0_components_ActorInit_jsonld_ActorInit_default_bus
});
const urn_comunica_default_rdf_join_actors_minus_hash = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-minus-hash/lib/index.js").ActorRdfJoinMinusHash))({
  'mediatorJoinSelectivity': urn_comunica_default_rdf_join_selectivity_mediators_main,
  'name': 'urn:comunica:default:rdf-join/actors#minus-hash',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join__2_0_0_components_ActorRdfJoin_jsonld_ActorRdfJoin_default_bus
});
const urn_comunica_default_rdf_join_actors_minus_hash_undef = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-minus-hash-undef/lib/index.js").ActorRdfJoinMinusHashUndef))({
  'mediatorJoinSelectivity': urn_comunica_default_rdf_join_selectivity_mediators_main,
  'name': 'urn:comunica:default:rdf-join/actors#minus-hash-undef',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join__2_0_0_components_ActorRdfJoin_jsonld_ActorRdfJoin_default_bus
});
const urn_comunica_default_rdf_join_actors_optional_bind = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-optional-bind/lib/index.js").ActorRdfJoinOptionalBind))({
  'bindOrder': 'depth-first',
  'selectivityModifier': 0.0001,
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'mediatorJoinSelectivity': urn_comunica_default_rdf_join_selectivity_mediators_main,
  'name': 'urn:comunica:default:rdf-join/actors#optional-bind',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join__2_0_0_components_ActorRdfJoin_jsonld_ActorRdfJoin_default_bus
});
const urn_comunica_default_rdf_join_actors_optional_nested_loop = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-optional-nestedloop/lib/index.js").ActorRdfJoinOptionalNestedLoop))({
  'mediatorJoinSelectivity': urn_comunica_default_rdf_join_selectivity_mediators_main,
  'name': 'urn:comunica:default:rdf-join/actors#optional-nested-loop',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join__2_0_0_components_ActorRdfJoin_jsonld_ActorRdfJoin_default_bus
});
const urn_comunica_default_rdf_join_actors_inner_none = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-inner-none/lib/index.js").ActorRdfJoinNone))({
  'mediatorJoinSelectivity': urn_comunica_default_rdf_join_selectivity_mediators_main,
  'name': 'urn:comunica:default:rdf-join/actors#inner-none',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join__2_0_0_components_ActorRdfJoin_jsonld_ActorRdfJoin_default_bus
});
const urn_comunica_default_rdf_join_actors_inner_single = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-inner-single/lib/index.js").ActorRdfJoinSingle))({
  'mediatorJoinSelectivity': urn_comunica_default_rdf_join_selectivity_mediators_main,
  'name': 'urn:comunica:default:rdf-join/actors#inner-single',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join__2_0_0_components_ActorRdfJoin_jsonld_ActorRdfJoin_default_bus
});
const urn_comunica_default_rdf_join_actors_inner_multi_empty = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-inner-multi-empty/lib/index.js").ActorRdfJoinMultiEmpty))({
  'mediatorJoinSelectivity': urn_comunica_default_rdf_join_selectivity_mediators_main,
  'name': 'urn:comunica:default:rdf-join/actors#inner-multi-empty',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join__2_0_0_components_ActorRdfJoin_jsonld_ActorRdfJoin_default_bus
});
const urn_comunica_default_rdf_join_actors_inner_hash = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-inner-hash/lib/index.js").ActorRdfJoinHash))({
  'mediatorJoinSelectivity': urn_comunica_default_rdf_join_selectivity_mediators_main,
  'name': 'urn:comunica:default:rdf-join/actors#inner-hash',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join__2_0_0_components_ActorRdfJoin_jsonld_ActorRdfJoin_default_bus
});
const urn_comunica_default_rdf_join_actors_inner_symmetric_hash = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-inner-symmetrichash/lib/index.js").ActorRdfJoinSymmetricHash))({
  'mediatorJoinSelectivity': urn_comunica_default_rdf_join_selectivity_mediators_main,
  'name': 'urn:comunica:default:rdf-join/actors#inner-symmetric-hash',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join__2_0_0_components_ActorRdfJoin_jsonld_ActorRdfJoin_default_bus
});
const urn_comunica_default_rdf_join_actors_inner_nested_loop = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-inner-nestedloop/lib/index.js").ActorRdfJoinNestedLoop))({
  'mediatorJoinSelectivity': urn_comunica_default_rdf_join_selectivity_mediators_main,
  'name': 'urn:comunica:default:rdf-join/actors#inner-nested-loop',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join__2_0_0_components_ActorRdfJoin_jsonld_ActorRdfJoin_default_bus
});
const urn_comunica_default_rdf_join_actors_inner_multi_bind = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-inner-multi-bind/lib/index.js").ActorRdfJoinMultiBind))({
  'bindOrder': 'depth-first',
  'selectivityModifier': 0.0001,
  'mediatorJoinEntriesSort': urn_comunica_default_rdf_join_entries_sort_mediators_main,
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'mediatorJoinSelectivity': urn_comunica_default_rdf_join_selectivity_mediators_main,
  'name': 'urn:comunica:default:rdf-join/actors#inner-multi-bind',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join__2_0_0_components_ActorRdfJoin_jsonld_ActorRdfJoin_default_bus
});
const urn_comunica_default_query_operation_actors_update_clear = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-update-clear/lib/index.js").ActorQueryOperationClear))({
  'mediatorUpdateQuads': urn_comunica_default_rdf_update_quads_mediators_main,
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#update-clear',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_update_drop = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-update-drop/lib/index.js").ActorQueryOperationDrop))({
  'mediatorUpdateQuads': urn_comunica_default_rdf_update_quads_mediators_main,
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#update-drop',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_update_delete_insert = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-update-deleteinsert/lib/index.js").ActorQueryOperationUpdateDeleteInsert))({
  'mediatorUpdateQuads': urn_comunica_default_rdf_update_quads_mediators_main,
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#update-delete-insert',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_update_create = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-update-create/lib/index.js").ActorQueryOperationCreate))({
  'mediatorUpdateQuads': urn_comunica_default_rdf_update_quads_mediators_main,
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#update-create',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_update_load = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-update-load/lib/index.js").ActorQueryOperationLoad))({
  'mediatorUpdateQuads': urn_comunica_default_rdf_update_quads_mediators_main,
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#update-load',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_join = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-join/lib/index.js").ActorQueryOperationJoin))({
  'mediatorJoin': urn_comunica_default_rdf_join_mediators_main,
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#join',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_leftjoin = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-leftjoin/lib/index.js").ActorQueryOperationLeftJoin))({
  'mediatorJoin': urn_comunica_default_rdf_join_mediators_main,
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#leftjoin',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_minus = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-minus/lib/index.js").ActorQueryOperationMinus))({
  'mediatorJoin': urn_comunica_default_rdf_join_mediators_main,
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#minus',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_query_operation_actors_path_seq = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-path-seq/lib/index.js").ActorQueryOperationPathSeq))({
  'mediatorJoin': urn_comunica_default_rdf_join_mediators_main,
  'mediatorQueryOperation': urn_comunica_default_query_operation_mediators_main,
  'name': 'urn:comunica:default:query-operation/actors#path-seq',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_rdf_join_actors_inner_multi_smallest = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-join-inner-multi-smallest/lib/index.js").ActorRdfJoinMultiSmallest))({
  'mediatorJoinEntriesSort': urn_comunica_default_rdf_join_entries_sort_mediators_main,
  'mediatorJoin': urn_comunica_default_rdf_join_mediators_main,
  'mediatorJoinSelectivity': urn_comunica_default_rdf_join_selectivity_mediators_main,
  'name': 'urn:comunica:default:rdf-join/actors#inner-multi-smallest',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_join__2_0_0_components_ActorRdfJoin_jsonld_ActorRdfJoin_default_bus
});
const urn_comunica_default_query_operation_actors_quadpattern = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-query-operation-quadpattern/lib/index.js").ActorQueryOperationQuadpattern))({
  'mediatorResolveQuadPattern': urn_comunica_default_rdf_resolve_quad_pattern_mediators_main,
  'unionDefaultGraph': false,
  'name': 'urn:comunica:default:query-operation/actors#quadpattern',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_query_operation__2_0_0_components_ActorQueryOperation_jsonld_ActorQueryOperation_default_bus
});
const urn_comunica_default_rdf_resolve_quad_pattern_actors_federated = new ((__quadstore_comunica_require__("../node_modules/@comunica/actor-rdf-resolve-quad-pattern-federated/lib/index.js").ActorRdfResolveQuadPatternFederated))({
  'mediatorResolveQuadPattern': urn_comunica_default_rdf_resolve_quad_pattern_mediators_main,
  'skipEmptyPatterns': false,
  'name': 'urn:comunica:default:rdf-resolve-quad-pattern/actors#federated',
  'bus': https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_rdf_resolve_quad_pattern__2_0_0_components_ActorRdfResolveQuadPattern_jsonld_ActorRdfResolveQuadPattern_default_bus
});
const urn_comunica_default_Runner = (https___linkedsoftwaredependencies_org_bundles_npm__comunica_bus_init__2_0_0_components_ActorInit_jsonld_ActorInit_default_bus, [
  urn_comunica_default_hash_bindings_actors_sha1,
  urn_comunica_default_context_preprocess_actors_source_to_destination,
  urn_comunica_default_optimize_query_operation_actors_join_bgp,
  urn_comunica_default_optimize_query_operation_actors_bgp_to_join,
  urn_comunica_default_optimize_query_operation_actors_join_connected,
  urn_comunica_default_init_actors_query,
  urn_comunica_default_query_parse_actors_sparql,
  urn_comunica_default_rdf_join_selectivity_actors_variable_counting,
  urn_comunica_default_rdf_join_entries_sort_actors_cardinality,
  urn_comunica_default_rdf_update_quads_actors_rdfjs_store,
  urn_comunica_default_query_operation_actors_ask,
  urn_comunica_default_query_operation_actors_distinct,
  urn_comunica_default_query_operation_actors_bgp,
  urn_comunica_default_query_operation_actors_construct,
  urn_comunica_default_query_operation_actors_describe,
  urn_comunica_default_query_operation_actors_extend,
  urn_comunica_default_query_operation_actors_from,
  urn_comunica_default_query_operation_actors_filter,
  urn_comunica_default_query_operation_actors_group,
  urn_comunica_default_query_operation_actors_join,
  urn_comunica_default_query_operation_actors_leftjoin,
  urn_comunica_default_query_operation_actors_minus,
  urn_comunica_default_query_operation_actors_nop,
  urn_comunica_default_query_operation_actors_orderby,
  urn_comunica_default_query_operation_actors_quadpattern,
  urn_comunica_default_query_operation_actors_project,
  urn_comunica_default_query_operation_actors_service,
  urn_comunica_default_query_operation_actors_slice,
  urn_comunica_default_query_operation_actors_reduced,
  urn_comunica_default_query_operation_actors_union,
  urn_comunica_default_query_operation_actors_values,
  urn_comunica_default_query_operation_actors_path_inv,
  urn_comunica_default_query_operation_actors_path_alt,
  urn_comunica_default_query_operation_actors_path_seq,
  urn_comunica_default_query_operation_actors_path_nps,
  urn_comunica_default_query_operation_actors_path_link,
  urn_comunica_default_query_operation_actors_path_one_or_more,
  urn_comunica_default_query_operation_actors_path_zero_or_more,
  urn_comunica_default_query_operation_actors_update_clear,
  urn_comunica_default_query_operation_actors_update_add,
  urn_comunica_default_query_operation_actors_path_zero_or_one,
  urn_comunica_default_query_operation_actors_update_composite,
  urn_comunica_default_query_operation_actors_update_drop,
  urn_comunica_default_query_operation_actors_update_delete_insert,
  urn_comunica_default_query_operation_actors_update_copy,
  urn_comunica_default_query_operation_actors_update_create,
  urn_comunica_default_query_operation_actors_update_move,
  urn_comunica_default_rdf_join_actors_minus_hash,
  urn_comunica_default_rdf_join_actors_minus_hash_undef,
  urn_comunica_default_query_operation_actors_update_load,
  urn_comunica_default_rdf_join_actors_optional_bind,
  urn_comunica_default_rdf_join_actors_optional_nested_loop,
  urn_comunica_default_rdf_resolve_quad_pattern_actors_federated,
  urn_comunica_default_rdf_resolve_quad_pattern_actors_rdfjs_source,
  urn_comunica_default_rdf_join_actors_inner_none,
  urn_comunica_default_rdf_join_actors_inner_single,
  urn_comunica_default_rdf_join_actors_inner_multi_empty,
  urn_comunica_default_rdf_join_actors_inner_multi_bind,
  urn_comunica_default_rdf_join_actors_inner_hash,
  urn_comunica_default_rdf_join_actors_inner_symmetric_hash,
  urn_comunica_default_rdf_join_actors_inner_nested_loop,
  urn_comunica_default_rdf_join_actors_inner_multi_smallest
]);
module.exports = urn_comunica_default_init_actors_query;



/***/ }),

/***/ "./src/index.js":
/***/ ((module, __unused_webpack_exports, __quadstore_comunica_require__) => {


__quadstore_comunica_require__("./src/crypto-polyfill.js");

const { QueryEngineBase } = __quadstore_comunica_require__("../node_modules/@comunica/actor-init-query/lib/index-browser.js");
const engine = new QueryEngineBase(__quadstore_comunica_require__("./src/engine.js"));

const empty = Object.create(null);

class Engine {

    constructor(store) {
        this.store = store;
        this.engine = engine;
    }

    getContext(context) {
        return {
            ...context,
            source: this.store,
            destination: this.store,
        };
    }

    query(query, context = empty) {
        return engine.query(query, this.getContext(context));
    }

    queryVoid(query, context = empty) {
        return engine.queryVoid(query, this.getContext(context));
    }

    queryBindings(query, context = empty) {
        return engine.queryBindings(query, this.getContext(context));
    }

    queryQuads(query, context = empty) {
        return engine.queryQuads(query, this.getContext(context));
    }

    queryBoolean(query, context = empty) {
        return engine.queryBoolean(query, this.getContext(context));
    }

}

module.exports.D = Engine;
module.exports.H = engine;


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __quadstore_comunica_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __quadstore_comunica_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __quadstore_comunica_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __quadstore_comunica_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__quadstore_comunica_modules__[moduleId].call(module.exports, module, module.exports, __quadstore_comunica_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/global */
/******/ (() => {
/******/ 	__quadstore_comunica_require__.g = (function() {
/******/ 		if (typeof globalThis === 'object') return globalThis;
/******/ 		try {
/******/ 			return this || new Function('return this')();
/******/ 		} catch (e) {
/******/ 			if (typeof window === 'object') return window;
/******/ 		}
/******/ 	})();
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module used 'module' so it can't be inlined
/******/ var __quadstore_comunica_exports__ = __quadstore_comunica_require__("./src/index.js");
/******/ var __quadstore_comunica_exports__Engine = __quadstore_comunica_exports__.D;
/******/ var __quadstore_comunica_exports___engine = __quadstore_comunica_exports__.H;
/******/ export { __quadstore_comunica_exports__Engine as Engine, __quadstore_comunica_exports___engine as __engine };
/******/ 
